% Type-preserving environment based
% interpreter
%
% Author: Brigitte Pientka

tp   : type.
nat  : tp.
bool : tp.

exp  : tp -> type.

tt   : exp bool.
ff   : exp bool.

z    : exp nat.
suc  : exp nat -> exp nat.
eq   : exp nat -> exp nat -> exp bool.

iff  : {T:tp} exp bool -> exp T -> exp T -> exp T.
letv : {T1:tp} {T2:tp} exp T1 -> (exp T1 -> exp T2) -> exp T2.

schema ctx = some [t:tp] exp t;

rec eval : (g:ctx) [g. exp bool] -> [. g] -> [. exp bool] =
fn e => fn env => [. tt] ;

%{ SUBSTITUTION VARIABLES

rec eval : (g:ctx) [g. exp bool] -> [. g] -> [. exp bool] =
fn e => fn env =>
 let [g. E ..] = e in
 let [ ] #S[..] = env in [. E #S[..]]
;

}%
% FN g => fn e => fn r => let sbox S[.] = r in
%     case e of
%         box(g. z) : (exp nat)[g] => box( . z)
%       | {U::(exp nat)[g]} box(g. suc U[id(g)]) : (exp nat)[g] =>
%         let
%             box( . V[.]) = eval [g] < . nat> box(g. U[id(g)]) r
%         in
%             box( . suc V[.])
%         end
%       | {T::tp[.]} {p::(exp T[.])[g]} box(g. p[id(g)]) : (exp T[.])[g] =>
%         box( . p[S[.]])
%       | {U::(exp nat)[g]}{V::(exp nat)[g]} box(g. eq U[id(g)] V[id(g)]) : (exp bool)[g] =>
%         let
%             box( . W1[.]) = eval [g] < . nat> box(g. U[id(g)]) r
%             box( . W2[.]) = eval [g] < . nat> box(g. V[id(g)]) r
%         in
%             if boxeq( . W1[.], W2[.]) then box( . tt) else box( . ff)
%         end
%       | {T1::tp[.]}{T2::tp[.]}{W::(exp T1[.])[g]}{U::(exp T2[.])[g]}
%         box(g . letv T1[.] T2[.] W[id(g)] (\x. U[id(g), x])) : (exp T2[.])[g] =>
%             let
%                 box V[.] = eval [g] < . T1[.]> (box g.W[id(g)]) r
%             in
%                 eval [g,x:exp T1[.]]  < . T2[.]> box(g,x. U[id(g),x]) (sbox S[.], V[.])
%             end;
