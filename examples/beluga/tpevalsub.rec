% Type-preserving substitution-based interpreter
%
% Author: Brigitte Pientka
%
% TODO extend with functions and function application

tp   : type.
nat  : tp.
bool : tp.

exp  : tp -> type.  

tt   : exp bool.
ff   : exp bool.

z    : exp nat.
suc  : exp nat -> exp nat.
eq   : exp nat -> exp nat -> exp bool.

iff   : exp bool -> exp T -> exp T -> exp T.
letv :  exp T1 -> (exp T1 -> exp T2) -> exp T2.

rec equal : (exp nat)[.] -> (exp nat)[.] -> (exp bool)[.] =
fn x => fn y => 
  case x of
    box(. . z) : (exp nat)[.] => 
      (case y of
          box(. . z)  => box(. tt)

       | box(. . suc U![.]!) => box(. ff))

  | box(. . suc U![.]!) => 
      (case y of
         box(. . z)  => box(. ff)
      |  box(. . suc V![.]!) 
            => equal box(. U![.]!) box(. V![.]!))
;




rec eval : (exp T![.]!)[.] -> (exp T![.]!)[.] = 
% mlam S => 
 fn e => 
  case e of 
    box(. . tt) => box(. tt)

  | box(. . ff) => box(. ff)

  | box(. . z)  => box(. z)

  | box(. . suc U![.]!) => 
         (case eval  box(. U![.]!) of
             box(. . V![.]!)  => box(. suc V![.]!))


 | box(. . eq U![.]! V![.]!) =>
         equal (eval box(. U![.]!)) 
               (eval  box(. V![.]!))

   | 
     box(. . iff  U![.]! V![.]! W![.]!)  =>
         (case eval box(. U![.]!) of
             box(. . tt) 
	        => eval box(. V![.]!)
           | box(. . ff) 
	      => eval box(. W![.]!))

   | box(. . letv  U![.]! (\ x . W![., x]!))  =>

         (case eval  box(. U![.]!) of
             box(. . V![.]!) 
             => eval box(. W![ ., V![.]! ]!))
;
