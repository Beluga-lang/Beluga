%{
  CH 6:  Lambda-terms
  Author: Brigitte Pientka

  SYNTAX
}%

datatype term: type = 
| lam: (term -> term) -> term
| app: term -> term -> term;

datatype value:  term -> type = 
| v_lam: value (lam M);

% ---------------------------------------------------------- %
% Small-step operational semantics

datatype step: term -> term -> type = 
| e_app_1    : step M1 M1'
             -> step (app M1 M2) (app M1' M2)
| e_app_2    : step M2 M2' -> value M1              
              -> step (app M1 M2) (app M1 M2')
| e_app_abs : value M2
              -> step (app (lam M) M2) (M M2)
;
             

datatype equal : term -> term -> type = 
| refl: equal M M;

not_possible : type.

rec values_dont_step : [ |- step M M' ] -> [ |- value M  ] -> [ |- not_possible]=
/ total v (values_dont_step m m' s v)/
fn s => fn v => case v of
| [ |- v_lam] => impossible s in []
;


rec unique : [|- step M M1] -> [|- step M M2] -> [|- equal M1 M2 ] =
/ total s (unique m m1 m2 s)/
fn s1 => fn s2 => case s1 of
| [ |- e_app_1 DstepE1'] => 
   (case s2 of 
    | [|- e_app_1 DstepE1''] =>
      let [ |- refl] = unique [ |- DstepE1'] [|- DstepE1''] in
         [ |- refl]
    | [|- e_app_2 DstepE2'' V1] => 
      impossible values_dont_step [|- DstepE1'] [|- V1] in []
    | [|- e_app_abs V2] =>    
      impossible values_dont_step [|- DstepE1'] [|- v_lam] in []
  )
| [ |- e_app_2 DstepE2' V1 ] => 
   (case s2 of 
    | [|- e_app_2 DstepE2'' _] =>
      let [ |- refl] = unique [ |- DstepE2'] [|- DstepE2''] in
        [ |- refl]
    | [|- e_app_1 DstepE1''] => 
      impossible values_dont_step [|- DstepE1''] [|- V1] in []
    | [|- e_app_abs V2] => 
      impossible values_dont_step [|- DstepE2'] [|- V2] in []
   )

| [ |- e_app_abs V2] => 
  (case s2 of 
   | [|- e_app_abs _ ] =>  [ |- refl]
   | [|- e_app_1 DstepE1'] =>
      impossible values_dont_step [|- DstepE1'] [|- v_lam] in []
   | [|- e_app_2 DstepE2'' V1] => 
      impossible values_dont_step [|- DstepE2''] [|- V2] in []
  )

;
