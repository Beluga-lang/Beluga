% Cut-admissibility as a function
% Author: Brigitte Pientka
% This proof does not coverage check
% See cut-elim-crec-cover.bel .

i : type.  % individuals
%name i S.
o : type.  % formulas
%name o A.

imp    : o -> o -> o.
not    : o -> o.
true   : o.
forall : (i -> o) -> o.

hyp  : o -> type.  % Hypotheses (left)
conc : o -> type.  % Conclusion (right)

axiom   : (hyp A -> conc A).
truer   : conc (true).
impr    : (hyp A -> conc B) -> conc (imp A B).
impl    : conc A -> (hyp B -> conc C) -> (hyp (imp A B) -> conc C).
notr    : ({p:o}hyp A -> conc p) -> conc (not A).
notl    : conc A -> (hyp (not A) -> conc C).
forallr : ({a:i} conc (A a)) -> conc (forall (\x. A x)).
foralll : {T:i}(hyp (A T) -> conc C) -> (hyp (forall (\x . A x)) -> conc C).

schema ctx = some [a: o] hyp a + i + o;

rec lemma: (g:ctx)[g, u:hyp true |-  conc (C ..)] -> [g |- conc (C .. )] =
fn d => case d of
| [g,h:hyp true |-  truer]  => [g |- truer]
| [g,h:hyp true |-  axiom (H ..)] => [g |- axiom (H ..)]
| [g,h:hyp true |-  axiom h] => [g |- truer]
| [g,h:hyp true |-  impr (\v. D .. v h)] =>
  let [g,v:hyp _ |-  E .. v] = lemma [g,v:hyp _, h:hyp true |-  D .. v h] in
   [g |- impr (\v. E .. v)]

| [g,h:hyp true |-  notr (\p.\v. D .. p v h)] =>
  let [g,p:o, v:hyp _  |-  E .. p v] = lemma [g, p:o, v:hyp _, h:hyp true |-  D .. p v h] in
   [g |- notr (\p.\v. E .. p v)]

| [g,h:hyp true |-  forallr (\a. D .. a h)] =>
  let [g,a:i |-  E .. a] = lemma [g,a:i, h:hyp true |-  D .. a h] in
   [g |- forallr (\a. E .. a)]

| [g,h:hyp true |-  impl (D1 .. h) (\y. D2 .. y h) (H ..)] =>
  let [g |- E1 ..] = lemma [g, h:hyp true |-  D1 .. h] in
  let [g,y:hyp _  |-  E2 .. y] = lemma [g,y:hyp _ , h:hyp true |-  D2 .. y h] in
   [g |- impl (E1 ..) (\y. E2 .. y) (H ..)]


| [g,h:hyp true |-  impl (D1 .. h) (\y. D2 .. y h) (H ..)] =>
  let [g |- E1 ..] = lemma [g, h:hyp true |-  D1 .. h] in
  let [g,y:hyp _  |-  E2 .. y] = lemma [g,y:hyp _ , h:hyp true |-  D2 .. y h] in
   [g |- impl (E1 ..) (\y. E2 .. y) (H ..)]

| [g,h:hyp true |-  notl (D1 .. h) (H ..)] =>
  let [g |- E1 ..] = lemma [g, h:hyp true |-  D1 .. h] in
   [g |- notl (E1 ..) (H ..)]

| [g,h:hyp true |-  foralll (T ..) (\y. D1 .. y h) (H ..)] =>
  let [g, v: hyp _  |-  E1 .. v] = lemma [g, v: hyp _ , h:hyp true |-  D1 .. v h] in
   [g |- foralll (T .. ) (\y. E1 .. y) (H ..)]

;




rec ca : (g:ctx){A:[g |- o]} [g |- conc (A ..)] -> [g, u: hyp (A .. ) |-  conc (C ..)]
       -> [g |- conc (C ..)] =
mlam A' => fn d => fn e => case e of
 | [g, h:hyp (B ..) |-  axiom (H1 ..)] =>  [g |- axiom (H1 ..)]

 | [g, h:hyp (A ..) |-  axiom h]  => d

 |[g, h:hyp (A ..) |-  impr (\h1. E2 .. h1 h)] =>
   let [g |- D ..]  = d in
   let [g, h1: hyp (B1 ..) |-  E2' .. h1] =
     ca  [g,h1: hyp _  |-  A .. ]
        [g, h1 |-  D .. ]
        [g, h1, h |-  E2 .. h1 h]
   in
    [g |- impr (\h1. E2' .. h1)]

 | [g, h:hyp (A ..) |-  impl (E1 .. h) (\h2. E2 .. h2 h) (H ..)] =>
   let [g |- D ..] = d in
   let [g |- E1' ..] = ca  [g |- A .. ] d [g, h |-  E1 .. h] in
   let [g,h2: hyp (B2 ..) |-  E2' .. h2] =
       ca  [g,h2: hyp _   |-  A .. ] [g,h2 |- D ..] [g, h2, h |-  E2 .. h2 h]
   in
    [g |- impl (E1' ..) (\h2. E2' .. h2) (H ..)]

 | [g, h:hyp (A ..) |-  notr (\p.\h1. E1 .. h p h1)] =>
   let [g |- D ..] = d in
   let [g, p:o, h1: hyp (B1 ..) |-  E1' .. p h1] =
     ca  [g,p:o, h1:hyp _   |-  A ..]
        [g,p,h1 |-  D ..] [g,p,h1,h |-  E1 .. h p h1]
   in
     [g |- notr (\p.\h1. E1' .. p h1)]

 | [g, h:hyp (A ..) |-  notl (E1 .. h) (H ..)] =>
   let [g |- E1' ..] = ca  [g |- A .. ] d [g, h |-  E1 .. h] in
     [g |- notl (E1' ..) (H ..)]

 | [g,h: hyp (A ..) |-  truer] => [g |- truer]

 | [g,h:hyp (A ..) |-  forallr (\a. E1 .. a h)] =>
   let [g |- D ..] = d in
   let [g,a:i |-  E1' .. a] =
     ca  [g,a:i  |-  A .. ]  [g,a |- D ..] [g,a, h |-  E1 .. a h]
   in
    [g |- forallr \a. E1' .. a]

 | [g, h:hyp (A ..) |-  foralll (T ..) (\h1.E1 .. h h1) (H ..)] =>
   let [g |- D ..] = d in
   let [g,h1: hyp _  |-  E1' .. h1] =
     ca  [g,h1: hyp _  |-  A ..] [g,h1 |- D .. ] [g,h1,h |-  E1 .. h h1]
   in
     [g |- foralll (T ..) (\h1. E1' .. h1) (H ..)]

 | [g, h:hyp (not (A1 ..)) |-  notl (E1 .. h) h] =>
   let [g |- notr \p.\h2. (D1 .. p h2)]  = d in
   let [g |- F1 ..] = ca  [g |- A' .. ] d  [g,h |- E1 .. h] in
   let [g,p:o |-  F2 .. p] = ca  [g, p:o |-  A1 .. ] [g,p |- F1 ..] [g,p,h1 |-  D1 .. p h1] in
     [g |- F2 .. _]

 | [g, h:hyp (forall (\x  .   A1 .. x)) |- foralll (T ..) (\h1. E1 .. h h1) h] =>
   let [g |- forallr \a. D1 .. a] = d in
   let [g,h2: hyp _  |-  E1' .. h2] =
     ca  [g,h2 : hyp _  |-  A' ..]  [g,h2 |- forallr \a. D1 .. a]   [g, h2, h |-  E1 .. h h2]
   in
    ca [g |- A1 .. (T ..) ] [g |- D1 .. (T ..)] [g,h2 |- E1' .. h2]


 | [g, h:hyp (imp (A1 ..) (A2 ..)) |-  impl (E1 .. h) (\h2. E2 .. h h2) h]  =>
   let [g |- impr \h1. D2 .. h1]  = d in
   let [g |- E1' ..] = ca  [g |- A' .. ] d [g,h |- E1 .. h] in
   let [g,h2: hyp (A2 ..) |-  E2' .. h2] =
     ca [g,h2 : hyp (A2 ..) |-  A' .. ]
       [g,h2 |- impr \h1. D2 .. h1] [g,h2,h |-  E2 .. h h2] in
   let [g |- D2' ..] = ca  [g |- A1 .. ] [g |- E1' .. ] [g,h1 |- D2 .. h1] in
     ca  [g |- A2 .. ] [g |- D2' .. ] [g,h2 |- E2' .. h2]

 | [g, h:hyp (A ..) |-  E .. h] =>
   case d of
    | [g |- axiom (H ..)] =>   [g |- E .. (H ..)]

    | [g |- impl (D1 .. ) (\h2. D2 .. h2) (H ..)] =>
      let [g,h2: hyp (B2 ..) |-  D2' .. h2] = ca [g,h2: hyp _  |-  A .. ] [g,h2 |- D2 .. h2] [g,h2,h |-  E .. h] in
       [g |- impl (D1 ..) (\h2. D2' .. h2) (H ..)]

    | [g |- notl (D1 ..) (H ..)] => [g |- notl (D1 .. ) (H ..)]
%   | [g] notl (D1 ..) (H ..) => d  % is not working -bp

    | [g |- foralll (T ..) (\h1. D1 .. h1) (H ..)] =>
      let [g,h1: hyp _  |-  D1' .. h1] = ca [g,h1:hyp _  |-  A ..] [g,h1 |- D1 .. h1] [g,h1,h |-  E .. h] in
        [g |- foralll (T .. ) (\h1. D1' .. h1) (H ..)]

    | [g |- truer] =>  lemma [g, h: hyp (A ..) |-  E .. h]
%{      let [g,h:hyp true] F ..  = [g, h: hyp true] E .. h in
        [g] F ..
}%


;


% Original Twelf implementation
%
% ca : {A:o} conc A -> (hyp A -> conc C) -> conc C -> type.
% % mode ca +A +D +E -F.
%
% %% Axiom Conversions
%
% ca_axiom_l : ca A (axiom H) E (E H).
%
% ca_axiom_r : ca A D ([h:hyp A] axiom h) D.
% ca_imp  : ca (A1 imp A2) (impr D2)
% 	   ([h:hyp (A1 imp A2)] impl (E1 h) (E2 h) h) F
% 	   <- ca (A1 imp A2) (impr D2) E1 E1'
% 	   <- ({h2:hyp A2}
% 		 ca (A1 imp A2) (impr D2)
% 		 ([h:hyp (A1 imp A2)] E2 h h2) (E2' h2))
% 	   <- ca A1 E1' D2 D2'
% 	   <- ca A2 D2' E2' F.
% ca_not  : ca (not A1) (notr D1)
% 	   ([h:hyp (not A1)] notl (E1 h) h) (F2 C)
% 	   <- ca (not A1) (notr D1) E1 F1
% 	   <- ({p:o} ca A1 F1 ([h1:hyp A1] D1 p h1) (F2 p)).
%
%
% ca_forall : ca (forall A1) (forallr D1)
% 	     ([h:hyp (forall A1)] foralll T (E1 h) h) F
% 	     <- ({h2:hyp (A1 T)}
% 		   ca (forall A1) (forallr D1)
% 		   ([h:hyp (forall A1)] E1 h h2) (E1' h2))
% 	     <- ca (A1 T) (D1 T) E1' F.
%
% cal_impl   : ca A (impl D1 D2 H) E (impl D1 D2' H)
% 	      <- ({h2:hyp B2} ca A (D2 h2) E (D2' h2)).
%
% cal_notl   : ca A (notl D1 H) E (notl D1 H).
%
% cal_foralll : ca A (foralll T D1 H) E (foralll T D1' H)
% 	       <- ({h} ca A (D1 h) E (D1' h)).
%
% car_axiom : ca A D ([h:hyp A] axiom H1) (axiom H1).
%
% car_impr : ca A D ([h:hyp A] impr (E2 h)) (impr E2')
% 	    <- ({h1:hyp B1} ca A D ([h:hyp A] E2 h h1) (E2' h1)).
%
% car_impl : ca A D ([h:hyp A] impl (E1 h) (E2 h) H) (impl E1' E2' H)
% 	    <- ca A D E1 E1'
% 	    <- ({h2:hyp B2} ca A D ([h:hyp A] E2 h h2) (E2' h2)).
% car_notr : ca A D ([h:hyp A] notr (E1 h)) (notr E1')
% 	    <- ({p:o} {h1:hyp B1} ca A D ([h:hyp A] E1 h p h1) (E1' p h1)).
%
% car_notl : ca A D ([h:hyp A] notl (E1 h) H) (notl E1' H)
% 	    <- ca A D E1 E1'.
%
% car_truer: ca A D ([h:hyp A] truer) (truer).
%
% car_forallr : ca A D ([h:hyp A] forallr (E1 h)) (forallr E1')
% 	       <- ({a:i} ca A D ([h:hyp A] E1 h a) (E1' a)).
%
% car_foralll: ca A D ([h:hyp A] foralll T (E1 h) H) (foralll T E1' H)
% 	      <- ({h1} ca A D ([h:hyp A] E1 h h1) (E1' h1)).
