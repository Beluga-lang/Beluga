% Variable counting (see Pientka [POPL'08])
% Author:  Brigitte Pientka
%
% This example only uses weak higher-order abstract syntax.

tp  : type.
nat : tp.
bool: tp.

exp : tp -> type.
z   : exp nat.
s   : exp nat -> exp nat.

tt  : exp bool.

add : exp nat -> exp nat -> exp nat.
letv: {T1:tp}exp T1 -> (exp T1 -> exp T2) -> exp T2.


schema W = some [T:tp] block (exp T);


rec plus : (exp nat) [.] -> (exp nat) [.] -> (exp nat) [.] =
fn x => fn y =>
 (case x of
    box(. . z)  => y

  | box(. . s U ![.]!)  =>
    (case (plus box(. U![.]!) y) of
       box(. . V![.]!) : (exp nat)[.] 
       => box(. s V![.]!)));


rec cntV : {g:(W)*} (exp S![id]!)[g, x:(exp T![id]!)] -> (exp nat) [.] =
FN g => 
  fn e =>
  (case e of

      box(g,x : exp T'![id]! . tt)  => box(. z)

   | box(g,x : exp T2![id]! . #p![id]!)     
    => box(. z)

   | box(g,x : exp T'![id]! . x)  => box(. s z)


   | box(g,x : exp T'![id]! . z)   => box(. z)

   | box(g,x : exp T'![id]! . s W ![id, x]! )  => 
          cntV [g]   box(g,x . W![id, x]!)
%
%
%  NOT WORKING IF WE OMIT T1![id]! since from the pattern we simply infer
%  T1:tp[g, x:exp _]    and only later in the branch we learn that T1:tp[g].
%  
%%   | box(g,x : exp _ . letv  _ U1![id, x]! (\ y . U2![id, x, y]!)) =>
%%             plus (cntV [g]  box(g,x . U1![id, x]!)) 
%%                  (cntV [g, y:exp T1![id]!]  box(g,y,x . U2![id, x, y]!))
%
%

   | box(g,x : exp _ . letv T1![id]! U1![id, x]! (\ y . U2![id, x, y]!)) =>
             plus 
	     (cntV [g]  box(g,x . U1![id, x]!)) 
             (cntV [g, y:exp _]  box(g,y,x . U2![id, x, y]!))


   | box(g,x: exp _ . add U![id, x]! W![id, x]!)  =>
          plus (cntV [g] box(g,x . U![id, x]!))
               (cntV [g] box(g,x . W![id, x]!))

);


