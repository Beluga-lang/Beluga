nat : type.     
z : nat.
s : nat -> nat.

add : nat -> nat -> nat -> type. 
a_z : add z R R.
a_s : add N1 N2 N3 -> add (s N1) N2 (s N3).


less : nat -> nat -> type. 
l_one : less N (s N). 
l_trans : less N M -> less M O -> less N O.


rec plus1 : nat [] -> nat [] =
fn x => case x of
 | [] z => [] (s(z))
%{ | [] (s U) => 
   let [] V = plus1 ([] U ) in [] s V }%
;
%{
rec plus11 : {N::nat []} (add N (s z) N) [] =
mlam N => case ([] N) of
 | [] z => [] (a_z (s z))
;
}%
rec sumzr1 : {N::nat []} (add N z N) [] =
mlam N => case ([] N) of
 | [] z => [] (a_z z)
 | [] (s N) => 
   let [] F = sumzr1 < . N> in
     [] a_s F
;

let v1 = plus1 ([] z);

rec plus3 : nat [] -> nat [] =
fn x => case x of
 | [] z => [] (s(s(s(z))))
 | [] (s U) => 
   let [] V = plus3 ([] U ) in [] s V
;

rec zless :  (less z (s z)) []  = [] l_one
;

rec ssless : {N::nat []} (less N (s(s N))) [] =
mlam N =>
 let [] E = [] (l_one N) in
 let [] F = [] l_one (s N) in
 [] l_trans E F
;

rec oneplusone : nat [] -> nat [] =
fn y =>
   plus1 ([] s z)
;


rec snplusone : nat [] -> nat [] = 
fn x => case x of 
 | [] z => oneplusone ([] z)
 | [] (s A) => let [] B = [] s (s A) in plus1 ([] B);


rec sumzr : {N::nat []} (add N z N) [] =
mlam N => case ([] N) of
 | [] z => [] (a_z z)
 | [] (s N) => 
   let [] F = sumzr < . N> in
     [] a_s F
;

rec sumsr :{D1::(add Nat1 Nat2 Nat3)[]} (add Nat1 (s Nat2) (s Nat3))[] =
mlam D1 => case ([] D1) of
 | [] a_z E => [] (a_z (s E))
 | [] a_s I =>
   let [] H = sumsr < . I> in
     [] a_s H
;

let v2 = sumzr < . z>;

rec sumcom : {A::(add M N O)[]} (add N M O) [] =
mlam A => case ([] A) of
 | [] a_z E => sumzr < . E>
 | [] a_s F => 
    let [] G = sumcom < . F> in
       sumsr < . G>
;
