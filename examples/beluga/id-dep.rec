tp: type.
nat: tp.
arr: tp -> tp -> tp.

exp : tp -> type.
z : exp nat.
s  : exp nat -> exp nat.
lam : % {T1:tp}
      (exp T1 -> exp T2) -> exp (arr T1 T2).

rec identity : (exp nat)[.] -> (exp nat) [.] =
    fn x =>
      case x of
          box (. . z)  => box (. z)
        | box (. . s U ![ . ]! )  => box (. s U ![ . ]! );


schema w = some [T:tp] block exp T;


rec identity' : {g:(w)*} (exp T ![ id ]! )[g] -> (exp T ![ id]! ) [g] =
FN g => % mlam T => 
    fn x =>
      case x of
          box (g. z)    => box (g. z)
        | box (g. s U![ id]! )  => box (g. s U![id]! )

	| box(g. #p![id]!) 
	 =>  box(g. #p![id]!)

	| box(g. #p![id]!) % : (exp S![id]!)[g] 
	=>   box(g. #p![id]!)
;


rec copy : {g:(w)*} (exp T ![id]! )[g] -> (exp T ![id]! ) [g] =
FN g =>  % mlam T => 
    fn x =>
      case x of

          box (g. z)   => box (g. z)

        | box (g. s U ![id]! )  => 
	   (case (copy [g] (box(g. U![id]!))) of
	      box (g. V ![id]! ) => box(g. s V![id]!))

        | box(g . lam (\ x. E![id , x]!))  => 
              box(g . lam  (\ x. E![id , x]!)) 					  

        | box(g . lam (\ x. E![id , x]!))  => 
	   x

 	| box(g. #p![id]!) => box(g. #p![id]!)
;
