/* Since SASyLF was originally written in Java and the Sasybel syntaxt is modeled to it comments are made like in Java, beginning by  and ending by , the star can't appear in a comment. */

/* The terinal declaration is put at the top of the file, it consit of the keyword "terminals" and a list of terms, this will used for Sasybel to detect what is a type or a symbol. The terminal declaration is necessary, it can always be empty though. */
terminals z suc

/* Before declaring any type the keyword syntax is needed. Types are declared with the following syntax: type := <alternative> | <alternative> | <alternative> .... There is no upper bound on the number of alternatives, and order does not matter. */

syntax

nat  ::= z
  | suc nat

/* The syntax for a judgement is: judgment <judgment_name> : <premise> ; . The judgment name can be any string starting by a character. The premise is made of two types of words types and symbols, if a word hasn't previously been declared as a type it will be assumed that its a symbol, and it will be ignored when translating. Terminals should not appear in the premisse of a judgment. The ";" at the end is necessary since this how Sasybels knows that the premise is finshed. A judgment is follow by one or more rules. */

judgment value: nat + nat = nat;

/* Rules can consist of only a conclusion, in this case the inference line consist of a finite sequence of "-" and the name of the rule is located at the end of it. Here again the premise must end by a ";", but in this case the premise can be composed of alternatives and symbols that were previously declare in the judgments. */

---------------- sum-z
z + (N ) = (N) ;

/* Rules can also have many premises, these also must end with a ";" they can be separated by any whitespace. */

N1 + N2 = N3 ;
-------------------------- sum-s
(suc N1) + N2 = (suc N3);

judgment less : nat < nat ;

---------------less-one
n1 < (suc n1);

n1 < n3; n3 < n2;
----------------- less-transitive
n1 < n2;

/* A theorem declaration starts with the keyword theorem followed by the name of the theorem, then the statement that must be proven, which can be of the type exist <premise> or forall <premise> exist <premise>, these premise must also end with a ";". */

theorem plus1 : forall n exists n + (suc z) = (suc n);

/* In the case of an induction proof what has to be proven is repeated and the premise is given a name this time. */

x : n + (suc z) = (suc n) by induction on n : 

/* The different cases of the induction are listed, with the syntax: case <alternative> is, then this is followed by a list of premises which possibly have names and are followed by a justification. A case is terminated with end case. */

case z is
	   (z) + (suc z) = (suc z) 	by rule sum-z
end case
/* The syntax to apply the induction hypothesis or to justify by a rule is straight forward. These can be invoked on a "name" or not. */
case suc n' is
	               d3 : n' + (suc z) = (suc n') by induction hypothesis on n'
                       d4 : (suc n') + (suc z) = (suc suc n')  by rule sum-s on d3

/* In the two statements above only d3 needs a name. */
end case

/* Specify that you are ending your induction and the theorem. */
end induction
end theorem

/* This is a very simple theorem, theres is no "forall" part therefore this can only be proved by calling a rule. */
theorem z_less_s_z: exists z < s z; 

 z < s z by rule less-one

end theorem

/* This is another induction proof but here, the cases are not alternatives but judgments. */
theorem sum-s-rh : forall d1 : n1 + n2 = n3 exists n1 + (suc n2) = (suc n3);
/* Note that the brackets in this case are important because they delimit the alternative. */
d2 : n1 + (suc n2) = (suc n3) by induction on d1 :

case rule

-------------- sum-z
z + n = n;

is

z + (suc n) = (suc n) by rule sum-z

end case


case rule

d3: n1' + n2 = n3';
------------------------------- sum-s
d4: (suc n1') + n2 = (suc n3');

is

d5 : n1' + (suc n2) = (suc n3')  by induction hypothesis on d3
d6 : (suc n1') + (suc n2) = (suc suc n3') by rule sum-s on d5

end case
end induction
end theorem

theorem sum-commutes : forall d1 : n1 + n2 = n3 exists n2 + n1 = n3;

d2 : n2 + n1 = n3 by induction on d1:

case rule

------------ sum-z
z + n = n ;

is

n + z = n by theorem sum-z-rh on n

end case


case rule

d3 : n1' + n2 = n3';
------------------------------ sum-s
d4 : (suc n1') + n2 = (suc n3');

is

d5 : n2 + n1' = n3' by induction hypothesis on d3
d6 : n2 + (suc n1') = (suc n3') by theorem sum-s-rh on d5

end case
end induction
end theorem

