% Value soundness 
% Author: Brigitte Pientka
%
% TODO extend with functions and function application

exp  : type.  
z    : exp.
suc  : exp -> exp.
letv : exp -> (exp -> exp) -> exp.

value : exp -> type.
v_z   : value z.
v_s   : {E:exp} value E -> value (suc E).

eval : exp -> exp -> type.
ev_z : eval z z.
ev_s : {E:exp} {V:exp} eval E V -> eval (suc E) (suc V).
ev_l : {E1:exp} {E2:exp -> exp} {V1:exp} {V:exp} 
       eval (E2 V1) V  -> eval E1 V1 -> eval (letv E1 (\x. E2 x)) V.

rec vs : {E::exp[.]} {V::exp[.]} (eval E![.]! V![.]!)[.] -> (value V![.]!)[.] = 
mlam E => mlam V => fn e =>
  case e of 
     box(. . ev_z) : (eval z z)[.] => box(. v_z)

  | {E::exp[.]}{V::exp[.]}{D::(eval  E![.]! V![.]!)[.]}
    box(. . ev_s E![.]! V![.]! D![.]!) : (eval (suc E![.]!) (suc V![.]!))[.]

    => 

    (case   (vs   <. E![.]! > <. V![.]! > box(. D![.]!)) of 

      {V'::exp[.]}{F::(value V'![.]!)[.]}
       box(. . F![.]!) : (value V'![.]!)[.] 
       =>    box(. v_s V![.]! F![.]!) 
     )

  | {E1::exp[.]} {E2::exp[. , x:exp]} {V1::exp[.]} {V2::exp[.]}
    {D1::(eval E1![.]! V1![.]!)[.]} {D2::(eval E2![., V1![.]! ]! V2![.]!)[.]}

     box(. . ev_l E1![.]! (\x . E2![., x]!) V1![.]! V2![.]! D2![.]! D1![.]!) :
       (eval (letv E1![.]! (\x . E2![., x]!)) V2![.]!)[.] 

     =>
        vs <. E2![., V1![.]! ]! >  <. V2![.]! >  box(. D2![.]!)

;