%{ 
  CH 3:  Untyped arithmetic expressions
  Author: Brigitte Pientka

  IMPLEMENTING AN INTERPRETER

  We interpret the big-step evaluation rules
  as a specification for an interpreter.
}%

rec eval : term [ ] -> term [ ] =
fn m => case m of 
| [ ] true  => [ ] true
| [ ] false => [ ] false
| [ ] switch T1 T2 T3 => 
  (case eval ([ ] T1) of
    | [ ] true  => eval ([ ] T2)
    | [ ] false => eval ([ ] T3)
  )
;



let r = eval ([ ] (switch (switch (switch true false false)
                               true 
                               true)
                       false 
                       false) ) ;
