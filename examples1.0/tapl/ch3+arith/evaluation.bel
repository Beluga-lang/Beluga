%{ 
  CH 3:  Untyped arithmetic expressions
  Author: Brigitte Pientka

  EVALUATION RULES AND META-THEORY

  EXTENSION WITH NUMBERS (includes a proof attempt to 
  proving every evaluation sequence terminates and yields a value,
  which is in fact a false statement!)

  CORRECT SOLUTION: see evaluation-corrected.bel

}%

% Values
value     : term -> type.

v_true : value true.
v_false: value false.
v_z    : value z.
v_s    : value N -> value (succ N).


% Small-step operational semantics
step: term -> term -> type.

e_switch_true:  
   step (switch true T2 T3)    T2.

e_switch_false:
   step (switch false T2 T3)   T3.

e_switch:
   step T1 T1'
-> step (switch T1 T2 T3)      (switch T1' T2 T3).

e_succ:
   step T T' 
-> step (succ T) (succ T').

e_pred_zero:
   step (pred z) z.

e_pred_succ:
  step (pred (succ N)) N.

e_pred:
   step T T'
-> step (pred T) (pred T').

e_iszero_zero:
   step (iszero z) true.

e_iszero_succ:
   step (iszero (succ N)) false.

e_iszero:
   step M N
-> step (iszero M) (iszero N).


% Example:

let t : (step (switch (switch true false false)
                      true 
                      true)
              (switch false true true)) [ ]
= [ ] e_switch e_switch_true ;

let d : (step (switch (switch (switch true false false)
                               true 
                               true)
                       false 
                       false) 
        
              (switch (switch false true true)
	              false
                      false)) [ ]
= [ ] e_switch (e_switch e_switch_true) ;


let e1 : (step (pred (succ (pred z))) (pred (succ z))) [ ] 
= [ ] e_pred (e_succ e_pred_zero) ;


let e2 : (step (pred (succ (pred z))) (pred z)) [ ] 
= [ ] e_pred_succ ;


equal: term -> term -> type.
ref: equal T T.

% -------------------------------------------------------- %
%{
Determinacy of evaluation:

Theorem: if step T T1 and step T T2 then equal T1 T2.

}%

steps_to_terms: term -> term -> term -> type.
andalso: step T T1 -> step T T2 -> steps_to_terms T T1 T2.


rec det : (steps_to_terms T T1 T2)[ ] -> (equal T1 T2)[ ] =
fn s => case s of 
| [ ] andalso (e_switch_true)  (e_switch_true)  =>  [ ] ref
| [ ] andalso (e_switch_false) (e_switch_false) =>  [ ] ref
| [ ] andalso (e_switch D)     (e_switch E)     =>
  let [ ] ref        = det ([ ] andalso D E) in 
    [ ] ref

| [ ] andalso (e_succ D)        (e_succ F)   => 
  let [ ] ref = det ([ ] andalso D F) in 
    [ ] ref

| [ ] andalso (e_pred_zero)     (e_pred_zero) =>
    [ ] ref

| [ ] andalso (e_pred D)         (e_pred F)   =>
    let [ ] ref = det ([ ] andalso D F) in 
    [ ] ref

| [ ] andalso (e_iszero_zero)    (e_iszero_zero) =>
    [ ] ref

| [ ] andalso (e_iszero_succ)    (e_iszero_succ)  =>
    [ ] ref

| [ ] andalso (e_iszero D)       (e_iszero F)     =>
   let [ ] ref = det ([ ] andalso D F) in 
     [ ] ref
;


% -------------------------------------------------------- %
% Normal form = values
%{ 
 Multi-step evaluation rules 
}%
mstep: term -> term -> type.

m_step : step M N' -> mstep N' N
     -> mstep M N.   

m_ref  : mstep M M.   % Reflexive


% -------------------------------------------------------- %
%{ Values evaluate to themselves

 Lemma: if value N and mstep N M then  equal N M.

}%
rec lemma_val : (value N)[ ] -> (mstep N M)[ ] -> (equal M N)[ ] =
fn v => fn s => case v of 
| [ ] v_true => 
    let [ ] m_ref  = s in 
      [ ] ref

| [ ] v_false => 
    let  [ ] m_ref = s in
      [ ] ref

| [ ] v_z     => 
  let [ ] m_ref = s in 
    [ ] ref

| [ ] v_s V   => 
  let [ ] m_ref = s in 
    [ ] ref

;

% -------------------------------------------------------- %
%{
Theorem: Uniqueness of evaluation

If mstep M N  and mstep M N'  then equal N N'.
}%

msteps_to_terms: term -> term -> term -> type.
andalso': mstep M M1 -> mstep M M2 -> msteps_to_terms M M1 M2.

rec unique : (msteps_to_terms M N1 N2)[ ] 
             -> (value N1)[ ] -> (value N2)[ ] 			      
	     -> (equal N1 N2)[ ] =
fn ms => fn vn1 => fn vn2 => case ms of 
| [ ] andalso' (m_step S1 MS1) (m_ref) => 
  let [ ] V2 = vn2 in 
    lemma_val ([ ] V2) ([ ] m_step S1 MS1)

| [ ] andalso' (m_step S1 MS1) (m_step S2 MS2) => 
  let [ ] ref = det ([ ] andalso S1 S2) in
    unique ([ ] andalso' MS1 MS2) vn1 vn2

| [ ] andalso' (m_ref )       (m_ref )   => 
   [ ] ref

;

% -------------------------------------------------------- %
%{
 Correctness of algorithmic small-step semantics 
}%

multi_step: term -> term -> type.

ms_tr: multi_step M N' -> multi_step N' N
      -> multi_step M N.

ms_ref: multi_step M M.

ms_step: step M N
	 -> multi_step M N.


%{
Admissibility of transitivity for mstep:
}%

rec m_trans : (mstep M N')[ ] -> (mstep N' N)[ ] -> (mstep M N)[ ] = 
fn ms1 => fn ms2 => case ms1 of 
| [ ] m_ref  => ms2 
| [ ] m_step  S1 MS1 => 
  let [ ] MS1' = m_trans ([ ] MS1) ms2 in 
    [ ] m_step S1 MS1'
;


rec sound : (mstep M N)[ ] -> (multi_step M N)[ ] = 
fn ms => case ms of 
| [ ] m_ref => [ ] ms_ref
| [ ] m_step S MS => 
  let [ ] MS' = sound ([ ] MS) in 
    [ ] ms_tr (ms_step S) MS'
;


rec complete : (multi_step M N)[ ] -> (mstep M N)[ ] =
fn ms =>  case ms of 
| [ ] ms_ref => 
    [ ] m_ref 
| [ ] ms_tr MS1 MS2 => 
  let [ ] MS2' = complete ([ ] MS2) in 
  let [ ] MS1' = complete ([ ] MS1) in 
   m_trans ([ ] MS1') ([ ] MS2')

| [ ] ms_step S => 
  [ ] m_step S m_ref
;


% -------------------------------------------------------- %
%{ 
Termination of Evaluation

We want to prove the following theorem:

THEOREM: For every term, there exists an evaluation sequence 
 which leads to a value.

NOTE: THIS THEOREM IS FALSE - THERE ARE TERMS WHICH ARE
  STUCK SUCH AS (succ false).
  THIS IS MERELY TO HIGHLIGHT A PROOF ATTEMPT, WHICH GOES
  WRONG AND IS CAUGHT BE COVERAGE.

}%

steps_to_val: term -> type.
result: multi_step T T' -> value T' 
   -> steps_to_val T.


% ---------------------------------------------------------- %
% LEMMAS
%{

Lemma: IF multi-step T T'  
  THEN multi-step (switch T T2 T3) (switch T' T2 T3).

}%

rec mstep_switch : 
  {T2::term[ ]}{T3::term[ ]}
  (multi_step T T')[ ] ->
  (multi_step (switch T T2 T3) (switch T' T2 T3))[ ] = 
mlam T2 => mlam T3 => 
fn ms => case ms of 
| [ ] ms_ref => [ ] ms_ref
| [ ] ms_step S => 
  [ ] ms_step (e_switch S)

| [ ] ms_tr MS1 MS2 =>
  let [ ] MS1' = mstep_switch < . T2 > < . T3 > ([ ] MS1) in 
  let [ ] MS2' = mstep_switch < . T2 > < . T3 > ([ ] MS2) in 
    [ ] ms_tr MS1' MS2'
;

%{

Lemma: IF multi-step T T'  
  THEN multi-step (succ T) (succ T').

}%

rec mstep_succ :
 (multi_step M M')[ ] -> (multi_step (succ M) (succ M') )[ ] =
fn ms => case ms of 
| [ ] ms_ref => [ ] ms_ref
| [ ] ms_step S => 
    [ ] ms_step (e_succ S)
| [ ] ms_tr MS1 MS2 => 
  let [ ] MS1' = mstep_succ ([ ] MS1) in 
  let [ ] MS2' = mstep_succ ([ ] MS2) in 
    [ ] ms_tr MS1' MS2'
;

%{

Lemma: IF multi-step T T'  
  THEN multi-step (pred T) (pred T').

}%


rec mstep_pred :
  (multi_step M M')[ ] -> (multi_step (pred M) (pred M'))[ ] =
fn ms => case ms of 
| [ ] ms_ref => [ ] ms_ref
| [ ] ms_step S => 
    [ ] ms_step (e_pred S)
| [ ] ms_tr MS1 MS2 => 
  let [ ] MS1' = mstep_pred ([ ] MS1) in 
  let [ ] MS2' = mstep_pred ([ ] MS2) in 
    [ ] ms_tr MS1' MS2'
;

% ---------------------------------------------------------- %
%{

 MAIN THEOREM: 

 For every term, there exists an evaluation sequence 
 which leads to a value.

 THIS IS A PROOF ATTEMPT -- THE FUNCTION BELOW IS NOT A PROOF!

}%

%{
 Evaluation terminates with a value

 For every term, there exists an evaluation sequence which leads to a value. 
 i.e. no term will get stuck.
}%

rec terminate : {M::term[ ]} (steps_to_val M)[ ] =
mlam M => case [ ] M of 
| [ ] true => 
   [ ] result ms_ref v_true

| [ ] false => 
    [ ] result ms_ref v_false

| [ ] switch T T1 T2 => 
  (case terminate < . T > of 
   | [ ] result MS v_true => 
       let [ ] result MS1 V1 = terminate < . T1 > in 
       let [ ] MS'           = mstep_switch < . T1 > < . T2 > ([ ] MS) in 
       [ ] result (ms_tr MS' (ms_tr (ms_step e_switch_true) MS1)) V1

   | [ ] result MS v_false => 
       let [ ] result MS2 V2 = terminate < . T2 > in 
       let [ ] MS'           = mstep_switch < . T1 > < . T2 > ([ ] MS) in 
       [ ] result (ms_tr MS' (ms_tr (ms_step e_switch_false) MS2)) V2    
  )

| [ ] z => 
    [ ] result ms_ref v_z

| [ ] succ N => 
    let [ ] result MS V = terminate < . N > in 
    let [ ] MS'         = mstep_succ ([ ] MS) in 
    [ ] result MS' (v_s V)

| [ ] pred M       => 
  (case terminate < . M > of 
   | [ ] result MS v_z => 
     let [ ] MS'         = mstep_pred ([ ] MS) in 
       [ ] result (ms_tr MS' (ms_step (e_pred_zero))) v_z
   | [ ] result MS (v_s V) => 
     let [ ] MS'         = mstep_pred ([ ] MS) in 
       [ ] result (ms_tr MS' (ms_step (e_pred_succ))) V
  %NOTE : this will not cover since M could evaluate to true
  %
  %       which is also a value; but then we are stuck.
  %       so the statement is not true anymore and needs to be generalized.
  %       it could only be proven of well-typed expressions.
  % 
  %FIX : see evaluation-corrected.bel

  )
      

;
