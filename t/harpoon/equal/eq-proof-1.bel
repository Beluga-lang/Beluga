% Given an expression e, return the proof that e is always equal to itself.
%
% If e is an expression, then eq e e.

% Author: Brigitte Pientka
% Comments:
% - use of Sigma-types in context
%
% - in Delphin, this example requires a special function `extend' of
%   type eqParamFun = <f:exp#> -> <eq f f> to keep track of the
%   relationship between an introduced parameter and the fact that
%   every parameter is equal to itself;
%
% - also requires explicit use of "remove parameter x and u" in the
%   definition of `extend' and the use of `extend' in `eqfun'

LF exp: type =
  | app: exp -> exp -> exp
  | lam: (exp -> exp) -> exp
;
--name exp E x.

LF eq: exp -> exp -> type =
  | eq_app : eq E1 F1 -> eq E2 F2 -> eq (app E1 E2) (app F1 F2)
  | eq_lam :  ({x : exp} eq x x -> eq (E x) (F x)) -> eq (lam (\x. E x)) (lam (\x. F x))
;
--name eq Q u.

LF equal: exp -> exp -> type =
  | e_l: ({x:exp} equal x x -> equal (T x) (T' x)) -> equal (lam (\x. T x)) (lam (\x. T' x))
  | e_a: equal T2 S2  -> equal T1 S1 -> equal (app T1 T2) (app S1 S2)
  | e_r: equal T T
  | e_t: equal T R -> equal R S -> equal T S
;

schema eqCtx = block x:exp, _t:eq x x;
schema equalCtx =  block x: exp, u:equal x x , _t:eq x x ;

proof ref : {g:equalCtx} {U:[g |- exp]} [g |- eq U U] =
/ total u (ref g u) /
?
;

% mlam g => mlam U => case [g |- U] of
% | [g |- #p.1] => [g |- #p.3]
%
% | [g |- lam \x. L] =>
%   let [g,b:block y:exp,u:equal y y , _t:eq y y |-  V[..,b.1,b.3]] =
%          ref [g, b:block y:exp, u:equal y y ,_t:eq y y] [g, b |-  L[..,b.1]]
%   in
%    [g |- eq_lam \x. \w. V]  % : eq L L
%
% | [g |- app A1 A2] =>
%   let [g |- EQ1] = ref [g] [g |- A1 ] in
%   let [g |- EQ2] = ref [g] [g |- A2 ] in
%     [g |- eq_app (EQ1) (EQ2)]
% ;

% General transitivity is admissible
proof trans: (g:equalCtx)
   [g |- eq (TT) (RR)]     % e1 : eq T R
-> [g |- eq (RR) (SS)]     % e2 : eq R S
-> [g |- eq (TT) (SS)]     % result : eq T S
=
 / total e1 (trans g t r s e1) /
?
;

% fn e1 => fn e2 => case e1 of
% | [g |- #p.3] => e2
%
% | [g |- eq_lam \x.\u. D1] =>
%   let [g |- eq_lam \x.\u. D2] =  e2  in
%   let % {E::(eq M M)[g, x:exp, u:eq x x]}
%      [g, b:block x:exp, u:equal x x , _t:eq x x |-  E[..,b.1,b.3]] =
%      trans [g, b:block x':exp, u:equal x' x' , _t:eq x' x' |-  D1[..,b.1,b.3]]
%          [g, b |-  D2[..,b.1,b.3]]
%   in
%    [g |- eq_lam \x. \u. E]
%
% | [g |- eq_app D1 D2] =>
%    let [g |- eq_app F1 F2] = e2 in
%    let [g |- E1] = trans [g |- D1]  [g |- F1] in
%    let [g |- E2] = trans [g |- D2]  [g |- F2] in
%      [g |- eq_app  E1  E2]
% ;

proof ceq: (g:equalCtx)
         [g |- equal T S] -> [g |- eq T S]  =
/ total e (ceq g t s e)/
?
;

% fn e => case e of
% | [g |- #p.2] => [g |- #p.3]
% | [g |- e_r] => ref [g] [g |- _  ]
% | [g |- e_a D2 D1] =>
%     let [g |- F1] = ceq [g |- D1] in
%     let [g |- F2] = ceq [g |- D2] in
%       [g |- eq_app F1 F2]
%
% | [g |- e_l (\x.(\u. D))] =>
%   let % {F:: (eq R Q)[g, x:exp, u: eq x x]}
%      [g,b:block x:exp,u:equal x x , _t:eq x x |-  F[..,b.1,b.3]] =
%         ceq [g, b:block x:exp, u:equal x x , _t:eq x x |-  D[..,b.1,b.2]]
%   in
%      [g |- eq_lam (\x.\v. F)]
%
% | [g |- e_t D1 D2] =>
%   let [g |- F2] = ceq [g |- D2] in
%   let [g |- F1] = ceq [g |- D1] in
%     trans [g |- F1]  [g |- F2]
% ;
