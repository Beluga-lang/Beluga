%%% A most naive version of translation from natural deductions
%%% into a proof in the Hilbert-style system and vice versa.
%%% Expresses the equivalence of the two systems.
%%% Author: Frank Pfenning

% abs implements bracket abstraction which amounts to
% the computational content of the deduction theorem.
%{
abs : (|- A -> |- B) -> |- (imp A B) -> type.

% aID	  : abs ([x] x) (mp (mp s k) k).
aONE	  : abs (\x. one) (mp k one).
aPAIR	  : abs (\x. pair) (mp k pair).
aLEFT	  : abs (\x. left) (mp k left).
aRIGHT	  : abs (\x. right) (mp k right).
aK	  : abs (\x. k) (mp k k).
aS	  : abs (\x. s) (mp k s).
aMP	  : abs (\x. mp (P x) (Q x)) (mp (mp s P') Q')
	      <- abs P P' <- abs Q Q'.
}%

schema |-ctx =  |- A.

rec abs: {g:(|-ctx)*}(|- (B[..] ))[g, u: |- A] -> (|- imp (A[..]) (B[..]))[g] =
 FN g => fn d => case d of
  | [g,x: |- (A[..])] x       => [g] mp (mp s k) k
  | [g,x: |- (A[..])] #p[..]   => [g] mp k (#p[..])
  | [g,x: |- _     ] pair    => [g] mp k pair
  | [g,x: |- _     ] left    => [g] mp k left
  | [g,x: |- _     ] right   => [g] mp k right
  | [g,x: |- _     ] k       => [g] mp k k
  | [g,x: |- _     ]  mp (P) (Q) =>
    let [g] P'[..] = abs [g] ([g,x] P) in
    let [g] Q'[..] = abs [g] ([g,x] Q) in
     [g] mp (mp s (P'[..])) (Q'[..])

;

% comb does the translation from natural deduction to Hilbert deductions,
% appealing to the deduction theorem in case of implies-introduction
% which requires hypothetical reasoning.



%{comb : ! A -> |- A -> type.
%mode comb +D -F.

ctrue     : comb trueI one.
candI     : comb (andI P Q) (mp (mp pair P') Q') <- comb P P' <- comb Q Q'.
candEL    : comb (andEL P)  (mp left P')	 <- comb P P'.
candER    : comb (andER P)  (mp right P')	 <- comb P P'.
cimpliesI : comb (impliesI PP) Q
            <- ({x:! _ }{y: |- _ } comb x y
%	                -> ({B:o} abs (\z. y) (mp k y))
	                -> (abs (\z. y) (mp k y))
		        -> comb (PP x) (PP' y))
	    <- abs PP' Q.
cimpliesE : comb (impliesE P Q) (mp P' Q')
	    <- comb P P'
	    <- comb Q Q'.
}%


schema !ctx = some [a:o] ! a;
coercion !to|- : !ctx -> |-ctx =
            [a:o] ! a => |- a;

rec comb: {g:!ctx} (! (A[..]))[g] -> (|- (A[..]))[!to|-(g)] =
FN g => fn d => case d of

  [g] #p[..] => [!to|-(g)] !to|-(#p[..])

| [g] trueI => [!to|-(g)] one

|[g] andI (P[..]) (Q[..]) =>
 let [!to|-(g)] P'[..] = comb [g] ([g] P[..] ) in
 let [!to|-(g)] Q'[..] = comb [g] ([g] Q[..] ) in
   [!to|-(g)] mp (mp pair (P'[..])) (Q'[..])

|[g] andEL (P[..])  =>
 let [!to|-(g)] P'[..] = comb [g] ([g] P[..] ) in
  [!to|-(g)] mp left (P'[..])
|[g] andER (P[..])  =>
 let [!to|-(g)] P'[..] = comb [g] ([g] P[..] ) in
  [!to|-(g)] mp right (P'[..])

|[g] impliesI (PP[..]) =>
 let [!to|-(g), y:|- _ ] PP'[..] y = comb [g, x:! _ ] ([g, x] PP) in
    abs [!to|-(g)] ([!to|-(g), y] PP'[..] y)

|[g] impliesE (P[..]) (Q[..]) =>
  let [!to|-(g)] P'[..] = comb [g] ([g] P[..] ) in
 let [!to|-(g)] Q'[..] = comb [g] ([g] Q[..] ) in
   [!to|-(g)] mp (P'[..]) (Q'[..])

;


% Now the translation from Hilbert deduction into natural deductions.
% This simply gives the definition of the (proof) combinators as lambda-terms.


coercion |-to! : |-ctx –-> !ctx =
            [a:o] |- a –-> ! a ;

%{combdefn : |- A -> ! A -> type.
%mode  combdefn +D -F.

cdK     : combdefn k (impliesI (\p. impliesI (\q. p))).
cdS	: combdefn s (impliesI (\p. impliesI (\q. impliesI (\r.
		         (impliesE (impliesE p r) (impliesE q r)))))).
cdONE   : combdefn one trueI.
cdPAIR  : combdefn pair (impliesI (\p. impliesI (\q. andI p q))).
cdLEFT  : combdefn left (impliesI (\p. andEL p)).
cdRIGHT : combdefn right (impliesI (\p. andER p)).
cdMP    : combdefn (mp P Q) (impliesE P' Q')
	     <- combdefn P P'
	     <- combdefn Q Q'.

}%

rec combdefn : {g:(|-ctx)*} (|- (A[..]))[g] -> (! (A[..] ))[|-to!(g)] =
FN g => fn d => case d of

 | [g] #p[..] => [|-to!(g)] |-to!(#p[..])

 | [g] k =>  [|-to!(g)] impliesI (\p. impliesI (\q. p))
 | [g] s => [|-to!(g)] impliesI (\p. impliesI (\q. impliesI (\r.
		         (impliesE (impliesE p r) (impliesE q r)))))

 | [g] one => [|-to!(g)] trueI

 | [g] pair =>  [|-to!(g)] impliesI (\p. impliesI (\q. andI p q))
 | [g] left =>  [|-to!(g)] impliesI (\p. andEL p)
 | [g] right =>  [|-to!(g)] impliesI (\p. andER p)

 | [g] mp (P[..]) (Q[..]) =>
   let [|-to!(g)] P'[..] = combdefn [g] ([g] P[..] ) in
   let [|-to!(g)] Q'[..] = combdefn [g] ([g] Q[..] ) in
     [|-to!(g)] impliesE (P'[..]) (Q'[..])

;

%%% Decidability proof for theorem  HD -> ND
%terminates D (combdefn D _).
