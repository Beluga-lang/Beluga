% ----------------------------------------------------------------------------
% Weak normalization for lambda-calculus with 
% parallel reduction (in particular with reduction 
% under binder)
% Author: A. Cave
% ----------------------------------------------------------------------------
% Definition of types and intrinsically typed terms
LF tp : type = 
| i :  tp
| arr: tp -> tp -> tp
;
%name tp T.

LF tm : tp -> type = 
| app : tm (arr T S) -> tm T -> tm S
| lam : (tm T -> tm S) -> tm (arr T S)
;
%name tm E.

schema ctx = tm T;
% ----------------------------------------------------------------------------
LF step : tm A -> tm A -> type = 
| s_beta : step (app (lam M) N) (M N)
| s_lam : ({x:tm A} step (M x) (M' x)) -> step (lam M) (lam M')
| s_app1 : step M M' -> step (app M N) (app M' N)
| s_app2 : step N N' -> step (app M N) (app M N')
;

LF mstep : tm A -> tm A -> type =
| s_refl : mstep M M
| s_trans : step M M' -> mstep M' M'' -> mstep M M''
;

%name step S.
% -----------------------------------------------------------------------------
% Defining Normal and Neutral Terms
% We define them in LF. We do not enforce eta-longness here, although this can in principle be done.
%

LF normal : tm A -> type =
| n_lam : ({x:tm A} neutral x -> normal (M x)) -> normal (lam (\x. M x))
| n_neut : neutral M -> normal M
and neutral : tm A -> type =
| n_app : neutral M -> normal N -> neutral (app M N)
;


% -----------------------------------------------------------------------------
schema nctx = some [t:tp] block x:tm t, y:neutral x;

inductive Halts : (gamma:nctx) {A:[ |- tp]}{M:[gamma |- tm A[]]} ctype =
| Halts : {V:[gamma |- tm A[]]} [gamma |- mstep M V] -> [gamma |- normal V] -> Halts [ |- A] [gamma |- M];

% -----------------------------------------------------------------------------
% Reducibility Definition 
% It is defined inductively over the type A.
% In the case where A is a function type we quantify over
% the context h0, a substitution #R which maps variables from the context h to the
% context h0. While we use built-in simultanteous substitutions to model #R, our 
% built-in substitutions are more general and do not restrict #R to be a variable 
% substitution (i.e. a possible a weakening substitution).
% We hence define explicitly a predicate that checks whether a given substitution is a 
% variable-to-variable substitution.

stratified Reduce : (gamma:nctx) {A:[ |- tp]}{M:[gamma |- tm A[]]} ctype =
| Base : Halts [ |- i] [gamma |- M] -> Reduce [ |- i] [gamma |- M]
| Arr :  {M:[gamma |- tm (arr A[] B[])]}
	 Halts [ |- arr A B] [gamma |- M] ->
         ({phi:nctx} {#S:[phi |- gamma]} {N:[phi |- tm A[]]}
            Reduce [ |- A] [phi |- N]
          -> Reduce [ |- B ] [phi |- app M[#S] N])
         -> Reduce [ |- arr A B] [gamma |-  M];

% -----------------------------------------------------------------------------
% Lemma [ Backwards Closed ]
% If step M M'   and   M' is reducible at type A  
% then M is reducible at type A

rec closed : {A:[|- tp]}{M:[g |- tm A[]]}{M':[g |- tm A[]]}
             {S:[g |- step M M']} Reduce [ |- A] [g |- M'] -> Reduce [ |- A] [g |- M] =
/ total a (closed _ a) /
mlam A,M,M',S => fn r => case [|- A] of 
| [|- i] =>  
   let Base (Halts [g |- V] [g |- S'] v) = r in 
     Base (Halts [g |- V] [g |- s_trans S S'] v)

| [|- arr A B] => 
  let Arr [g |- M] (Halts [g |- V] [g |- S'] v) f = r in 
  Arr [g |- _] (Halts [g |- V] [g |- s_trans S S'] v)
  (mlam h => mlam #W => mlam N => fn rn =>
    closed [ |- B] [h |- _ ] [h |- _ ] [h |- s_app1 S[#W]] (f [h] [h |- #W] [h |- N] rn))
;

rec m_closed : (g:nctx) [g |- mstep M M'] -> Reduce [ |- A] [g |- M'] -> Reduce [ |- A] [g |- M] =
/ total s (m_closed a m m' g s) /
fn s,r => case s of
| [g |- s_refl] => r
| [g |- s_trans S MS] => 
  let r' = m_closed [g |- MS] r in
  closed [|- _] [_ |- _] [_ |- _] [_ |- S] r'
;

rec m_app2 : (g:nctx) {M:[g |- tm (arr A[] B[])]} [g |- mstep N N'] -> [g |- mstep (app M N) (app M N')] =
/ total s (m_app2 a b g m n n' s) /
mlam M => fn s => case s of
| [g |- s_refl] => [g |- s_refl]
| [g |- s_trans S MS] =>
  let [g |- MS'] = m_app2 [g |- M] [g |- MS] in
  [g |- s_trans (s_app2 S) MS']
;

rec m_lam : (g:nctx) {M:[g, x:tm A[] |- tm B[]]} [g, b:block (x:tm A[], u:neutral x) |- mstep M[..,b.1] M'[..,b.1]] -> [g |- mstep (lam (\x. M)) (lam (\x. M'))] =
/ total s (m_lam a b g m m' s) /
mlam M => fn s => case s of
| [g, b:block (x:tm A[], u:neutral x) |- s_refl] => [g |- s_refl]
| [g, b:block (x:tm A[], u:neutral x) |- s_trans S[..,b.1] MS] =>
  let [g |- MS'] = m_lam [_ |- _] [g,b:block (x:tm A[], u:neutral x) |- MS] in
  [g |- s_trans (s_lam (\x. S)) MS']

;

% -----------------------------------------------------------------------------
% Lemma: If M is reducible at type A then M halts

rec reflect : {gamma:nctx}{A:[|-tp]}{R:[gamma |- tm A[]]}{NR:[gamma |- neutral R]} Reduce [ |- A] [gamma |- R] =
/ total a (reflect gamma a) /
mlam gamma, A,R,NR => case [ |- A] of
| [ |- i] => Base (Halts [gamma |- R] [gamma |- s_refl] [gamma |- n_neut NR])
| [ |- arr A B] =>
  Arr [gamma |- R] (Halts [gamma |- R] [gamma |- s_refl] [gamma |- n_neut NR])
  (mlam h => mlam #W => mlam M2 => fn rm2 =>
    let Halts [_ |- _] ms [_ |- N] = reify [h] [|- A] [h |- M2] rm2 in
    m_closed  (m_app2 [_ |- _] ms)
             (reflect [h] [|- B] [h |- _ ] [_ |- n_app NR[#W] N]))

and reify : {g:nctx}{A:[|- tp]}{M:[g |- tm A[]]}
            Reduce [ |- A] [g |- M] -> Halts [ |- A] [g |- M] =
 / total a (reify g a ) /
mlam g,A,M => fn r => case [|- A] of 
| [|- i] => let Base h = r in h
| [|- arr A B] => 
  let Arr [g |- M] h f = r in h
;

% -----------------------------------------------------------------------------
% Defining reducibility of simultaneous substitutions.

inductive LogSub : {g:ctx}(h:nctx){#S:[h |- g]} ctype =
| Nil : LogSub [] [h |- ^ ]
| Dot : LogSub [g] [h |- #S ] -> Reduce [ |- A] [h |- M] -> LogSub [g,x:tm A[]] [h |- #S, M ];

% Lemmas about reducible simultaneous substitutions.
% Weakening a term M that is reducible at type A
rec monotone : (h:nctx) {#W:[h |- g]} Reduce  [ |- A] [g |- M] -> Reduce [ |- A] [h |- M[#W]] =
/ total (monotone) /
mlam #W => fn r =>
case r of
| Base (Halts [_ |- _] [g |- S] [g |- NR]) => Base (Halts [_ |- _] [_ |- S[#W]] [_ |- NR[#W]])
| Arr [g |- M] (Halts [_ |- _] [g |- S] [g |- NR]) f =>
  Arr [_ |- M[#W]] (Halts [_ |- _] [_ |- S[#W]] [_ |- NR[#W]])
   (mlam h', #W2, N => fn rn =>
    f [h'] [h' |- #W[#W2]] [h' |-  N] rn);


% Composing a reducible substitution with a variable substitution yields a 
% reducible substitution
rec monotoneSub : {#W:[h' |- h]} LogSub [g] [h |- #S] -> LogSub [g] [h' |- #S[#W]] =
/ total rs (monotoneSub _ _ _ _ _ rs) /
mlam #W => fn rs => case rs of
| Nil => Nil
| Dot rs' rN => Dot (monotoneSub [_ |- #W] rs') (monotone [_ |- #W] rN);

% If sigma is a reducible substitution then applying sigma to a variable yields a term 
% that is reducible
rec redVar : {g:ctx}{#p:[g |- tm A[]]} LogSub [g] [h |- #S] ->  Reduce [ |- A] [h |- #p[#S] ] =
/ total g (redVar g) / 
mlam g, #p => fn rs => case [g] of 
| [] => impossible [ |- #p] 
| [g', x:tm A[]] => (case [g', x:tm A[] |- #p[..,x]] of 
   | [g',x:tm A[] |-  x]      =>    let Dot rs' rN = rs in rN
   | [g',x:tm A[] |-  #q[..]] => let Dot rs' rN = rs in redVar [g'] [g' |-  #q] rs');

% % The identity substitution is reducible
% rec idLogSub : {g:ctx} LogSub [g] [g |- ..] =
% / total g (idLogSub g) /
% mlam g => case [g] of 
% | [ ] => Nil
% | [g',x:tm A[]] =>
%   Dot (monotoneSub (idLogSub [g']) (shiftIsVarSub [g']))
%       (reflect [g', x:tm A[]] [|- _ ] [g', x:tm A[] |- x ] (Var (IsVar [g',x:tm A[] |-  x])));

% -----------------------------------------------------------------------------
% Main Lemma: 
% If g |- M : A   and  h |- sigma : g   and sigma is reducible 
% then M[sigma] is reducible at type A in the context h.

rec eval : {M:[gamma |- tm A[]]} LogSub [gamma] [phi |- #S ] -> Reduce [ |- A] [phi |- M[#S] ] =
/ total m (eval gamma phi a sigma m) /
mlam M => fn rs => let (rs : LogSub [gamma] [phi |- #S] ) = rs in
 case [gamma |- M] of
| [gamma |-  #p] => redVar [gamma] [gamma |-  #p] rs
| [gamma |-  app M1 M2]  =>
  let Arr [phi |- _ ] h f = eval [gamma |-  M1]  rs in
   f [phi] [phi |- ..] [phi |- M2[#S]] (eval [gamma |-  M2] rs)
| [gamma |-  lam (\x. M1)] =>
   let q0 = eval [gamma,x:tm _ |- M1] (Dot (monotoneSub [phi,b:block x:tm _,y:neutral x |- ..] rs)
     (reflect [phi,b:block x:tm _,y:neutral x] [|- _] [phi,b |- b.1] [phi,b:block x:tm _,y:neutral x |- b.2])) in
   let 
        Halts [phi,b:block x:tm A1[],y:neutral x |- _]
              [phi,b:block x:tm A1[],y:neutral x |- MS[..,b.1,b.2]]
              [phi,b:block x:tm A1[],y:neutral x |- NV]
     = reify [phi,b:block x:tm _,y:neutral x] [|- _] [phi,b |- _] q0 in
   Arr [phi |- lam (\x. M1[#S[..], x])]
   (Halts [_ |- _] 
     (m_lam [phi, x:tm A1[]  |- M1[#S[..],x]]  [phi, b:block (x:tm A1[], y:neutral x) |- MS[..,b.1,b.2] ])
     [phi |- n_lam (\x.\y. NV[..,<x;y>])])
   (mlam psi,#W,N => fn rN =>
     closed [|- _ ] [psi |- app (lam \x.M1[#S[#W[..]],x]) N ] [psi |- M1[#S[#W[..]], N] ] 
            [psi |-  s_beta] (eval [gamma,x:tm _ |-  M1] (Dot (monotoneSub [psi |- #W] rs) rN)))
;

% -----------------------------------------------------------------------------
% THEOREM: Well-typed terms halt. 

% #Id is a substitution which moves from a term context to a neutral term context in the obvious way
inductive IdSub : (g':nctx){g:ctx}{#Id:[g' |- g]} ctype =
| INil : IdSub [] [|- ^]
| ISnoc : IdSub [g] [g' |- #Id] -> IdSub [g,x:tm A[]] [g',b:block x:tm A[],y:neutral x |- #Id[..], b.1];

rec idLogSub : IdSub [g] [g' |- #Id] -> LogSub [g] [g' |- #Id] =
/ total r (idLogSub g g s r) /
fn r => case r of
| INil => Nil
| ISnoc r' =>
  Dot (monotoneSub [_,b:block x:tm _,y:neutral x |- ..] (idLogSub r'))
      (reflect [_] [|- _] [_ |- _] [_,b:block x:tm _,y:neutral x |- b.2])
;  

rec weakNorm : {M:[g |- tm A[]]} IdSub [g] [g' |- #Id] -> Halts  [ |- A] [g' |- M[#Id]] =
/ total (weakNorm) /
mlam M => fn s => reify [_] [|- _] [_ |- _] (eval [_ |- M] (idLogSub s));

% We probably want to show also that for any g:ctx there exists g':nctx and #Id:[g' |- g]
% such that IdSub [g] [g' |- #Id]...
