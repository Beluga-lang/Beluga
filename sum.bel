nat : type.     
z : nat.
s : nat -> nat.

add : nat -> nat -> nat -> type. 
a_z : add z R R.
a_s : add N1 N2 N3 -> add (s N1) N2 (s N3).

%{
less : nat -> nat -> type. 
l_one : {N:nat} less N (s N). 
l_trans : less N M -> less M O -> less N O.

rec zless : (less z (s z))[] = 
[] l_one z;

rec plus1 : {N::nat []} (add N (s z) (s N)) [] =
mlam N => case ([] N) of
 | [] z => [] (a_z)

 | [] (s N) => 
   let [] F = plus1 < . N> in
     [] a_s F

;
}%
rec sumsr : {D1::(add Nat1 Nat2 Nat3)[]} (add Nat1 (s Nat2) (s Nat3))[] = 
mlam D1 => case ([] D1) of

 | [] a_z  => [] a_z

 | [] a_s I =>
   let [] H' = sumsr < . I> in
     [] a_s H' 
;
