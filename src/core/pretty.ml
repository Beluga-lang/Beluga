(** Pretty printing for external and internal syntax.

    @see http://caml.inria.fr/resources/doc/guides/format.html
*)

open Format

(* Explanation of formatting markup:

   "@[" opens a box (open_box 0).  You may specify more information
          with an argument, e.g., "@[<hov n>" is equivalent to open_hovbox n.

   "@]" closes a box (close_box ()).

   "@ " outputs a breakable space (print_space ()).

   "@," outputs a break hint (print_cut ()).

   "@." ends the pretty-printing, closing all boxes still opened (print_newline ()).

   "@;<n m>" emits a "full" break hint (print_break n m).

   "@?" outputs pending material in the pretty-printer queue (print_flush ()).

  Important tips:
    - Use "@ " for a break.  Don't use " @ " unless you want more than one space.
    - If you want a newline (for example, before the branch of a case expression),
      you need to do something like this:

           "@[<v>@[%a@]@ @[%a@]@]"
  
      The "@[<v>" begins a "vertical-only box", in which all breaks are newlines.
      (With a normal box, a break will only write a newline if the right margin is reached.)
      The @[ @] around the two %a's are "horizontal-or-vertical boxes", to ensure that
      breaks generated by the formatting functions called via %a aren't all vertical.
      Otherwise, you'll get output like

           case blah
                ([g]
                 T
                 ..) of

  Notes:
     - Function whose names start with "frugal" try to produce output similar to human input.
*)

type lvl    = int

let std_lvl = 0

let l_paren_if cond =
  if cond
  then "("
  else ""

let r_paren_if cond =
  if cond
  then ")"
  else ""

module Control = struct
  type substitution_style = Natural | DeBruijn

  let substitutionStyle = ref Natural
  let printImplicit = ref true

  let db() = !substitutionStyle = DeBruijn
end (* Control *)

module Int = struct

  open Id
  open Syntax.Int

  (* Internal Syntax Printer Signature *)
  module type PRINTER = sig

    (* Contextual Format Based Pretty Printers *)
    val fmt_ppr_sgn_decl      : lvl -> formatter -> Sgn.decl  -> unit
    val fmt_ppr_lf_kind       : LF.dctx -> lvl -> formatter -> LF.kind      -> unit
    val fmt_ppr_lf_ctyp_decl  : LF.mctx -> lvl -> formatter -> LF.ctyp_decl -> unit
    val fmt_ppr_lf_typ_rec    : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.typ_rec    -> unit

    val fmt_ppr_lf_typ        : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.typ    -> unit
    val fmt_ppr_lf_tuple      : LF.mctx -> LF.dctx -> lvl  -> formatter -> LF.tuple  -> unit
    val fmt_ppr_lf_normal     : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.normal -> unit
    val fmt_ppr_lf_head       : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.head   -> unit
    val fmt_ppr_lf_spine      : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.spine  -> unit
    val fmt_ppr_lf_sub        : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.sub    -> unit

    val fmt_ppr_lf_schema     : lvl -> formatter -> LF.schema     -> unit
    val fmt_ppr_lf_sch_elem   : lvl -> formatter -> LF.sch_elem   -> unit

    val fmt_ppr_lf_psi_hat    : LF.mctx -> lvl -> formatter -> LF.dctx  -> unit 
    val fmt_ppr_lf_dctx       : LF.mctx -> lvl -> formatter -> LF.dctx  -> unit

    val fmt_ppr_lf_mctx       : lvl -> formatter -> LF.mctx     -> unit
    val fmt_ppr_cmp_kind      : LF.mctx -> lvl -> formatter -> Comp.kind -> unit
    val fmt_ppr_cmp_typ       : LF.mctx -> lvl -> formatter -> Comp.typ -> unit
    val fmt_ppr_cmp_exp_chk   : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.exp_chk  -> unit
    val fmt_ppr_cmp_exp_syn   : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.exp_syn  -> unit
    val fmt_ppr_cmp_value     : lvl -> formatter -> Comp.value -> unit
    val fmt_ppr_cmp_branches  : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.branch list -> unit
    val fmt_ppr_cmp_branch    : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.branch      -> unit
    val fmt_ppr_pat_obj       : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.pattern     -> unit

    val fmt_ppr_lf_ctx_var    : LF.mctx -> formatter -> LF.ctx_var -> unit

    (* Regular Pretty Printers *)
    val ppr_sgn_decl      : Sgn.decl         -> unit
    val ppr_lf_kind       : LF.dctx -> LF.kind -> unit
    val ppr_lf_ctyp_decl  : LF.mctx -> LF.ctyp_decl  -> unit
    val ppr_lf_typ_rec    : LF.mctx -> LF.dctx -> LF.typ_rec -> unit
    val ppr_lf_typ        : LF.mctx -> LF.dctx -> LF.typ     -> unit
    val ppr_lf_normal     : LF.mctx -> LF.dctx -> LF.normal  -> unit
    val ppr_lf_head       : LF.mctx -> LF.dctx -> LF.head    -> unit
    val ppr_lf_spine      : LF.mctx -> LF.dctx -> LF.spine   -> unit
    val ppr_lf_sub        : LF.mctx -> LF.dctx -> LF.sub     -> unit

    val ppr_lf_schema     : LF.schema        -> unit
    val ppr_lf_sch_elem   : LF.sch_elem      -> unit

    (* val ppr_lf_psi_hat    : LF.mctx -> LF.dctx -> unit *)
    val ppr_lf_dctx       : LF.mctx -> LF.dctx  -> unit
    val ppr_lf_mctx       : LF.mctx -> unit 
    val ppr_cmp_kind      : LF.mctx -> Comp.kind -> unit
    val ppr_cmp_typ       : LF.mctx -> Comp.typ -> unit
    val ppr_cmp_exp_chk   : LF.mctx -> Comp.gctx -> Comp.exp_chk -> unit
    val ppr_cmp_exp_syn   : LF.mctx -> Comp.gctx -> Comp.exp_syn -> unit
    val ppr_cmp_branches  : LF.mctx -> Comp.gctx -> Comp.branch list -> unit
    val ppr_cmp_branch    : LF.mctx -> Comp.gctx -> Comp.branch      -> unit

    (* Conversion to string *)
    val subToString       : LF.mctx -> LF.dctx -> LF.sub      -> string
    val spineToString     : LF.mctx -> LF.dctx -> LF.sclo     -> string
    val typToString       : LF.mctx -> LF.dctx -> LF.tclo     -> string
    val typRecToString    : LF.mctx -> LF.dctx -> LF.trec_clo -> string
    val kindToString      : LF.dctx -> (LF.kind * LF.sub) -> string
    val normalToString    : LF.mctx -> LF.dctx -> LF.nclo     -> string
    val headToString      : LF.mctx -> LF.dctx -> LF.head     -> string
    val tupleToString     : LF.mctx -> LF.dctx -> LF.tuple    -> string
    val dctxToString      : LF.mctx -> LF.dctx -> string
    val mctxToString      : LF.mctx -> string

    val metaObjToString   : LF.mctx -> Comp.meta_obj -> string

    val schemaToString    : LF.schema     -> string
    val schElemToString   : LF.sch_elem   -> string

    val gctxToString      : LF.mctx -> Comp.gctx -> string
    val patternToString   : LF.mctx -> Comp.gctx -> Comp.pattern -> string
    val expChkToString    : LF.mctx -> Comp.gctx -> Comp.exp_chk -> string
    val expSynToString    : LF.mctx -> Comp.gctx -> Comp.exp_syn -> string
    val valueToString     :                         Comp.value   -> string
    val branchToString    : LF.mctx -> Comp.gctx -> Comp.branch  -> string
    val compKindToString  : LF.mctx              -> Comp.kind -> string
    val compTypToString   : LF.mctx              -> Comp.typ  -> string
    val msubToString      : LF.mctx              -> LF.msub   -> string

  end (* Int.PRINTER *)

  (* Internal Syntax Pretty Printer Functor *)
  module Make : functor (R : Store.Cid.RENDERER) -> PRINTER = functor (R : Store.Cid.RENDERER) -> struct

    module InstHashedType = struct
      type t    = LF.normal option ref
      let equal = (==)
      let hash  = Hashtbl.hash
    end

    module InstHashtbl = Hashtbl.Make (InstHashedType)

    let inst_hashtbl : string InstHashtbl.t = InstHashtbl.create 0

    module PInstHashedType = struct
      type t    = LF.head option ref
      let equal = (==)
      let hash  = Hashtbl.hash
    end

    module PInstHashtbl = Hashtbl.Make (PInstHashedType)

    let pinst_hashtbl : string PInstHashtbl.t = PInstHashtbl.create 0

    let rec phatToDCtx phat = match phat with 
      | (None,      0) -> LF.Null
      | (Some psi , 0) -> LF.CtxVar psi
      | (ctx_v    , k) -> 
         LF.DDec (phatToDCtx (ctx_v, k-1), LF.TypDeclOpt (Id.mk_name Id.NoName)) 
        

    (* Contextual Format Based Pretty Printers 
     *
     * We assume types, terms, etc are all in normal form.
     *)
    let rec fmt_ppr_lf_typ cD cPsi lvl ppf = function
      | LF.Atom (_, a, LF.Nil) ->
          fprintf ppf "%s"
            (R.render_cid_typ a)

      | LF.Atom (_, a, ms) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%s%a%s"
              (l_paren_if cond)
              (R.render_cid_typ a)
              (fmt_ppr_lf_spine cD cPsi 2) ms
              (r_paren_if cond)

      | LF.PiTyp ((LF.TypDecl (x, a), LF.Maybe), b) ->
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s{%s : %a} @ %a%s@]"
              (l_paren_if cond)
              (R.render_name  x)
              (fmt_ppr_lf_typ cD cPsi 0) a
              (fmt_ppr_lf_typ cD (LF.DDec(cPsi, LF.TypDecl(x, a))) 0) b
              (r_paren_if cond)

      | LF.PiTyp ((LF.TypDecl (x, a), LF.No), b) ->
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s%a -> %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_lf_typ cD cPsi 1) a
              (fmt_ppr_lf_typ cD (LF.DDec(cPsi, LF.TypDecl(x, a))) 0) b
              (r_paren_if cond)

      | LF.Sigma typRec ->
          fprintf ppf "block (%a)"
(*            (l_paren_if (lvl > 0)) *)
            (fmt_ppr_lf_typ_rec cD cPsi lvl) typRec
(*            (r_paren_if (lvl > 0)) *)

      | LF.TClo (typ, s) ->
          fprintf ppf "TClo(%a,@ %a)"
            (fmt_ppr_lf_typ cD cPsi lvl) typ
            (fmt_ppr_lf_sub cD cPsi lvl) s


    and fmt_ppr_lf_tuple cD cPsi lvl ppf = function
      | LF.Last tM ->
           fmt_ppr_lf_normal cD cPsi lvl ppf tM

      | LF.Cons(tM, rest) ->
           fprintf ppf "%a, %a"
             (fmt_ppr_lf_normal cD cPsi lvl) tM
             (fmt_ppr_lf_tuple cD cPsi lvl) rest

    and fmt_ppr_lf_normal cD cPsi lvl ppf =
      let rec dropSpineLeft ms n = match (ms, n) with
          (_, 0) -> ms
        | (LF.Nil, _) -> ms
        | (LF.App (_m, rest), n) -> dropSpineLeft rest (n - 1)

      in let deimplicitize_spine h ms = match h with
        | LF.Const c ->
            let implicit_arguments = if !Control.printImplicit
                                     then 0
                                     else Store.Cid.Term.get_implicit_arguments c
            in
              dropSpineLeft ms implicit_arguments

        | LF.MVar _
        | LF.BVar _
        | LF.PVar _
        | LF.FMVar _
        | LF.FPVar _
        | LF.Proj _  
        | LF.FVar _
        | LF.AnnH _ ->
            ms

      in function
        | LF.Lam (_, x, m) ->
            let cond = lvl > 0 in
              fprintf ppf "%s\\%s. %a%s"
                (l_paren_if cond)
                (R.render_name x)
                (fmt_ppr_lf_normal cD (LF.DDec(cPsi, LF.TypDeclOpt x)) 0) m
                (r_paren_if cond)

        | LF.Tuple (_, tuple) ->
           fprintf ppf "<%a>"
             (fmt_ppr_lf_tuple cD cPsi lvl) tuple

        | LF.Root (_, h, LF.Nil) ->
            fprintf ppf "%a"
              (fmt_ppr_lf_head cD cPsi lvl) h

        | LF.Root (_, h, ms)  ->
            let cond = lvl > 1 in
            let ms = deimplicitize_spine h ms in
              fprintf ppf "%s%a%a%s"
                (l_paren_if cond)
                (fmt_ppr_lf_head cD cPsi lvl) h
                (fmt_ppr_lf_spine cD cPsi 2)  ms
                (r_paren_if cond)

        | LF.Clo(tM, s) -> fmt_ppr_lf_normal cD cPsi lvl ppf (Whnf.norm (tM, s))

    and fmt_ppr_lf_head cD cPsi lvl ppf head = 
      let paren s = not (Control.db()) && lvl > 0 && (match s with
        | LF.Shift _ when not (Context.hasCtxVar cPsi) -> false
        | _ -> true)
      in
      let rec fmt_head_with proj = function
      | LF.BVar x  ->
          fprintf ppf "%s%s"
            (R.render_bvar cPsi x)
            proj

      | LF.Const c ->
          fprintf ppf "%s%s"
            (R.render_cid_term c)
            proj

      | LF.MMVar (c, (ms, s)) ->
          fprintf ppf "%s%a%s[%a]%a%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_mmvar lvl) c
            proj
            (fmt_ppr_lf_msub cD lvl) ms
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.MVar (c, s) ->
          fprintf ppf "%s%a%s%a%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_cvar cD lvl) c
            proj
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.PVar (c, s) ->
          fprintf ppf "%s#%a%s%a%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_cvar cD lvl) c
            proj
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.FVar x ->
          fprintf ppf "%s%s"
            (R.render_name x)
            proj

      | LF.FMVar (u, s) ->
          fprintf ppf "FMV %s%s%s%a%s"
            (l_paren_if (paren s))
            (R.render_name u)
            proj
            (fmt_ppr_lf_sub cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.FPVar (p, s) ->
          fprintf ppf "%s#%s%s%a%s"
            (l_paren_if (paren s))
            (R.render_name p)
            proj
            (fmt_ppr_lf_sub cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.Proj (head, k) ->
          fmt_head_with ("." ^ string_of_int k) head

      in
        fmt_head_with "" head


    and fmt_ppr_lf_spine cD cPsi lvl ppf = function
      | LF.Nil ->
          fprintf ppf ""

      | LF.App (m, ms) ->
          fprintf ppf " %a%a"
            (fmt_ppr_lf_normal  cD cPsi (lvl + 1)) m
            (fmt_ppr_lf_spine   cD cPsi lvl) ms

    and fmt_ppr_lf_sub cD cPsi lvl ppf s =
      match !Control.substitutionStyle with
        | Control.Natural -> fmt_ppr_lf_sub_natural cD cPsi lvl ppf s
        | Control.DeBruijn -> fmt_ppr_lf_sub_deBruijn cD cPsi lvl ppf s

    and fmt_ppr_lf_sub_natural cD cPsi lvl ppf s=
      let print_front = fmt_ppr_lf_front cD cPsi 1 in
      let hasCtxVar = match Context.ctxVar cPsi with Some _ -> true | None -> false in
      let rec self lvl ppf =
        function
       (* Print ".." for a Shift when there is a context variable present,
          and nothing otherwise *)
       (* above is WRONG *)
        | LF.Shift (LF.NoCtxShift, _) when hasCtxVar -> fprintf ppf ".."
        | LF.Shift (LF.NoCtxShift, _) when not hasCtxVar -> ()
        | LF.Shift (LF.CtxShift _, _) when hasCtxVar     ->    ()
        | LF.Shift (LF.CtxShift _, _) when not hasCtxVar     -> fprintf ppf "????"
        | LF.Shift (LF.NegCtxShift _, _) when hasCtxVar  -> fprintf ppf ".."    (* ??? *)
        | LF.Shift (LF.NegCtxShift _, _) when not hasCtxVar  ->    ()    (* ??? *)

        | LF.SVar (c, s) ->
            fprintf ppf "[%a. #%a]"
               (self lvl) s
               (fmt_ppr_lf_cvar cD lvl) c
              
        | LF.Dot (f, s) when hasCtxVar ->
            fprintf ppf "%a %a"
              (self lvl) s
              print_front f
              
        | LF.Dot (f, LF.Shift _) when not hasCtxVar ->       (* No context variable, so just print the front *)
            fprintf ppf "%a"
              print_front f
              
        | LF.Dot (f, s) when not hasCtxVar ->
            fprintf ppf "%a %a"
              (self lvl) s
              print_front f
      in
        match s with
          | LF.Shift _ when not hasCtxVar ->  (* Print nothing at all, because the user would have written nothing at all *)
              ()
          | _ ->  (* For anything else, print a space first *)
              fprintf ppf " %a"
                (self lvl) s

    and fmt_ppr_lf_sub_deBruijn cD cPsi lvl ppf s =
      let rec self lvl ppf = function
        | LF.Shift (LF.NoCtxShift,n) ->
            fprintf ppf "^%s"
              (R.render_offset n)

        | LF.Shift (LF.CtxShift (LF.CtxOffset psi), n) -> 
            fprintf ppf "^(ctxShift (%s) + %s)"
              (R.render_ctx_var cD psi)
              (R.render_offset n)

        | LF.Shift (LF.CtxShift (LF.CtxName psi), n) -> 
            fprintf ppf "^(ctxShift (NAME %s ) + %s)"
              (R.render_name psi)
              (R.render_offset n)

        | LF.Shift (LF.CtxShift (_psi), n) -> 
            fprintf ppf "^(ctxShift ( _ ) + %s)"
              (R.render_offset n)


        | LF.Shift (LF.NegCtxShift (LF.CtxOffset psi), n) -> 
            fprintf ppf "^(NegShift(%s) + %s)"
              (R.render_ctx_var cD psi)
              (R.render_offset n)


        | LF.Shift (LF.NegCtxShift ( _psi), n) -> 
            fprintf ppf "^(NegShift( _ ) + %s)"
              (R.render_offset n)

        | LF.SVar (c, s) ->
            fprintf ppf "[%a.%a]"
              (self lvl) s
              (fmt_ppr_lf_cvar cD lvl) c

        | LF.Dot (f, s) ->
            fprintf ppf "%a . %a"
              (fmt_ppr_lf_front cD cPsi 1) f
              (self lvl) s
      in
        fprintf ppf "[%a]"
          (self lvl) s


    and fmt_ppr_lf_front cD cPsi lvl ppf = function
      | LF.Head h ->
          fprintf ppf "%a"
            (fmt_ppr_lf_head cD cPsi lvl) h

      | LF.Obj m ->
          fprintf ppf "%a"
            (fmt_ppr_lf_normal cD cPsi lvl) m

      | LF.Undef ->
          fprintf ppf "_"


    and fmt_ppr_csub_refinement cD cO_orig lvl ppf cs = begin match (cs, cO_orig) with 
      | (LF.CShift k, _ ) ->
          (match !Control.substitutionStyle with
            | Control.Natural -> fprintf ppf ""
            | Control.DeBruijn -> fprintf ppf "^%s" (string_of_int k))

      | (LF.CDot (cPsi, LF.CShift k), LF.Dec(cO', decl)) -> 
           let g = begin match decl with 
                     | LF.CDecl (g, _ , _) -> g 
                     | LF.CDeclOpt g    -> g 
                   end  
           in
             (match !Control.substitutionStyle with
                | Control.Natural -> 
                    fprintf ppf "%a = %s"
                      (fmt_ppr_lf_dctx cD 0) cPsi
                      (R.render_name g)
                | Control.DeBruijn -> 
                    fprintf ppf "%a = %s @ ,@ ^%s"
                      (fmt_ppr_lf_dctx cD 0) cPsi 
                      (R.render_name g)
                      (string_of_int k)
             )

      | (LF.CDot (cPsi, cs) , LF.Dec (cO', decl)) ->
           let g = begin match decl with 
                     | LF.CDecl (g, _ , _) -> g 
                     | LF.CDeclOpt g    -> g 
                   end  
           in 
             fprintf ppf "%a = %s @ ,@ %a"
               (fmt_ppr_lf_dctx cD 0) cPsi
               (R.render_name g)
               (fmt_ppr_csub_refinement cD cO' lvl) cs
    end

    and fmt_ppr_lf_csub cD lvl ppf cs = begin match cs with 
      | LF.CShift k ->
          (match !Control.substitutionStyle with
            | Control.Natural -> fprintf ppf ""
            | Control.DeBruijn -> fprintf ppf "^%s" (string_of_int k))

      | LF.CDot (cPsi, LF.CShift k) -> 
          (match !Control.substitutionStyle with
                | Control.Natural -> 
                    fprintf ppf "%a"
                      (fmt_ppr_lf_dctx cD 0) cPsi
                | Control.DeBruijn -> 
                    fprintf ppf "%a @ ,@ ^%s"
                      (fmt_ppr_lf_dctx cD 0) cPsi 
                      (string_of_int k)
             )

      | LF.CDot (cPsi, cs) ->
          fprintf ppf "%a @ ,@ %a"
            (fmt_ppr_lf_dctx cD 0) cPsi
            (fmt_ppr_lf_csub cD lvl) cs
    end


    and fmt_ppr_lf_msub cD lvl ppf = function
      | LF.MShift k ->
          fprintf ppf "^%s" (string_of_int k)

      | LF.MDot (f, s) ->
          fprintf ppf "%a@ ,@ %a"
            (fmt_ppr_lf_mfront cD 1) f
            (fmt_ppr_lf_msub cD lvl) s


    and fmt_ppr_lf_mfront cD lvl ppf = function
      | LF.MObj (psihat, m) ->
          let cPsi = phatToDCtx psihat in 
          fprintf ppf "M (%a . %a)"
            (fmt_ppr_lf_psi_hat cD lvl) cPsi
            (fmt_ppr_lf_normal cD cPsi lvl) m

      | LF.PObj (psihat, h) ->
          let cPsi = phatToDCtx psihat in 
          fprintf ppf "P (%a . %a)"
            (fmt_ppr_lf_psi_hat cD lvl) cPsi
            (fmt_ppr_lf_head cD cPsi lvl) h

      | LF.CObj (cPsi) ->
          fprintf ppf "M (%a )"
            (fmt_ppr_lf_dctx cD lvl) cPsi

      | LF.MV k ->
          fprintf ppf "MV %s"
            (R.render_cvar cD k)

      | LF.MUndef -> 
          fprintf ppf "_ "

    and fmt_ppr_lf_mmvar lvl ppf = function
      | LF.MInst (_, ({ contents = None } as u), _, _, tA, _) ->
          begin
            try
              fprintf ppf "?%s"
                (InstHashtbl.find inst_hashtbl u)
            with
              | Not_found ->
                  (* (* Should probably create a sep. generator for this -dwm *)
                  let sym = String.uppercase (Gensym.VarData.gensym ()) in
                  *)
                  (* Not working -bp *)
                  let sym = match Store.Cid.Typ.gen_mvar_name tA with 
                              | Some vGen -> vGen ()
                              | None -> Gensym.MVarData.gensym ()
                  in 
                      InstHashtbl.replace inst_hashtbl u sym
                    ; fprintf ppf "?%s" sym
          end
       
      | LF.MInst (_, {contents = Some m}, cD, cPsi, _, _) ->
          (* fprintf ppf "MMV SOME %a" *)
          fprintf ppf " %a"
            (fmt_ppr_lf_normal cD cPsi lvl) m

    and fmt_ppr_lf_cvar cD _lvl ppf = function
      | LF.Offset n ->
          fprintf ppf "%s"
            (R.render_cvar cD n)

      | LF.Inst (_, ({ contents = None } as u), _, tA, _) ->
          begin
            try
              fprintf ppf "?%s"
                (InstHashtbl.find inst_hashtbl u)
            with
              | Not_found ->
                  let sym = match Store.Cid.Typ.gen_mvar_name tA with 
                              | Some vGen -> vGen ()
                              | None -> Gensym.MVarData.gensym ()
                  in 
                      InstHashtbl.replace inst_hashtbl u sym
                    ; fprintf ppf "?%s" sym
          end

      | LF.PInst (_, ({ contents = None } as p), _, _, _) ->
          begin
            try
              fprintf ppf "?%s"
                (PInstHashtbl.find pinst_hashtbl p)
            with
              | Not_found ->
                  (* Should probably create a sep. generator for this -dwm *)
                  let sym = String.lowercase (Gensym.VarData.gensym ()) in
                      PInstHashtbl.replace pinst_hashtbl p sym
                    ; fprintf ppf "%s" sym
          end

      | LF.PInst _ ->               fprintf ppf "?PINST _ "
      | LF.Inst _ ->               fprintf ppf "?INST _ "

    and fmt_ppr_lf_ctx_var cD ppf = function     
      | LF.CInst (n, {contents = None}, _schema, _cO, _cD) -> 
          fprintf ppf "%s"
            (R.render_name n)

      | LF.CInst (_n, {contents = Some cPsi}, _schema, _cO', cD') -> 
          fprintf ppf "%a"
          (fmt_ppr_lf_dctx cD' 0) cPsi

      | LF.CtxOffset psi ->
          fprintf ppf "%s"
            (R.render_ctx_var cD psi)
      | LF.CtxName psi ->
          fprintf ppf "%s"
            (R.render_name psi)

    and fmt_ppr_lf_typ_rec cD cPsi _lvl ppf typrec = 
       let ppr_element cD cPsi ppf suffix = function
       | (x, tA) ->
              fprintf ppf "%s:%a%s"
                (R.render_name x)
                (fmt_ppr_lf_typ cD cPsi 0) tA
               suffix
       in 
       let rec ppr_elements cD cPsi ppf = function
         | LF.SigmaLast tA -> fmt_ppr_lf_typ cD cPsi 0 ppf tA
         | LF.SigmaElem (x, tA1, LF.SigmaLast tA2) -> 
             begin 
               ppr_element cD cPsi  ppf ". " (x, tA1); 
               fprintf ppf "%a" (fmt_ppr_lf_typ cD (LF.DDec(cPsi, LF.TypDecl(x, tA1))) 0) tA2 
             end
         | LF.SigmaElem (x, tA, tAs)  -> 
             begin 
               ppr_element cD cPsi ppf ", " (x, tA); 
               ppr_elements cD (LF.DDec(cPsi, LF.TypDecl (x, tA))) ppf  tAs 
             end
(*             | tA :: tAs -> *)
(*                   fprintf ppf "%a,@ %a" *)
(*                     (fmt_ppr_lf_typ cD cPsi 0) tA *)
(*                     ppr_typ_rec        tAs *)
(*                fprintf ppf "Sigma %a. %a" *)
       in
         ppr_elements cD cPsi ppf typrec

    and projectCtxIntoDctx = function
         |  LF.Empty -> LF.Null
         |  LF.Dec (rest, last) -> LF.DDec (projectCtxIntoDctx rest, last)

    and fmt_ppr_lf_schema lvl ppf = function
      | LF.Schema [] -> ()

      | LF.Schema (f :: []) ->
            fprintf ppf "%a"
              (fmt_ppr_lf_sch_elem lvl) f

      | LF.Schema (f :: fs) ->
            fprintf ppf "@[%a@]@ +@ @[%a@]"
              (fmt_ppr_lf_sch_elem lvl) f
              (fmt_ppr_lf_schema lvl) (LF.Schema fs)

    and frugal_block cD cPsi lvl ppf = function
      | LF.SigmaLast tA -> fmt_ppr_lf_typ cD cPsi 0 ppf tA
      | other -> fprintf ppf "block (%a)" (fmt_ppr_lf_typ_rec cD cPsi lvl) other

    and fmt_ppr_lf_sch_elem lvl ppf = function
      | LF.SchElem (LF.Empty, sgmDecl) ->
            fprintf ppf "%a"
              (frugal_block LF.Empty LF.Null lvl) sgmDecl
          
      | LF.SchElem (typDecls, sgmDecl) ->
          let cPsi = projectCtxIntoDctx typDecls in
            fprintf ppf "@[some [%a] %a@]"
              (ppr_typ_decl_dctx  LF.Empty)  cPsi
              (frugal_block LF.Empty cPsi lvl) sgmDecl


    and ppr_typ_decl_dctx cD ppf = function
      | LF.Null ->  
          fprintf ppf "" 
            
      | LF.DDec (LF.Null, LF.TypDecl (x, tA)) ->
          fprintf ppf "%s : %a"    (* formerly "., %s : %a"    -jd 2010-06-03 *)
            (R.render_name x)
            (fmt_ppr_lf_typ cD LF.Null 0) tA 
            
      | LF.DDec (cPsi, LF.TypDecl (x, tA)) ->
          fprintf ppf "%a, %s : %a"
            (ppr_typ_decl_dctx cD) cPsi
            (R.render_name x)
            (fmt_ppr_lf_typ cD cPsi 0) tA


    and fmt_ppr_lf_psi_hat cD _lvl ppf = function
      | LF.Null   -> fprintf ppf "" 

      | LF.CtxVar ctx_var ->
          fmt_ppr_lf_ctx_var cD ppf ctx_var

      | LF.DDec (LF.Null, LF.TypDeclOpt x) ->
          fprintf ppf "%s"
            (R.render_name x)

      | LF.DDec (cPsi, LF.TypDeclOpt x) ->
          fprintf ppf "%a, %s"
            (fmt_ppr_lf_psi_hat cD 0) cPsi
            (R.render_name x)

      | LF.DDec (LF.Null, LF.TypDecl(x, _ )) ->
          fprintf ppf "%s"
            (R.render_name x)

      | LF.DDec (cPsi, LF.TypDecl(x, _ )) ->
          fprintf ppf "%a, %s"
            (fmt_ppr_lf_psi_hat cD 0) cPsi
            (R.render_name x)

    and fmt_ppr_lf_dctx cD _lvl ppf = function
      | LF.Null ->
          fprintf ppf ""

      | LF.CtxVar ctx_var ->
          fmt_ppr_lf_ctx_var cD ppf ctx_var

      | LF.DDec (LF.Null, LF.TypDecl (x, tA)) ->
          fprintf ppf "%s : %a"
            (R.render_name x)
            (fmt_ppr_lf_typ cD LF.Null 0) tA

      | LF.DDec (LF.Null, LF.TypDeclOpt x) ->
          fprintf ppf "%s : _"
            (R.render_name x)

      | LF.DDec (cPsi, LF.TypDecl (x, tA)) ->
          fprintf ppf "%a, %s : %a"
            (fmt_ppr_lf_dctx cD 0) cPsi
            (R.render_name x)
            (fmt_ppr_lf_typ cD cPsi 0) tA

      | LF.DDec (cPsi, LF.TypDeclOpt x) ->
          fprintf ppf "%a, %s : _"
            (fmt_ppr_lf_dctx cD 0) cPsi
            (R.render_name x)

    and fmt_ppr_lf_mctx lvl ppf = function
      | LF.Empty ->
          fprintf ppf "."

      | LF.Dec (cD, ctyp_decl) ->
          fprintf ppf "%a, %a"
            (fmt_ppr_lf_mctx 0) cD
            (fmt_ppr_lf_ctyp_decl cD lvl) ctyp_decl

(*    and frugal_lf_octx lvl ppf = function
      | LF.Empty -> ()
      | other -> fprintf ppf "@[%a@]@ " (fmt_ppr_lf_octx lvl) other

    and fmt_ppr_lf_octx lvl ppf = function
      | LF.Empty ->
          fprintf ppf "."

      | LF.Dec (LF.Empty, ctyp_decl) ->
          fprintf ppf "%a"
            (fmt_ppr_lf_ctyp_decl LF.Empty LF.Empty lvl) ctyp_decl

      | LF.Dec (cO, ctyp_decl) ->
          fprintf ppf "%a, %a"
            (fmt_ppr_lf_octx 0) cO
            (fmt_ppr_lf_ctyp_decl LF.Empty LF.Empty lvl) ctyp_decl

*)

    and fmt_ppr_lf_kind cPsi lvl ppf = function
      | LF.Typ ->
          fprintf ppf "type"

      | LF.PiKind ((LF.TypDecl (x, a), LF.Maybe), k) ->
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s{%s : %a}@ %a%s@]"
              (l_paren_if cond)
              (R.render_name   x)
              (fmt_ppr_lf_typ LF.Empty cPsi  0) a
              (fmt_ppr_lf_kind (LF.DDec(cPsi, LF.TypDeclOpt  x)) 0) k
              (r_paren_if cond)

      | LF.PiKind ((LF.TypDecl (x, a), LF.No), k) ->
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s%a -> %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_lf_typ LF.Empty cPsi  1) a
              (fmt_ppr_lf_kind (LF.DDec(cPsi, LF.TypDeclOpt  x)) 0) k
              (r_paren_if cond)



    and fmt_ppr_lf_ctyp_decl cD _lvl ppf = function
      | LF.MDecl (u, tA, cPsi) ->
          fprintf ppf "{%s :: [%a. %a]}"
            (R.render_name u)
            (fmt_ppr_lf_dctx cD 0) cPsi
            (fmt_ppr_lf_typ cD cPsi 2) tA

      | LF.PDecl (p, tA, cPsi) ->
          fprintf ppf "{#%s :: [%a.%a]}"
            (R.render_name p)
            (fmt_ppr_lf_dctx cD 0) cPsi
            (fmt_ppr_lf_typ cD cPsi 2) tA

      | LF.SDecl (u, cPhi, cPsi) ->
          fprintf ppf "{%s :: [%a. %a]}"
            (R.render_name u)
            (fmt_ppr_lf_dctx cD 0) cPsi
            (fmt_ppr_lf_dctx cD 0) cPhi

      | LF.CDecl (name, schemaName, LF.No) ->
          fprintf ppf "{%s :: (%a)}"
            (R.render_name name)
            (fmt_ppr_lf_schema 0) (Store.Cid.Schema.get_schema schemaName)

      | LF.CDecl (name, schemaName, LF.Maybe) ->
          fprintf ppf "{%s :: {%a}}"
            (R.render_name name)
            (fmt_ppr_lf_schema 0) (Store.Cid.Schema.get_schema schemaName)

      | LF.MDeclOpt name -> 
          fprintf ppf "{%s :: _ }"
            (R.render_name name)


      | LF.PDeclOpt name -> 
          fprintf ppf "{%s :: _ }"
            (R.render_name name)
      | LF.CDeclOpt name -> 
          fprintf ppf "{%s :: _ }"
            (R.render_name name)


    (* Computation-level *)
    let rec fmt_ppr_cmp_kind cD lvl ppf = function
      | Comp.Ctype _ -> fprintf ppf "ctype"
      | Comp.PiKind (_, (ctyp_decl, _dep), cK) -> 
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s%a@ %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_lf_ctyp_decl cD 1) ctyp_decl
              (fmt_ppr_cmp_kind (LF.Dec(cD, ctyp_decl)) 1) cK
              (r_paren_if cond)

    let rec fmt_ppr_meta_spine cD lvl ppf = function 
      | Comp.MetaNil ->           
          fprintf ppf ""
      | Comp.MetaApp (mO, mS) -> 
          fprintf ppf " %a%a"
            (fmt_ppr_meta_obj  cD (lvl + 1)) mO
            (fmt_ppr_meta_spine   cD lvl) mS

    and fmt_ppr_meta_obj cD lvl ppf = function  
      | Comp.MetaCtx (_, cPsi) -> 
            fprintf ppf "[%a]"
              (fmt_ppr_lf_dctx cD 0) cPsi
      | Comp.MetaObj (_, phat, tM) ->
          let cond = lvl > 1 in
          let cPsi = phatToDCtx phat in
            fprintf ppf "%s[%a. %a]%s"
              (l_paren_if cond)
               (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_normal cD cPsi 0) tM
              (r_paren_if cond)
      | Comp.MetaObjAnn (_, cPsi, tM) ->
          let cond = lvl > 1 in
            fprintf ppf "%s[%a. %a]%s"
              (l_paren_if cond)
               (fmt_ppr_lf_dctx cD 0) cPsi
              (fmt_ppr_lf_normal cD cPsi 0) tM
              (r_paren_if cond)
         
    let rec fmt_ppr_cmp_typ cD lvl ppf = function
      | Comp.TypBase (_, c, mS)-> 
          let cond = lvl > 1 in
            fprintf ppf "%s%s%a%s"
              (l_paren_if cond)
              (R.render_cid_comp_typ c)
              (fmt_ppr_meta_spine cD 2) mS
              (r_paren_if cond)

      | Comp.TypBox (_, tA, cPsi) ->
          fprintf ppf "[%a. %a]"
                (fmt_ppr_lf_dctx cD 0) cPsi
                (fmt_ppr_lf_typ cD cPsi 2) tA

      | Comp.TypSub (_, cPhi, cPsi) ->
          fprintf ppf "[%a. %a]"
            (fmt_ppr_lf_dctx cD 0) cPsi
            (fmt_ppr_lf_dctx cD 0) cPhi

      | Comp.TypArr (tau1, tau2) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a -> %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_typ cD 2) tau1
              (fmt_ppr_cmp_typ cD 0) tau2
              (r_paren_if cond)

      | Comp.TypCross (tau1, tau2) ->
          let cond = lvl > 0 in
            fprintf ppf "%s%a * %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_typ cD 1) tau1
              (fmt_ppr_cmp_typ cD 0) tau2
              (r_paren_if cond)

      | Comp.TypCtxPi ((psi, w, dep), tau) ->
          let dep' = match dep with Comp.Explicit -> LF.No | Comp.Implicit -> LF.Maybe in 
          let cond = lvl > 1 in
            fprintf ppf "%s{%s : %s}@ %a%s"
              (l_paren_if cond)
              (R.render_name psi)
              (R.render_cid_schema w)
              (fmt_ppr_cmp_typ (LF.Dec(cD, LF.CDecl(psi, w, dep'))) 0) tau
              (r_paren_if cond)

      | Comp.TypPiBox ((ctyp_decl, dep ), tau) ->
          let d = match dep with Comp.Explicit -> "^e" | Comp.Implicit -> "^i" in 
          let cond = lvl > 1 in
            fprintf ppf "%s%a%s@ %a%s"
              (l_paren_if cond)
              (fmt_ppr_lf_ctyp_decl cD 1) ctyp_decl
              d
              (fmt_ppr_cmp_typ (LF.Dec(cD, ctyp_decl)) 1) tau
              (r_paren_if cond)

      | Comp.TypClo (_, _ ) ->             fprintf ppf " TypClo! "

      | Comp.TypBool -> fprintf ppf "Bool"

    let together = function
      | Comp.Syn _ -> false
      | Comp.Fun _ -> true
      | Comp.CtxFun _ -> true
      | Comp.MLam _ -> true
      | _ -> false

    let apart_left ppf e = if not (together e) then fprintf ppf "@[<2>"
    let apart_right ppf e = if not (together e) then fprintf ppf "@]"

    let rec fmt_ppr_pat_spine cD cG lvl ppf = (function 
      | Comp.PatNil -> fprintf ppf ""
      | Comp.PatApp (_, pat, pat_spine) -> 
          fprintf ppf "%a %a"
            (fmt_ppr_pat_obj cD cG (lvl+1)) pat
            (fmt_ppr_pat_spine cD cG lvl) pat_spine)

    and fmt_ppr_pat_obj cD cG lvl ppf = function 
      | Comp.PatEmpty (_, cPsi) -> 
          let cond = lvl > 1 in 
            fprintf ppf "%s[%a. {}]%s"
              (l_paren_if cond)
              (fmt_ppr_lf_dctx cD 0) cPsi
              (r_paren_if cond)
      | Comp.PatMetaObj (_, mO) -> 
          let cond = lvl > 1 in 
            fprintf ppf "%s%a%s"
              (l_paren_if cond)
              (fmt_ppr_meta_obj cD 0) mO
              (r_paren_if cond)
      | Comp.PatConst (_, c, pat_spine) -> 
          let cond = lvl > 1 in 
            fprintf ppf "%s%s %a%s"
              (l_paren_if cond)
              (R.render_cid_comp_const c)
              (fmt_ppr_pat_spine cD cG 2) pat_spine
              (r_paren_if cond)

      | Comp.PatPair (_, pat1, pat2) -> 
          fprintf ppf "(%a , %a)"
            (fmt_ppr_pat_obj cD cG 0) pat1
            (fmt_ppr_pat_obj cD cG 0) pat2            
      | Comp.PatTrue _ -> fprintf ppf "ttrue"
      | Comp.PatFalse _ -> fprintf ppf "ffalse"
      | Comp.PatAnn (_, pat, tau) -> 
          fprintf ppf "(%a : %a)"
            (fmt_ppr_pat_obj cD cG 0) pat
            (fmt_ppr_cmp_typ cD 0) tau

      | Comp.PatVar (_, offset ) ->               
          fprintf ppf "%s"
            (R.render_var cG offset)

      | Comp.PatFVar (_, name ) -> 
          fprintf ppf "%s"
            (R.render_name name)

    let rec fmt_ppr_cmp_exp_chk cD cG lvl ppf = function 
      | Comp.Syn (_, i) ->
          fmt_ppr_cmp_exp_syn cD cG lvl ppf (strip_mapp_args cD cG i)

      | Comp.Fun (_, x, e) ->
          let cond = lvl > 0 in
(*            fprintf ppf "@[<2>%sfn %s =>@ %a%s@]" *)
            fprintf ppf "%sfn %s => "
              (l_paren_if cond)
              (R.render_name x);

            fprintf ppf "%a%s"
              (fmt_ppr_cmp_exp_chk cD (LF.Dec(cG, Comp.CTypDeclOpt x))  0) e
              (r_paren_if cond);

      | Comp.CtxFun (_, x, e) ->
          let cond = lvl > 0 in
            fprintf ppf "@[<2>%smlam %s =>@ %a%s@]"
              (l_paren_if cond)
              (R.render_name x)
              (fmt_ppr_cmp_exp_chk (LF.Dec(cD, LF.CDeclOpt x)) cG 0) e
              (r_paren_if cond)

      | Comp.MLam (_, x, e) ->
          let cond = lvl > 0 in
(*            fprintf ppf "@[<2>%smlam %s => @ %a%s@]" *)
            fprintf ppf "%smlam %s => "
              (l_paren_if cond)
              (R.render_name x);
            fprintf ppf "%a%s"
              (fmt_ppr_cmp_exp_chk (LF.Dec(cD, LF.MDeclOpt x)) (Whnf.cnormCtx (cG, LF.MShift 1)) 0) e
              (r_paren_if cond);

      | Comp.Pair (_, e1, e2) -> 
            fprintf ppf "(%a , %a)"
              (fmt_ppr_cmp_exp_chk cD cG 0) e1
              (fmt_ppr_cmp_exp_chk cD cG 0) e2


      | Comp.LetPair(_, i, (x, y, e)) -> 
          let cond = lvl > 1 in
            fprintf ppf "@[<2>%slet <%s,%s> = %a@ in %a%s@]"
              (l_paren_if cond)
              (R.render_name x)
              (R.render_name y)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (fmt_ppr_cmp_exp_chk cD (LF.Dec(LF.Dec(cG, Comp.CTypDeclOpt x), Comp.CTypDeclOpt y)) 0) e
              (r_paren_if cond)


      | Comp.Let(_, i, (x, e)) -> 
          let cond = lvl > 1 in
            fprintf ppf "@[<2>%slet %s = %a@ in %a%s@]"
              (l_paren_if cond)
              (R.render_name x)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (fmt_ppr_cmp_exp_chk cD (LF.Dec(cG, Comp.CTypDeclOpt x)) 0) e
              (r_paren_if cond)

      | Comp.Box (_ , pHat, tM) ->
          let cond = lvl > 1 in
          let cPsi = phatToDCtx pHat in
            fprintf ppf "%s[%a. %a]%s"
              (l_paren_if cond)
              (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_normal cD cPsi 0) tM
              (r_paren_if cond)


      | Comp.SBox (_ , pHat, sigma) ->
          let cond = lvl > 1 in
          let cPsi = phatToDCtx pHat in
            fprintf ppf "%s[%a. %a]%s"
              (l_paren_if cond)
              (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_sub cD cPsi 0) sigma
              (r_paren_if cond)



      | Comp.Case (_, prag, i, bs) ->
          let cond = lvl > 0 in
(*            fprintf ppf "@ @[<0>%scase %a of%s@ @[<0>%a@]%s@]" *)
            fprintf ppf "@ %s@[<v>case @[%a@] of%s%a@]%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (match prag with Pragma.RegularCase -> " " | Pragma.PragmaNotCase -> " %not ")
              (fmt_ppr_cmp_branches cD cG 0) bs
              (r_paren_if cond)

      | Comp.If (_, i, e1, e2) -> 
          let cond = lvl > 1 in
            fprintf ppf "@[<2>%sif %a @[<-1>then %a @]else %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (fmt_ppr_cmp_exp_chk cD cG 0) e1
              (fmt_ppr_cmp_exp_chk cD cG 0) e2
              (r_paren_if cond)

      | Comp.Hole (_) -> fprintf ppf " ? "

    and strip_mapp_args cD cG i = 
      if !Control.printImplicit then 
        i 
      else 
        let (i', _ ) = strip_mapp_args' cD cG i in i'

    and strip_mapp_args' cD cG i = match i with 
      | Comp.Const prog -> 
          (i,  implicitCompArg  (Store.Cid.Comp.get prog).Store.Cid.Comp.typ)
      | Comp.DataConst c -> 
          (i,  implicitCompArg  (Store.Cid.CompConst.get c).Store.Cid.CompConst.typ)
      | Comp.Var x -> 
          begin match Context.lookup cG x with
              None -> (i, 0) 
            | Some tau -> (i,  implicitCompArg tau)
          end 

      | Comp.Apply (loc, i, e) -> 
          let (i', _ ) = strip_mapp_args' cD cG i in 
            (Comp.Apply (loc, i', e), 0)

      | Comp.CtxApp (loc, i, cPsi) ->
          let (i', _ ) = strip_mapp_args' cD cG i in 
            (Comp.CtxApp (loc, i', cPsi), 0)

      | Comp.MApp (loc, i1, (phat, tM) ) -> 
          let (i', stripArg) = strip_mapp_args' cD cG i1 in 
            if stripArg = 0 then 
              (Comp.MApp (loc , i', (phat, tM)), 0)
            else 
              (i', stripArg - 1 )

      | Comp.Ann (e, tau) -> (Comp.Ann (e, tau), 0)


    and implicitCompArg tau = begin match tau with 
      | Comp.TypPiBox ((LF.MDecl _ , Comp.Implicit), tau) -> 
          implicitCompArg tau + 1 
      | _ -> 0
    end
        

    and fmt_ppr_cmp_exp_syn cD cG lvl ppf = function
      | Comp.Var x ->
          fprintf ppf "%s"
            (R.render_var cG x)

      | Comp.Const prog ->
          fprintf ppf "%s"
            (R.render_cid_prog prog)

      | Comp.DataConst c ->
          fprintf ppf "%s"
            (R.render_cid_comp_const c)

      | Comp.Apply (_, i, e) ->
          let cond = lvl > 1 in
            fprintf ppf "%s@[<2>%a@ %a@]%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              (fmt_ppr_cmp_exp_chk cD cG 2) e
              (r_paren_if cond)

      | Comp.CtxApp (_, i, cPsi) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a [%a]%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              (fmt_ppr_lf_dctx cD 0) cPsi
              (r_paren_if cond)

      | Comp.MApp (_, i, (pHat, Comp.NormObj tM )) ->
          let cond = lvl > 1 in
          let cPsi = phatToDCtx pHat in
            fprintf ppf "%s%a@ [%s%a. %a%s]%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              ("")
              (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_normal cD cPsi 0) tM
              ("")
              (r_paren_if cond)


      | Comp.MApp (_, i, (pHat, Comp.NeutObj head)) ->
          let cond = lvl > 1 in
          let cPsi = phatToDCtx pHat in
            fprintf ppf "%s%a @ < %a. %a > %s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_head cD cPsi 0) head
              (r_paren_if cond)

      | Comp.MApp (_, i, (pHat, Comp.SubstObj s)) ->
          let cond = lvl > 1 in
          let cPsi = phatToDCtx pHat in
            fprintf ppf "%s%a @ < %a. %a > %s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_sub cD cPsi 0) s
              (r_paren_if cond)

      | Comp.PairVal (loc, i1, i2) -> 
            fprintf ppf "(%a , %a)"
              (fmt_ppr_cmp_exp_syn cD cG 1) i1
              (fmt_ppr_cmp_exp_syn cD cG 1) i2

      | Comp.Ann (e, tau) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a : %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_chk cD cG 1) e
              (fmt_ppr_cmp_typ cD 2) (Whnf.cnormCTyp (tau, Whnf.m_id))
              (r_paren_if cond)



      | Comp.Equal (_, i1, i2) -> 
            fprintf ppf "%a == %a"
              (fmt_ppr_cmp_exp_syn cD cG 1) i1
              (fmt_ppr_cmp_exp_syn cD cG 1) i2 

      | Comp.Boolean true -> 
          fprintf ppf "ttrue"

      | Comp.Boolean false -> 
          fprintf ppf "ffalse"

    and fmt_ppr_cmp_value lvl ppf = function
      | Comp.FunValue _ -> fprintf ppf " fn "
      | Comp.RecValue _ -> fprintf ppf " rec "
      | Comp.MLamValue _ -> fprintf ppf " mlam "
      | Comp.CtxValue _ -> fprintf ppf " mlam "
      | Comp.BoxValue _ -> fprintf ppf " box "
      | Comp.ConstValue _ -> fprintf ppf " const "

    and fmt_ppr_cmp_branch_prefix _lvl ppf = function 
      | LF.Empty -> ()
      | other -> 
          (let rec fmt_ppr_ctyp_decls' ppf = function
            | LF.Dec (LF.Empty, decl) ->
                fprintf ppf "%a"
                  (fmt_ppr_lf_ctyp_decl LF.Empty 1) decl
            | LF.Dec (cD, decl) ->
                fprintf ppf "%a @ %a"
                  (fmt_ppr_ctyp_decls') cD
                  (fmt_ppr_lf_ctyp_decl cD 1) decl
          in             
            fprintf ppf "@[%a@]@ " (fmt_ppr_ctyp_decls') other 
          )

    and fmt_ppr_cmp_branches cD cG lvl ppf = function
      | [] -> ()

      | b :: [] ->
          fprintf ppf "%a"
            (fmt_ppr_cmp_branch cD cG 0) b

      | b :: bs ->
(*          fprintf ppf "%a @ @[<0>| %a@]" *)
          fprintf ppf "%a%a"
            (fmt_ppr_cmp_branch cD cG 0) b
            (fmt_ppr_cmp_branches cD cG lvl) bs

    and fmt_ppr_pattern cD1' cPsi ppf = function
      | Comp.NormalPattern (tM, _) -> fmt_ppr_lf_normal cD1' cPsi 0 ppf tM
      | Comp.EmptyPattern ->fprintf ppf "@[{}@]"

    and fmt_ppr_branch_body cD1' cG t ppf = function
      | Comp.NormalPattern (_, e) -> fmt_ppr_cmp_exp_chk cD1' (Whnf.cnormCtx (cG, t)) 1 ppf e
      | Comp.EmptyPattern -> ()
    
    and fmt_ppr_cmp_branch cD cG _lvl ppf = function
      | Comp.EmptyBranch (_, cD1, pat, t) -> 
          fprintf ppf "@ @[<v2>| @[<v0>%a@[[ %a : %a ] @]  @]@  "
            (fmt_ppr_cmp_branch_prefix  0) cD1
            (fmt_ppr_pat_obj cD1 LF.Empty 0) pat
            (fmt_ppr_refinement cD1 cD 2) t


      | Comp.Branch (_, cD1', _cG, Comp.PatMetaObj (_, mO), t, e) -> 
          fprintf ppf "@ @[<v2>| @[<v0>%a@[[%a  : %a ] @]  => @]@ @[<2>@ %a@]@]@ "
            (fmt_ppr_cmp_branch_prefix  0) cD1'
            (fmt_ppr_meta_obj cD1' 0) mO
            (* this point is where the " : " is in the string above *)
            (fmt_ppr_refinement cD1' cD 2) t
            (* NOTE: Technically: cD |- cG ctx and 
             *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
             * -bp
             *) 
            (fmt_ppr_cmp_exp_chk cD1' cG 1) e

      | Comp.Branch (_, cD1', cG', pat, t, e) -> 
          let cG_t = cG (* Whnf.cnormCtx (cG, t) *) in  
          let cG_ext = Context.append cG_t cG' in 

          fprintf ppf "@ @[<v2>| @[<v0>%a ; %a@[ . %a  : %a  @]  => @]@ @[<2>@ %a@]@]@ "
             (fmt_ppr_cmp_branch_prefix  0) cD1'
            (fmt_ppr_cmp_gctx cD1' 0) cG' 
             (fmt_ppr_pat_obj cD1' cG' 0) pat
            (* this point is where the " : " is in the string above *)
            (fmt_ppr_refinement cD1' cD 2) t
            (* NOTE: Technically: cD |- cG ctx and 
             *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
             * -bp
             *) 
            (fmt_ppr_cmp_exp_chk cD1' cG_ext 1) e

      | Comp.BranchBox (_, cD1', (cPsi, pattern, t, _cs)) ->
          let rec ppr_ctyp_decls' ppf = function
            | LF.Dec (LF.Empty, decl) ->
                fprintf ppf "%a"
                  (fmt_ppr_lf_ctyp_decl cD 1) decl
            | LF.Dec (cD, decl) ->
                fprintf ppf "%a @ %a"
                  (ppr_ctyp_decls' ) cD
                  (fmt_ppr_lf_ctyp_decl cD 1) decl
          and ppr_ctyp_decls ppf = function
            | LF.Empty -> ()
            | other -> fprintf ppf "@[%a@]@ " (ppr_ctyp_decls') other
          in
(*            fprintf ppf "%a @ [%a] %a : %a[%a] => @ @[<2>%a@]@ " *)
(*            fprintf ppf "%a @ %a @ ([%a] %a) @ : %a ; %a  => @ @[<2>%a@]@ " *)
            fprintf ppf "@ @[<v2>| @[<v0>%a@[([%a. %a])@ : %a @]  => @]@ @[<2>@ %a@]@]@ "
              (ppr_ctyp_decls ) cD1'
              (* (fmt_ppr_lf_psi_hat cO' 0) cPsi *)
              (fmt_ppr_lf_dctx cD1' 0) cPsi 
              (fmt_ppr_pattern cD1' cPsi) pattern
                 (* this point is where the " : " is in the string above *)
              (* (fmt_ppr_lf_msub cD1' 2) t   *)
              (fmt_ppr_refinement cD1' cD 2) t
              (* NOTE: Technically: cD |- cG ctx and 
               *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
               * -bp
               *) 
              (fmt_ppr_branch_body cD1' cG t) pattern
(*              (fmt_ppr_cmp_exp_chk cO' cD1' (Whnf.cnormCtx (cG, t)) 1) e *)


    (* cD |- t : cD'  *)

    and fmt_ppr_refinement cD cD0 lvl ppf t = begin match (t, cD0) with
      | (LF.MShift k, _ ) ->
          (match !Control.substitutionStyle with
            | Control.Natural -> fprintf ppf ""
            | Control.DeBruijn -> fprintf ppf "^%s" (string_of_int k))

      | (LF.MDot (f, LF.MShift k), LF.Dec(cD', decl)) -> 
          (match !Control.substitutionStyle with
            | Control.Natural ->
                fprintf ppf "%a"
                  (fmt_ppr_refine_elem cD decl 1) f
            | Control.DeBruijn -> 
                fprintf ppf "%a@ ,@ ^%s"
                  (fmt_ppr_refine_elem cD decl 1) f
                  (string_of_int k))


      | (LF.MDot (f, s), LF.Dec(cD', decl)) -> 
          fprintf ppf "%a@ ,@ %a"
            (fmt_ppr_refine_elem cD decl 1) f
            (fmt_ppr_refinement cD cD' lvl) s
    end


    and fmt_ppr_refine_elem cD decl lvl ppf = function 
      | LF.CObj (cPsi) ->
          let psi    = 
            begin match decl with 
              | LF.CDecl(psi, _ , _) -> psi 
              | LF.CDeclOpt psi -> psi
            end in
          fprintf ppf "%a = %s"
            (fmt_ppr_lf_dctx cD lvl) cPsi
            (R.render_name psi)

      | LF.MObj (psihat, m) ->
          let cPsi = phatToDCtx psihat in 
          let u    = 
            begin match decl with 
              | LF.MDecl(u, _ , _ ) -> u 
              | LF.MDeclOpt u -> u 
            end in
          fprintf ppf "%a . %a = %s"           
            (fmt_ppr_lf_psi_hat cD lvl) cPsi
            (fmt_ppr_lf_normal cD cPsi lvl) m
            (R.render_name u)

      | LF.PObj (psihat, h) ->
          let cPsi = phatToDCtx psihat in 
          let p = 
            begin match decl with 
              | LF.PDecl(p, _ , _ ) -> p 
              | LF.PDeclOpt p -> p
              | LF.MDeclOpt u -> u
            end in
          fprintf ppf "%a . %a = #%s"
            (fmt_ppr_lf_psi_hat cD lvl) cPsi
            (fmt_ppr_lf_head cD cPsi lvl) h
            (R.render_name p)


    and fmt_ppr_cmp_gctx cD lvl ppf = function
      | LF.Empty ->
          fprintf ppf "."

      | LF.Dec (cG, Comp.CTypDecl (x, tau)) ->
          fprintf ppf "%a, %s: %a"
            (fmt_ppr_cmp_gctx cD 0) cG
            (R.render_name x)
            (fmt_ppr_cmp_typ cD lvl) tau



    let rec fmt_ppr_sgn_decl lvl ppf = function
      | Sgn.Const (c, a) ->
          fprintf ppf "%s : %a.@.@?"
            (R.render_cid_term c)
            (fmt_ppr_lf_typ LF.Empty  LF.Null lvl)  a

      | Sgn.Typ (a, k) ->
          fprintf ppf "%s : %a.@.@?"
            (R.render_cid_typ  a)
            (fmt_ppr_lf_kind LF.Null lvl) k

      | Sgn.Schema (w, schema) ->
          fprintf ppf "schema %s : %a;@.@?"
            (R.render_cid_schema  w)
            (fmt_ppr_lf_schema lvl) schema

      | Sgn.Rec (f, tau, e) -> (* WARNING: this case is not used.
                                  reconstruct.ml has similar code itself; search for \nrec in reconstruct.ml *)
          fprintf ppf "rec %s : %a = @ @[<2>%a ;@]@?@."
            (R.render_cid_prog  f)
            (fmt_ppr_cmp_typ LF.Empty lvl) tau
            (fmt_ppr_cmp_exp_chk  LF.Empty
               (LF.Dec(LF.Empty, Comp.CTypDecl ((Store.Cid.Comp.get f).Store.Cid.Comp.name ,  tau)))  lvl) e

      | Sgn.Pragma (LF.NamePrag _cid_tp) ->  ()
 
 

    (* Regular Pretty Printers *)
    let ppr_sgn_decl           = fmt_ppr_sgn_decl              std_lvl std_formatter 
    let ppr_lf_ctyp_decl  cD   = fmt_ppr_lf_ctyp_decl cD    std_lvl std_formatter 
    let ppr_lf_kind cPsi       = fmt_ppr_lf_kind cPsi          std_lvl std_formatter
    let ppr_lf_typ  cD cPsi    = fmt_ppr_lf_typ cD cPsi     std_lvl std_formatter
    let ppr_lf_normal cD cPsi  = fmt_ppr_lf_normal cD cPsi  std_lvl std_formatter
    let ppr_lf_tuple cD cPsi   = fmt_ppr_lf_tuple cD cPsi      std_lvl std_formatter
    let ppr_lf_head cD cPsi    = fmt_ppr_lf_head cD cPsi    std_lvl std_formatter
    let ppr_lf_spine cD cPsi   = fmt_ppr_lf_spine cD cPsi   std_lvl std_formatter
    let ppr_lf_sub cD cPsi     = fmt_ppr_lf_sub cD cPsi     std_lvl std_formatter
    let ppr_lf_front cD cPsi   = fmt_ppr_lf_front cD cPsi   std_lvl std_formatter
    let ppr_lf_msub  cD        = fmt_ppr_lf_msub cD         std_lvl std_formatter
    let ppr_lf_mfront cD       = fmt_ppr_lf_mfront cD       std_lvl std_formatter
    let ppr_lf_cvar cD         = fmt_ppr_lf_cvar cD         std_lvl std_formatter

    let ppr_lf_schema          = fmt_ppr_lf_schema             std_lvl std_formatter
    let ppr_lf_sch_elem        = fmt_ppr_lf_sch_elem           std_lvl std_formatter

    let ppr_lf_typ_rec cD cPsi = fmt_ppr_lf_typ_rec cD cPsi std_lvl std_formatter

    let ppr_lf_psi_hat cD      = fmt_ppr_lf_psi_hat cD         std_lvl std_formatter
    let ppr_lf_dctx cD         = fmt_ppr_lf_dctx cD         std_lvl std_formatter
    let ppr_lf_mctx            = fmt_ppr_lf_mctx            std_lvl std_formatter
    let ppr_cmp_gctx cD        = fmt_ppr_cmp_gctx cD        std_lvl std_formatter
    let ppr_cmp_kind cD        = fmt_ppr_cmp_kind cD        std_lvl std_formatter
    let ppr_cmp_typ cD         = fmt_ppr_cmp_typ cD         std_lvl std_formatter
    let ppr_cmp_exp_chk cD cG  = fmt_ppr_cmp_exp_chk cD cG  std_lvl std_formatter
    let ppr_cmp_exp_syn cD cG  = fmt_ppr_cmp_exp_syn cD cG  std_lvl std_formatter
    let ppr_pat_obj cD cG      = fmt_ppr_pat_obj cD cG  std_lvl std_formatter
    let ppr_cmp_branches cD cG = fmt_ppr_cmp_branches cD cG std_lvl std_formatter
    let ppr_cmp_branch cD cG   = fmt_ppr_cmp_branch cD cG   std_lvl std_formatter

    let subToString cD cPsi s'  = 
      let s = Whnf.normSub s' in 
        fmt_ppr_lf_sub cD cPsi std_lvl str_formatter s
        ; flush_str_formatter ()

    let spineToString cD cPsi sS  = 
      let tS = Whnf.normSpine sS in 
        fmt_ppr_lf_spine cD cPsi std_lvl str_formatter tS
        ; flush_str_formatter ()

    let typToString cD cPsi sA    = 
      let tA = Whnf.normTyp sA in 
        fmt_ppr_lf_typ cD cPsi std_lvl str_formatter tA
        ; flush_str_formatter ()

    let typRecToString cD cPsi typrec_clo = 
      let typrec = Whnf.normTypRec typrec_clo in 
      fmt_ppr_lf_typ_rec cD cPsi std_lvl str_formatter typrec
      ; flush_str_formatter () 

    let kindToString cPsi sK   = 
      let tK = Whnf.normKind sK in 
      fmt_ppr_lf_kind cPsi std_lvl str_formatter tK
      ; flush_str_formatter ()

    let tupleToString cD cPsi tuple = 
      fmt_ppr_lf_tuple cD cPsi std_lvl str_formatter tuple
      ; flush_str_formatter ()

    let headToString cD cPsi h = 
      fmt_ppr_lf_head cD cPsi std_lvl str_formatter h
      ; flush_str_formatter ()

    let normalToString cD cPsi sM = 
      let tM = Whnf.norm sM in 
        fmt_ppr_lf_normal cD cPsi std_lvl str_formatter tM
        ; flush_str_formatter ()

    let attempt message f fallback =
      try
        f()
      with
        | Match_failure (file, line, column) ->
            (print_string ("pretty.ml attempt: \"" ^ message ^ "\" crashed: "
                           ^ file ^ " " ^ string_of_int line ^ " " ^ string_of_int column ^ "\n");
             exit 230)
        | _ -> (print_string ("pretty.ml attempt: \"" ^ message ^ "\" crashed.\n");
                fallback (*exit 231*) )

    let dctxToString cD cPsi =
      let (cPsi', notice) =  try (Whnf.cnormDCtx (cPsi, Whnf.m_id),  "")
                            with _ -> (cPsi, "{dctxToString: Whnf.cnormDCtx    crashed}") 
      in
      let cPsi' = attempt "dctxToString whnf" (fun () -> Whnf.normDCtx cPsi') cPsi' in 
       notice ^ (fmt_ppr_lf_dctx cD std_lvl str_formatter cPsi';
                 flush_str_formatter ()) 

    let mctxToString cD = 
(*      let cD' = attempt "mctxToString normMCtx" (fun () -> Whnf.normMCtx cD) cD in  *)
      let cD' = Whnf.normMCtx cD in 
      fmt_ppr_lf_mctx std_lvl str_formatter cD'
        ; flush_str_formatter ()

    let schemaToString schema = 
      fmt_ppr_lf_schema std_lvl str_formatter schema
      ; flush_str_formatter ()

    let schElemToString sch_elem = 
      fmt_ppr_lf_sch_elem std_lvl str_formatter sch_elem
      ; flush_str_formatter ()


    let metaObjToString  cD mO = 
        fmt_ppr_meta_obj cD std_lvl str_formatter mO
        ; flush_str_formatter ()

    let gctxToString cD cG = 
      let cG' = Whnf.normCtx cG in 
        fmt_ppr_cmp_gctx cD std_lvl str_formatter cG'
        ; flush_str_formatter ()

    let patternToString cD cG pat    = 
      let pat' = Whnf.cnormPattern (pat , Whnf.m_id) in 
       fmt_ppr_pat_obj cD cG std_lvl str_formatter pat'
      ; flush_str_formatter ()

    let expChkToString cD cG e    = 
      let e' = Whnf.cnormExp (e , Whnf.m_id) in 
       fmt_ppr_cmp_exp_chk cD cG std_lvl str_formatter e'
      ; flush_str_formatter ()

    let expSynToString cD cG i   = 
      fmt_ppr_cmp_exp_syn cD cG std_lvl str_formatter i
      ; flush_str_formatter ()

    let valueToString v = 
      fmt_ppr_cmp_value std_lvl str_formatter v
      ; flush_str_formatter ()

    let branchToString cD cG  b    = 
      fmt_ppr_cmp_branch cD cG std_lvl str_formatter b
      ; flush_str_formatter ()

    let compTypToString cD tau  = 
      let tau' = Whnf.normCTyp (Whnf.cnormCTyp (tau, Whnf.m_id)) in 
        fmt_ppr_cmp_typ cD std_lvl str_formatter tau'
        ; flush_str_formatter ()

    let compKindToString cD cK  = 
(*      let cK' = Whnf.normCKind cK in  *)
        fmt_ppr_cmp_kind cD std_lvl str_formatter cK
        ; flush_str_formatter ()

    let msubToString cD   s    = 
      let s' = Whnf.cnormMSub s in 
      fmt_ppr_lf_msub cD std_lvl str_formatter s'
      ; flush_str_formatter ()

  end (* Int.Make *)

  (* Default Error Pretty Printer Functor Instantiation *)
  module DefaultPrinter = Make (Store.Cid.NamedRenderer)

end (* Int *)

module Ext = Prettyext.Ext
