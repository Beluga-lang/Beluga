% Value soundness 
% Author: Brigitte Pientka
%
% TODO extend with functions and function application

exp  : type.  
z    : exp.
suc  : exp -> exp.
letv : exp -> (exp -> exp) -> exp.

value : exp -> type.
v_z   : value z.
v_s   : {E:exp} value E -> value (suc E).

eval : exp -> exp -> type.
ev_z : eval z z.
ev_s : {E:exp} {V:exp} eval E V -> eval (suc E) (suc V).
ev_l : {E1:exp} {E2:exp -> exp} {V1:exp} {V:exp} 
       eval (E2 V1) V  -> eval E1 V1 -> eval (letv E1 (\x. E2 x)) V.

% rec vs : {E::exp[]} {V::exp[]} (eval E[.] V[.])[] -> (value V[.])[] = 
%     mlam E => mlam V => fn e =>
%         case e of 
%             box(. ev_z) : (eval z z)[] => box(. v_z)

% %           | box(. ev_s E[.] V[.] D[.]) => 
% %             let 
% %                 box(. F[.]) = vs <. E[.]> <. V[.]> box(. D[.])
% %             in
% %                 box(. vs_s V[.] F[.])
% %             end

%           | {E::exp[]} {V::exp[]} {D::(eval E[.] V[.])[]}
%             box(. ev_s E[.] V[.] D[.]) : (eval (suc E[.]) (suc V[.]))[] =>
%             (case vs <. E[.]> <. V[.]> box(. D[.]) of
%                 % TODO investigate why it doesn't work without the extra {V::exp[]}
%                 {V::exp[]} {F::(value V[.])[]} box(. F[.]) : (value V[.])[] =>
%                 box(. v_s V[.] F[.]))

%          | {E1::exp[]} {E2::exp[x:exp]} {V1::exp[]} {V::exp[]}
%            {D1::(eval E1[.] V1[.])[]} {D2::(eval E2[., V1[.]] V[.])[]}
%            box(. ev_l E1[.] (\x . E2[., x]) V1[.] V[.] D2[.] D1[.]) :
%            (eval (letv E1[.] (\x . E2[., x])) V[.])[] =>
%            vs <. E2[., V1[.]]> <. V[.]>  box(. D2[.]);
