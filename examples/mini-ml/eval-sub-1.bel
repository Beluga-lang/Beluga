% Substitution based evaluator
%   call-by-value strategy
%
%   Author: Brigitte Pientka
%

exp: type.
nat: type.

num: nat -> exp.
add: exp -> exp -> exp.
letv: exp -> (nat -> exp) -> exp.


z  : nat.
suc: nat -> nat.

rec add : nat[ ] -> nat[ ] -> nat[ ] = 
fn a => fn b =>
   (case a of
        [ ] z  => b
      | [ ] suc U =>
      let [ ] V = b in add ([ ] U) ([ ] suc V)
)
;

rec eval : exp[ ] -> nat[ ] = 
fn e => 
(case e of
   [ ] num U => [ ] U
 | [ ] add U W  => 
       add (eval ([ ]  U)) (eval ([ ] W))

 | [ ] letv U (\ x . (W x))  => 

    case (eval ([ ] U)) of 
        [ ] V  =>  
          eval ([ ] (W V))
);
