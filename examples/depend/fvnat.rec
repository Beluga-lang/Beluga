tp: type.
nat: tp.
bool: tp.
arr : tp -> tp -> tp.


exp : tp -> type.
z   : exp nat.
suc : exp nat -> exp nat.
and : exp bool -> exp bool -> exp bool.
tt  : exp bool.
ff  : exp bool.

app:  exp (arr T T') -> exp T -> exp T'.
lam : (exp T -> exp T') -> exp (arr T T').

opt: type.
NONE: opt.
SOME: exp T -> opt.

schema w = some [T:tp] block exp T;

rec FVnat : {g:(w)*} (exp T![.]!)[g] -> (opt)[g] =
FN g  => % mlam T  => 
 fn e => 
 (case e of
    box(g . z)             => box(g . NONE)
  | box(g . tt)            => box(g . NONE)
  | box(g . ff)            => box(g . NONE)

  | box(g . #p![id]!) 
    => box(g . SOME  #p![id]!)

  | box(g . suc U![id]!)  => FVnat [g] (box(g . U![id]!))

  | box(g . and U![id]! V![id]!)  => 
       (case FVnat [g] (box(g . U![id]!)) of
          box(g . NONE)   => FVnat [g] (box(g . V![id]!))
        | box(g . SOME  #p![id]!)  => box(g . SOME  #p![id]!))

  | box(g . app U![id]! V![id]!)  => 
       (case FVnat [g] (box(g . U![id]!)) of
          box(g . NONE)   => FVnat [g] (box(g . V![id]!))

        | box(g . SOME  #p![id]!)  => box(g . SOME  #p![id]!))

  | box (g . lam (\x . U![id,x]!)) => 
     (case (FVnat [g, x:exp _ ] box(g, x. U![id,x]!)) of 
        box (g,x: exp _ . NONE) => box(g . NONE)
      | box (g, x: exp _ . SOME x)   => box(g . NONE) % technically we need to initiate backtracking
      | box (g, x: exp _ . SOME #p![id]!) => box(g . SOME #p![id]!)
      )
);


