% Value soundness 
% Author: Brigitte Pientka
%

exp  : type.  
z    : exp.
suc  : exp -> exp.
letv : exp -> (exp -> exp) -> exp.
lam  : (exp -> exp) -> exp.
app  : exp -> exp -> exp.

tp   : type.
nat  : tp.
arrow  : tp -> tp -> tp.


% Evaluation 
eval : exp -> exp -> type.
ev_z : eval z z.

ev_s : eval E V -> eval (suc E) (suc V).

ev_l : eval (E2 V1) V  -> eval E1 V1 -> eval (letv E1 (\x. E2 x)) V.

ev_lam: eval (lam (\x. E x)) (lam (\x. E x)).

ev_app: eval E1 (lam (\x. E x)) -> eval E2 V2 -> eval (E V2) V 
     -> eval (app E1 E2) V.


% Typing 

oft : exp -> tp -> type.

tp_z     : oft z nat.
tp_s     : oft E nat -> 
	   oft (suc E) nat.

tp_lam :   ({x:exp} oft x T1 -> oft (E x) T2) 
        -> oft (lam (\ x . E x)) (arrow T1 T2).

tp_app : oft E2 T2 -> 
         oft E1 (arrow T2 T1)
	 -> oft (app E1 E2) T1.

tp_letv : ({x:exp} oft x T1 -> oft (E2 x) T2) -> 
	   oft E1 T1  
        -> oft (letv E1 (\ x . E2 x)) T2.



% Type preservation proof
rec tps :  (eval E V)[ ] -> (oft E T)[ ]
         -> (oft V T)[ ]  = 
fn e => fn d => 
  case e of 
    [ ] ev_z => 
    let [ ] tp_z = d in [ ] tp_z

  | [ ]  ev_s E1  =>
    let [ ] tp_s D1 = d in 
    let [ ] F1      = tps ([ ] E1) ([ ] D1) in 
      [ ] tp_s F1
	

  | [ ] ev_lam =>  
    let [ ] tp_lam (\x. \u. (D x u)) = d in d


   | [ ] ev_app E1 E2 E3 => 
    let [ ] tp_app D2 D1        = d in 
    let [ ] tp_lam (\x. \u. (D x u)) = tps ([ ] E1) ([ ] D1)  in 
    let [ ] F2                       = tps ([ ] E2) ([ ] D2)  in 
        tps ([ ] E3) ([ ] (D  _  F2))


;