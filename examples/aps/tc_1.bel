nat:type.
zero: nat.
succ: nat -> nat.

even:nat -> type.
ev_z: even zero.
ev_s: even N -> even (succ (succ N)).

odd : nat -> type.
od_sz : odd (succ zero).
od_s : odd N -> odd (succ (succ N)).

le : nat -> nat -> type.
le_z : le zero N.
le_s : le N M -> le (succ N) (succ M).

--mquery 1 * 4 {N: [⊢ nat]} {D: [⊢ even N]} [⊢ odd (succ N)].

--mquery 1 * 4 [ |- even (succ (succ zero))].

--mquery 1 * 2 [ |- even (succ (succ (succ zero)))].
--mquery 1 * * [ |- odd (succ (succ (succ zero)))].

--mquery 1 * 7 [ |- le (succ (succ zero)) (succ (succ (succ (succ zero))))].

--mquery 1 * 2 {N:[ |- nat]}{D:[ |- even N]} [ |- even (succ (succ N))].

--mquery 0 * 1 {N:[ |- nat]}[ |- even (succ (succ N))].

--mquery 1 * * {N1:[ ⊢ nat]}{D : [ ⊢ odd N1]} {F:[ ⊢ even (succ N1)]}
	   [ |- even (succ (succ (succ N1)))].

--mquery 2 2 * [⊢ even (succ N)].

--mquery 1 * 3 {N: [ |- nat]}{D: [|- even N]} [|- even (succ (succ zero))].

schema ctx = nat;

rec odd_even : [ ⊢ odd N] → [ ⊢ even (succ N)] = fn d ⇒ case d of
  | [ ⊢ od_sz] ⇒ ? % solve [ ⊢ ev_s ev_z]
  | [ ⊢ od_s D] ⇒ let [ ⊢ F] = odd_even [ ⊢ D] in ?  % solve [ ⊢ ev_s F]  -- msolve-auto
;



%
--mquery  1 * * {g:ctx}{N:[g |- nat]}{D : [g |- even N]} [g |- even (succ (succ N))].

--mquery  1 * * {g:ctx}{N:[ |- nat]} {D : [g |- even N[]]} [g |- even (succ (succ N[]))].

node:type.
a:node.
b:node.
c:node.
d:node.
     
edge:node -> node -> type.
e_ab: edge a b.
e_bc: edge b c.
e_ad: edge a d.
e_cd: edge c d.

reach: node -> node -> type.
r_edge: edge A B -> reach A B.
r_reach: reach B C -> edge A B -> reach A C.
% NOTE: the order of subgoals depends on how the implication is written.
%       in this example our 1. subgoal will be edge A B and our 2. subgoal reach B C.
%       This is important, when we use depth first search

--mquery 2 * * [ |- reach a d].
% succeeds, finding the first solution, but in fact there are 2 expected solutions.

--mquery 2 * * [ |- reach a d].
% finds the correct 2 solutions

--mquery 2 * * {N:[ |- node]}{E: [ |- edge N a]}[ |- reach N d].

% To be tested with bounded depth-first search when we introduce some cycles in the graph


tree: type.
leaf: tree.
node: nat → tree → tree → tree.

rec plus : [ ⊢ nat] → [ |- nat] → [ ⊢ nat] = fn x ⇒ fn y ⇒ case x of
  | [ ⊢ zero] ⇒ ?
  | [ ⊢ succ N] ⇒ ? ;

rec size : [ ⊢ tree] → [ ⊢ nat] = fn t ⇒ case t of
      | [ |- leaf] ⇒ [ ⊢ zero]
      | [ ⊢ node D L R] ⇒ let [ ⊢ N1] = size [ ⊢ L] in
			  let [ ⊢ N2] = size [ ⊢ R] in
			  plus ? (plus [ ⊢ N1] ?)
;
