%{ 
  CH 3:  Untyped arithmetic expressions
  Author: Brigitte Pientka

  EVALUATION RULES AND META-THEORY

}%

% Small-step operational semantics
step: term -> term -> type.

e_switch_true:  
   step (switch true T2 T3)    T2.

e_switch_false:
   step (switch false T2 T3)   T3.

e_switch:
   step T1 T1'
-> step (switch T1 T2 T3)      (switch T1' T2 T3).


% Example:

let t : (step (switch (switch true false false)
                      true 
                      true)
              (switch false true true)) [ ]
= [ ] e_switch e_switch_true ;

let d : (step (switch (switch (switch true false false)
                               true 
                               true)
                       false 
                       false) 
        
              (switch (switch false true true)
	              false
                      false)) [ ]
= [ ] e_switch (e_switch e_switch_true) ;


% Values
value: term -> type.

v_true : value true.
v_false: value false.


equal: term -> term -> type.
ref: equal T T.

%{
Determinacy of evaluation:

Theorem: if step T T1 and step T T2 then equal T1 T2.

}%

steps_to_terms: term -> term -> term -> type.
andalso: step T T1 -> step T T2 -> steps_to_terms T T1 T2.


rec det : (steps_to_terms T T1 T2)[ ] -> (equal T1 T2)[ ] =
fn s => case s of 
| [ ] andalso (e_switch_true)  (e_switch_true)  =>  [ ] ref
| [ ] andalso (e_switch_false) (e_switch_false) =>  [ ] ref
| [ ] andalso (e_switch D)     (e_switch E)     =>
  let [ ] ref        = det ([ ] andalso D E) in 
    [ ] ref
;



% Normal form = values
%{ 
 Multi-step evaluation rules 
}%
mstep: term -> term -> type.

m_step : step M N' -> mstep N' N
     -> mstep M N.   

m_ref  : mstep M M.   % Reflexive



%{ Values evaluate to themselves

 Lemma: if value N and mstep N M then  equal N M.

}%
rec lemma_val : (value N)[ ] -> (mstep N M)[ ] -> (equal M N)[ ] =
fn v => fn s => case v of 
| [ ] v_true => 
    let [ ] m_ref  = s in 
      [ ] ref

| [ ] v_false => 
    let  [ ] m_ref = s in
      [ ] ref
;


%{
Theorem: Uniqueness of evaluation

If mstep M N  and mstep M N'  then equal N N'.

}%

msteps_to_terms: term -> term -> term -> type.
andalso': mstep M M1 -> mstep M M2 -> msteps_to_terms M M1 M2.

rec unique : (msteps_to_terms M N1 N2)[ ] 
             -> (value N1)[ ] -> (value N2)[ ] 				      
	     -> (equal N1 N2)[ ] =
fn ms => fn vn1 => fn vn2 => case ms of 
| [ ] andalso' (m_step S1 MS1) (m_ref) => 
  let [ ] V2 = vn2 in 
    lemma_val ([ ] V2) ([ ] m_step S1 MS1)

| [ ] andalso' (m_step S1 MS1) (m_step S2 MS2) => 
  let [ ] ref = det ([ ] andalso S1 S2) in
    unique ([ ] andalso' MS1 MS2) vn1 vn2

| [ ] andalso' (m_ref )       (m_ref )   => 
   [ ] ref

;


%{
 Correctness of algorithmic small-step semantics 
}%

multi_step: term -> term -> type.

ms_tr: multi_step M N' -> multi_step N' N
      -> multi_step M N.

ms_ref: multi_step M M.

ms_step: step M N
	 -> multi_step M N.


%{
Admissibility of transitivity for mstep:
}%

rec m_trans : (mstep M N')[ ] -> (mstep N' N)[ ] -> (mstep M N)[ ] = 
fn ms1 => fn ms2 => case ms1 of 
| [ ] m_ref  => ms2 
| [ ] m_step  S1 MS1 => 
  let [ ] MS1' = m_trans ([ ] MS1) ms2 in 
    [ ] m_step S1 MS1'
;


rec sound : (mstep M N)[ ] -> (multi_step M N)[ ] = 
fn ms => case ms of 
| [ ] m_ref => [ ] ms_ref
| [ ] m_step S MS => 
  let [ ] MS' = sound ([ ] MS) in 
    [ ] ms_tr (ms_step S) MS'
;


rec complete : (multi_step M N)[ ] -> (mstep M N)[ ] =
fn ms =>  case ms of 
| [ ] ms_ref => 
    [ ] m_ref 
| [ ] ms_tr MS1 MS2 => 
  let [ ] MS2' = complete ([ ] MS2) in 
  let [ ] MS1' = complete ([ ] MS1) in 
   m_trans ([ ] MS1') ([ ] MS2')

| [ ] ms_step S => 
  [ ] m_step S m_ref
;



