tp: type.   %name tp T.
bool: tp.
nat: tp.
arrow: tp -> tp -> tp. #infix arrow 1 left.

term : tp -> type.  %name term E x. #postfix term 2.

z    : term nat. 
s    : term nat -> term nat. #postfix s 2.

lam  : (term T -> term T') -> term (T arrow T'). 
app  : term (T arrow T') -> term T -> term T'. #infix app 1.


schema tctx = some [t:tp] t term;
% schema W = nat term;

% total ([g] [g |- M ..])  (copy [g] [g |- M ..] ).

rec copy : {g:tctx} [g |- (T ..) term] -> [g |- (T ..) term] =
mlam g => fn e => case e of

| [g |- z]      => [g |- z]

| [g |- (E ..) s] =>
  let [g |- (F ..)] = copy [g] [g |- (E .. )] in
     [g |- (F ..) s]

| [g |- #p .. ]   => [g |- #p ..]

| [g |- lam  (\x. (U .. x))] =>
  let [g,x :  _ term  |-  V .. x] = copy [g, x:_ term ] [g,x  |-  U .. x]  in
    [g |- lam  (\x. (V .. x))]

| [g |- (E1 ..) app (E2 ..)] =>
  let [g |- F1 .. ] = copy [g] [g |- E1 ..] in
  let [g |- F2 .. ] = copy [g] [g |- E2 ..] in
    [g |- (F1 ..) app (F2 ..)]

;


let t = copy [ ] [ |- z] ;
let t = copy [x:term nat ] [x:term nat  |-  x];
let t = copy [x:term _ ] [x : term nat |-  x s];
%{ let t : (term (nat arrow nat))[ ] =
     copy [ ] ([ ] lam \x. x);
 let t : (term ((bool arrow nat) arrow (bool arrow nat)))[ ]
     = copy [ ] ([ ] lam \x. (lam \y. x app y));
 let t = copy [y:term (((bool arrow nat) arrow (bool arrow nat)) arrow nat)] ([y] app y (lam \x. (lam \y. x app y)));
 let t = copy [y:term nat,x:term bool] ([x,y] x s);
}%
