<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Session (beluga.Harpoon.Session)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Harpoon</a> &#x00BB; Session</nav><header class="odoc-preamble"><h1>Module <code><span>Harpoon.Session</span></code></h1></header><div class="odoc-content"><p>A Harpoon session represents a set of mutually proven theorems.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Disambiguation_state"><a href="#module-Disambiguation_state" class="anchor"></a><code><span><span class="keyword">module</span> Disambiguation_state</span><span> =
  <a href="../../Beluga_parser/Disambiguation_state/Disambiguation_state/index.html">Beluga_parser.Disambiguation_state.Disambiguation_state</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Indexing_state"><a href="#module-Indexing_state" class="anchor"></a><code><span><span class="keyword">module</span> Indexing_state</span><span> = <a href="../../Beluga/Index_state/Indexing_state/index.html">Beluga.Index_state.Indexing_state</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><a href="../../Beluga_parser/Disambiguation_state/Disambiguation_state/index.html#type-state">Disambiguation_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Beluga/Index_state/Indexing_state/index.html#type-state">Indexing_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Syncom/Id/index.html#type-cid_mutual_group">Beluga_syntax.Syncom.Id.cid_mutual_group</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Theorem/index.html#type-t">Theorem.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Construct a new session representing the given mutual group.</p><p>Requirement: the mutual group identified by the given cid must indeed contain every given theorem.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_disambiguation_state"><a href="#val-with_disambiguation_state" class="anchor"></a><code><span><span class="keyword">val</span> with_disambiguation_state : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../Beluga_parser/Disambiguation_state/Disambiguation_state/index.html#type-state">Disambiguation_state.state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_indexing_state"><a href="#val-with_indexing_state" class="anchor"></a><code><span><span class="keyword">val</span> with_indexing_state : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../Beluga/Index_state/Indexing_state/index.html#type-state">Indexing_state.state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_mutual_decs"><a href="#val-get_mutual_decs" class="anchor"></a><code><span><span class="keyword">val</span> get_mutual_decs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/Comp/index.html#type-total_dec">Synint.Comp.total_dec</a> list</span></span></code></div><div class="spec-doc"><p>Retrieves the mutual declarations associated to this session's mutual group.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lookup_theorem"><a href="#val-lookup_theorem" class="anchor"></a><code><span><span class="keyword">val</span> lookup_theorem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Syncom.Name.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Theorem/index.html#type-t">Theorem.t</a> option</span></span></code></div><div class="spec-doc"><p>Looks up an incomplete theorem by name in the session.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-full_theorem_list"><a href="#val-full_theorem_list" class="anchor"></a><code><span><span class="keyword">val</span> full_theorem_list : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Theorem/index.html#type-t">Theorem.t</a> list</span></span></code></div><div class="spec-doc"><p>Gets the list of all complete and incomplete theorems in this session.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mark_current_theorem_as_proven"><a href="#val-mark_current_theorem_as_proven" class="anchor"></a><code><span><span class="keyword">val</span> mark_current_theorem_as_proven : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../Synint/Comp/index.html#type-exp">Synint.Comp.exp</a> option</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Moves the current theorem from the incomplete theorem stack to the finished theorem stack, and associates it to the given checkable term that is its translation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-defer_theorem"><a href="#val-defer_theorem" class="anchor"></a><code><span><span class="keyword">val</span> defer_theorem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Moves the current theorem to the bottom of the incomplete theorem stack, selecting the next one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-next_theorem"><a href="#val-next_theorem" class="anchor"></a><code><span><span class="keyword">val</span> next_theorem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Theorem/index.html#type-t">Theorem.t</a> option</span></span></code></div><div class="spec-doc"><p>Gets the currently focused theorem, if any. This returns None when all theorems in the session are complete.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-infer_invocation_kind"><a href="#val-infer_invocation_kind" class="anchor"></a><code><span><span class="keyword">val</span> infer_invocation_kind : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/Comp/index.html#type-exp">Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/Comp/index.html#type-invoke_kind">Synint.Comp.invoke_kind</a></span></code></div><div class="spec-doc"><p>Decides what kind of invocation the given synthesizable expression represents. The implementation is quite naive about detecting recursive calls, and will only find one in an application head position.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select_theorem"><a href="#val-select_theorem" class="anchor"></a><code><span><span class="keyword">val</span> select_theorem : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Syncom.Name.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Selects a given theorem by name in the session, moving it to the top of the incomplete theorem stack. Returns whether the selection succeeded. Selection fails only when there is no incomplete theorem by the given name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_session_kind"><a href="#val-get_session_kind" class="anchor"></a><code><span><span class="keyword">val</span> get_session_kind : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `introduced <span>| `loaded</span> ]</span></span></code></div><div class="spec-doc"><p>Decides what kind of session this is. `introduced: this session was created within Harpoon, via the session configuration wizard. `loaded: this session was recovered from a signature.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-translation_check_result"><a href="#type-translation_check_result" class="anchor"></a><code><span><span class="keyword">type</span> translation_check_result</span><span> = </span><span>[ </span></code><ol><li id="type-translation_check_result.some_translations_failed" class="def constructor anchored"><a href="#type-translation_check_result.some_translations_failed" class="anchor"></a><code><span>| </span></code><code><span>`some_translations_failed</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Returned when some theorems could not be translated. The user should already have seen an error indicating the failure.</p><span class="comment-delim">*)</span></div></li><li id="type-translation_check_result.check_error" class="def constructor anchored"><a href="#type-translation_check_result.check_error" class="anchor"></a><code><span>| </span></code><code><span>`check_error <span class="keyword">of</span> exn</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Returned when a translated theorem fails to typecheck.</p><span class="comment-delim">*)</span></div></li><li id="type-translation_check_result.ok" class="def constructor anchored"><a href="#type-translation_check_result.ok" class="anchor"></a><code><span>| </span></code><code><span>`ok</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Returned on successful typechecking.</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>Represents the result of trying to typecheck the translated proofs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_translated_proofs"><a href="#val-check_translated_proofs" class="anchor"></a><code><span><span class="keyword">val</span> check_translated_proofs : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-translation_check_result">translation_check_result</a></span></code></div><div class="spec-doc"><p>Typechecks all translated proofs in the session. Proofs are translated as soon as they are completed, and they are recorded inside the session. Once all proofs are completed, this function should be called to verify that the translation was correct. In principle, any proof that successfully completes should pass translation, and any translated proof should pass typechecking, so it is never a user-error if translation fails or if typechecking a translated proof fails.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-configuration_wizard"><a href="#val-configuration_wizard" class="anchor"></a><code><span><span class="keyword">val</span> configuration_wizard : 
  <span><a href="../../Beluga_parser/Disambiguation_state/Disambiguation_state/index.html#type-state">Disambiguation_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Beluga/Index_state/Indexing_state/index.html#type-state">Indexing_state.state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Io/index.html#type-t">Io.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="../Theorem/index.html#type-t">Theorem.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Theorem/index.html#type-subgoal_hook">Theorem.subgoal_hook</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p>Performs a series of prompts to interactively construct a new session. Returns None if the user aborts the session configuration. Otherwise, returns the newly defined session.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fmt_ppr_theorem_list"><a href="#val-fmt_ppr_theorem_list" class="anchor"></a><code><span><span class="keyword">val</span> fmt_ppr_theorem_list : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prints a vertical, enumerated list of all theorems in this session.</p></div></div></div></body></html>
