% Sketch of weak normalization for STLC that goes under binders
% Author: Andrew Cave

tp : type.                %name tp T.
i :  tp.
arr: tp -> tp -> tp.

tm : tp -> type.          %name tm E.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).

schema ctx = tm T;

mstep : tm A -> tm A -> type.  %name mstep S.
beta : mstep (app (lam M) N) (M N).
eta : {M:tm (arr A B)} mstep M (lam (\x. app M x)).
steplam : ({x:tm A} mstep (M x) (M' x)) -> mstep (lam M) (lam M').
stepapp : mstep M M' -> mstep N N' -> mstep (app M N) (app M' N').
refl : mstep M M.
trans : mstep M M' -> mstep M' M'' -> mstep M M''.

datatype IsVarSub : {g:ctx}  {h:ctx} {#S: g[h]}ctype =
| Nil : IsVarSub [] [h] <h $ ^ >
| Cons : {A:[g.tp]}{#S:g[h]}{#p:[h. tm (A #S[..])]} IsVarSub [g] [h] <h $ #S[..] >
         -> IsVarSub [g,x:tm (A ..)] [h] <h $ #S[..] (#p ..)  >
;


% This could be defined at the LF layer, but then it would require a bigger schema, and I don't want to deal with that
% TODO: Hmm, couldn't we use a block x:tm A , neut x schema all the way through? lam even adds the assumption that neut x?
datatype IsNormal : {g:ctx} {A:[g.tp]} {M:[g.tm (A ..)]} ctype =
| Neut : IsNeutral [g] [g. i] [g. M ..] -> IsNormal [g] [g.i] [g. M ..]
| Lam : IsNormal [g,x:tm (A ..)] [g,x. B ..] [g,x:tm (A ..). M .. x]
     -> IsNormal [g] [g.arr (A ..) (B ..)] [g. lam (\x. M .. x)]
and IsNeutral : {g:ctx} {A:[g.tp]} {M:[g.tm (A ..)]} ctype =
| Var : {#p:[g.tm (A ..)]} IsNeutral [g] [g.A ..] [g. #p ..]
| App : IsNeutral [g] [g.arr (A ..) (B ..)] [g. M ..]
     -> IsNormal [g] [g.A ..] [g. N ..]
     -> IsNeutral [g] [g.B ..] [g. app (M ..) (N ..)]
;

datatype Halts : {g:ctx}{A:[g.tp]} {M:[g. tm (A ..)]} ctype =
| Halts : [g. mstep (M ..) (V ..)] -> IsNormal [g] [g. A ..] [g. V .. ] ->
          Halts [g] [g. A ..] [g. M ..]
;

datatype Reduce : {g:ctx} {A:[g.tp]} {M:[g.tm (A ..)]} ctype =
| Base : Halts [g] [g. i] [g. M ..] -> Reduce [g] [g . i] [g. M ..]
| Arr :  {h0:ctx}{A:[h0.tp]}{B:[h0.tp]}{M:[h0.tm (arr (A ..) (B ..))]}
         ({h:ctx} {#R:h0[h]} {N:[h. tm (A #R[..])]}
          IsVarSub [h0] [h] <h $ #R[..] > ->
          Reduce [h] [h. A #R[..] ] [h. N ..] -> Reduce [h] [h. B #R[..] ] [h. app (M #R[..]) (N ..)])
           -> Reduce [h0] [h0. arr (A ..) (B ..)] [h0. M ..]
;

rec wknVarSub : {g:ctx}{h:ctx}{#S:g[h]}{A:[h. tp]} IsVarSub [g] [h] <h $ #S[..] >
 -> IsVarSub [g] [h,x:tm (A ..)] <h,x:tm (A ..) $ #S[..] > =
mlam g => mlam h => mlam #S => mlam A => fn r =>
?
%case r of
%| Nil => Nil
% TODO: There's a case not implemented yet in pruneSubst where the head is a PVar
%| {A:[g.tp]}{#S:g[h]}{#p:[h. tm (A #S[..])]}
%  Cons [g. A ..] <h $ #S[..] > [h . #p ..] r =>
%  ? % Make a recursive call, etc
;

rec idIsVarSub : {g:ctx} IsVarSub [g] [g] <g $ .. > =
mlam g => case [g. i] of % Because we can't pattern match directly on contexts yet
| [. i] => Nil
| {A:[g. tp]}
  [g,x:tm (A ..). i] =>
    let iv = idIsVarSub [g] in
    Cons [g. A ..] [g,x:tm (A ..) $ ..] [g,x:tm (A ..). x] (wknVarSub [g] [g] [g $ ..] [g. A ..] iv)
;

% TODO: Can we rewrite our definitions slightly so we don't need these? (Use Pis instead of ->s?)
rec mstepTrans : (g:ctx){M:[g.tm A]} [g. mstep (M ..) (M' ..)] -> [g. mstep (M' ..) (M'' ..)] -> [g. mstep (M ..) (M'' ..)] =
mlam M => fn s => fn s' => let [g. S ..] = s in let [g. S' ..] = s' in [g. trans (S ..) (S' ..)]
;

rec mstepAppL : (g:ctx){M1:[g.tm (arr A B)]} [g. mstep (M1 ..) (M2 ..)] -> [g. mstep (app (M1 ..) (N ..)) (app (M2 ..) (N ..))] =
mlam M => fn s => let [g. S ..] = s in [g. stepapp (S ..) refl]
;

rec haltsMstep : (g:ctx) [g. mstep (M ..) (M' ..)] -> Halts [g] [g. A ..] [g. M' ..] -> Halts [g] [g. A ..] [g. M ..] =
fn ms => fn h => let (h : Halts [g] [g. A ..] [g. M' ..]) = h in
let Halts ms' v = h in Halts (mstepTrans [g. _] ms ms') v
;


%rec closed2 : Reduce [g] [g.A ..] [g. M' ..] -> {S:[g. mstep (M ..) (M' ..)]} Reduce [g] [g.A ..] [g. M ..] =
%fn r => mlam S => let (r : Reduce [g] [g.A ..] [g. M' ..]) = r in  case r of
%| Base ha => ? %Base (haltsMstep2 [g. S ..] ha)
%| Arr [g] [g. A ..] [g. B ..] [g. M ..] f => Arr [g] [g. A ..] [g. B ..] [g. _]
%  (mlam h => mlam #W => mlam N => fn iv => fn rn =>
%     closed2 (f [h] [h $ #W[..]] [h. N ..] iv rn) [h. stepapp (S #W[..]) refl])
%
%;

% CR2
rec closed : Reduce [g] [g.A ..] [g. M' ..] -> [g. mstep (M ..) (M' ..)] -> Reduce [g] [g.A ..] [g. M ..] =
fn r => fn s => let (r : Reduce [g] [g.A ..] [g. M' ..]) = r in  case r of
| Base ha => Base (haltsMstep s ha)
| Arr [g] [g. A ..] [g. B ..] [g. M ..] f => Arr [g] [g. A ..] [g. B ..] [g. _]
  (mlam h => mlam #W => mlam N => fn iv => fn rn =>
    ?%  closed (f [h] [h $ #W[..]] [g. N ..] iv rn) (mstepAppL [g. _] s)
   )

;

datatype RedSub : {g:ctx}{h:ctx}{#S:g[h]} ctype =
| Nil : {h:ctx} RedSub [] [h] <h $ ^ >
| Dot : {g:ctx}{h:ctx}{A:[g. tp]}{#S:g[h]}{M:[h.tm (A #S[..])]} % !!!!
        RedSub [g] [h] <h $ #S[..] > -> Reduce [h] [h. A #S[..] ] [h. M ..]
         -> RedSub [g,x:tm (A ..)] [h] <h $ #S[..] (M ..) >
;

rec wknRedSub : {g:ctx}{h:ctx}{h':ctx}{#S:g[h]}{#W:h[h']}
    RedSub [g] [h] <h $ #S[..] >
 -> IsVarSub [h] [h'] <h' $ #W[..] >
 -> RedSub [g] [h'] <h' $ #S[#W[..]] > =
?
;

rec redVar : {g:ctx}{h:ctx}{T:[g.tp]}{#S:g[h]}{#p:[g.tm (T ..)]} RedSub [g] [h] <h $ #S[..]>
              ->  Reduce [h] [h. T #S[..]] [h. #p #S[..] ] =
mlam g => mlam h => mlam T => mlam #S => mlam #p => fn rs =>
case [g. #p ..] of
 | {A:[g'. tp]} [g',x:tm (A ..). x] =>
    (case rs of
     | {#R:g'[h]}{A:[g'.tp]}{N:[h. tm (A #R[..])]}
       Dot [g'] [h] [g'. A ..] <h $ #R[..] > [h . N .. ] rs' rN => rN)
 | {#q : [g'. tm (T ..)]} [g',x:tm (A ..). #q ..] =>
    let  {#R:g'[h]}{A:[g'.tp]}{N:[h. tm (A #R[..])]}
        Dot [g'] [h] [g'. A ..] <h $ #R[..] > [h . N .. ] rs' rN = rs in
     redVar [g'] [h] [g'. T ..] [h $ #R[..] ] [g'. #q ..] rs'
;


rec eval : {g:ctx}{h:ctx}{A:[g.tp]}{M:[g.tm (A ..)]}{#S:g[h]}
    RedSub [g] [h] <h $ #S[..] >
 -> Reduce [h] [h. A #S[..] ] [h. M #S[..] ] =
mlam g => mlam h => mlam A => mlam M => mlam #S => fn rs => 
 case [g. M ..] of
| {T:[g'.tp]}{#p:[g'. tm (T ..)]}
  [g'. #p ..] => redVar [g'] [h] [g'.T ..] [h $ #S[..] ] [g'. #p ..] rs
| {T:[g'.tp]}{T2:[g'.tp]}{M1: [g'.tm (arr (T2 ..) (T ..))]}{M2:[g'.tm (T2 ..)]}
  [g'. app (M1 ..) (M2 ..)]  =>
  let rN : Reduce [h] [h.A' ..] [h.N2 ..] =
      eval [g'] [h] [g'. T2 ..] [g'. M2 ..] [h $ #S[..] ] rs in
  let Arr [h0] [h0.S2 ..] [h0.S1 ..] [h0.N1 ..] f =
    eval [g'] [h] [g'. arr (T2 ..) (T ..)] [g'. M1 ..] [h $ #S[..] ] rs in
   f [h] [h $ .. ] [h.N2 ..] (idIsVarSub [h]) rN

| {T2:[g'.tp]}{T:[g'.tp]}{M1:[g',y:tm (T2 ..). tm (T ..)]}
  [g'. lam (\x. M1 .. x)] => 
  Arr [h] [h. T2 #S[..] ] [h. T #S[..] ] [h. lam (\x. M1 #S[..] x)]
  (mlam h' => mlam #W => mlam N => fn isVS => fn rN =>
   closed
     (eval [g',x:tm (T2 ..)] [h'] [g',x. T ..] [g',x. M1 .. x] [h' $ #S[#W[..]] (N ..)]
        (Dot [g'] [h'] [g'. T2 ..] [h' $ #S[#W[..]] ] [h'. N ..]
           (wknRedSub [g'] [h] [h'] [h $ #S[..]] [h' $ #W[..]] rs isVS)
           rN)
     )
     [h'. beta]
  )
%   mlam h' => mlam F => mlam N => fn wkn-f-m => fn rn => eval [g,x:tm _. M1 .. x] (Cons (all-wkn wkn-f-m rs) rn)
;
