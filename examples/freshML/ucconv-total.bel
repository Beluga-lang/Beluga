% Untyped closure conversion.
% Author: Olivier Savary B.
%

% term is the source language
term: type.
elam:(term -> term) -> term.
eapp:term -> term -> term.
elet:term -> (term -> term) -> term.

% targer is the target language
target:type.
tunit: target. % used as nil to list with pairs
tfst: target -> target.
tsnd: target -> target.
tpair: target -> target -> target.
tapp: target -> target -> target. % app is wrapped in topen
tlam: (target -> target) -> target. % lam is wrapped in tpack
tlet: target -> (target -> target) -> target.
tpack: target -> target.
topen: target -> (target -> target) -> target.

nat: type.
z:nat.
suc: nat -> nat.

% list of term
fvlist: type.
nil:fvlist.
cons: term -> fvlist -> fvlist.

schema ctx = term;
schema tctx = target;

datatype Fvs: {g:ctx} ctype = 
| Nil : Fvs [g]
| Cons: {#p:[g |- term]} Fvs [g] -> Fvs [g];


rec append: Fvs [g] -> Fvs [g] -> Fvs [g] = 
/ total l (append g l) /  
fn a => fn b => case a of 
| Nil => b
| Cons [g |- #p..] l => Cons [g |- #p..] (append l b)
;

rec remove: Fvs [g,x:term] -> Fvs [g] =
/ total l (remove g l)/
fn l => case l of
| Nil  => Nil
| Cons [g,x:term |- x] l => remove l
| Cons [g,x:term |- #p ..] l =>
    Cons [g |- #p ..] (remove l)
;


rec fvar:(g:ctx) [g |- term] -> Fvs [g] =
/ total e (fvar g e)/
fn e => case e of
| [g |- (#p ..)] => Cons [g |- #p ..] Nil
| [g |- elam \x.U .. x] =>
   remove (fvar [g,x:term |- U .. x])
| [g |- eapp (U..) (V..)] =>
    append (fvar [g |- U ..]) (fvar [g |- V ..])
|[g |- elet (U..) (\x.(V..x))] =>
 let l = remove (fvar [g,x:term |-  V .. x])  in
   append (fvar [g |- U ..]) l
;



% makeproj return the nth project of pair y
% makeproj n = tfst( ... (tfst y))
rec makeproj': [ |- nat]  -> [xenv:target |-  target] =
/ total n (makeproj' n ) / 
fn n => case n of
| [ |- z] => [xenv:target |-  (tfst xenv)]
| [ |- suc M] =>
  let [xenv:target |- N xenv] = makeproj' [ |- M] in
      [xenv:target |- tsnd (N xenv)]
;

rec makeproj: [ |- nat] -> [xenv:target |- target] =
/ total n (makeproj n) /  
fn n =>
   let [xenv:target |-  T xenv] = makeproj' n in
       [xenv:target |-  tfst (T xenv)]

;

 % Build a map from the free var to its position in fvlist , used in abs conversion(started with id from x -> x).
 % Resulting should be a term closed under the environement tuple xenv and the local variable x.

rec b_map:(g:ctx)Fvs [g] ->({#p:[g,x:term |- term]} [xenv:target |-  target]) -> [ |- nat] ->
	  {#p:[g,x:term |- term]}[xenv:target |-  target] =
/ total l (b_map g l )/  
fn l => fn map => fn n => case l of
| Nil => 
  let ( l : Fvs [g]) = l in
    (mlam #p => case [g,x:term |- #p ..]  of
	       |[g,x:term |- x]     => [xenv:target |- tsnd xenv]
	       |[g,x:term |- #p ..] => map [g,x:term |-  #p..]
	    )
| Cons [g |- #p ..] l =>
let [ |- N] = n in
 (mlam #q => case ([g,x:term |- #q .. x], [g,x:term |- #p ..]) of 
                | ([g,x:term |- #v .. x], [g,x:term |- #v .. x]) => makeproj [ |- N]
                | ([g,x:term |- _ ] , [g,x:term |- _ ] ) => 
                 b_map l map [ |- suc N] [g,x:term |- #q .. x])

;


% Extend the mapping with id function, used for the local variable in lam and let.
rec e_map : {g:ctx}{h:tctx} ({#p:[g |- term]} [h |- target])  ->  {#q:[g,x:term |-  term]} [h,x:target |-  target] =
/ total e' (e_map g h map e') /
mlam g, h => fn map => mlam #q => case [g,x:term |- #q ..] of
   | [g,x:term |-  x] => [h,x:target |-  x]
   | [g,x:term |-  #q ..] =>
     let [h |- F ..] = map [g |- #q..] in
    	 [h,x:target |- F ..]
;


% Build the environement tuble xenv that will be packed next to a lam. Map should contain the idmapping from x:term to x:target at this stage.
rec b_env:(g:ctx){h:tctx}({#p:[g |- term]} [h |- target]) -> Fvs [g] -> [h |- target] =
/ total fvar (b_env g h map fvar)/
mlam h => fn map => fn fvar => case fvar of
| Nil => [h |- tunit]
| Cons [g |- #p ..] l =>
  let [h |- Ta' ..] = b_env [h] map l in
  let [h |- E'  ..] = map [g |- #p ..] in
  [h |- tpair (E' ..) (Ta' ..)]
;


%
% outer conversion
%
rec convert:(g:ctx){h:tctx} ({#p:[g |- term]} [h |- target]) -> [g |- term] -> [h |- target] =
mlam h => fn map => fn e => case e of
| [g |- #p..] => map [g |- #p..]
| [g |- eapp (U ..) (V ..)] =>
  let [h |- U' ..] = convert [h] map [g |- U ..] in
  let [h |- V' ..] = convert [h] map [g |- V ..] in
  [h |- topen (U' ..)
      \xenv .  tapp (tfst xenv) (tpair (tsnd xenv) (V' ..))]

|[g |- elam \x.U .. x] =>
 let fvs = fvar e in
 let [xenv:target |- U' xenv] =
     convert [xenv:target]
	     (b_map fvs (mlam #p => [xenv:target |- tunit]) [ |- z])
	     [g,x:term |-  U .. x] in
let [h |- T2 ..] = b_env [h] map fvs in
  [h |- tpack (tpair (tlam \xenv. U' xenv) (T2 ..))]

|[g |- elet (U..) (\x. V .. x)] =>
 let [h |- U' ..] = convert [h] map [g |- U ..] in
 let [h,x:target |- V' .. x] = convert [h,x:target] (e_map [g] [h] map) [g,x:term |- V .. x] in
 [h |- tlet (U' ..) (\x.V' .. x)]
;


let t1 = convert [ ] (mlam #p => [ |- tunit]) [ |- elam (\x.(x))];
let t2 = convert [ ] (mlam #p => [ |- tunit]) [ |- elet (elam (\y.y)) (\x.x)];
let t3 = convert [ ] (mlam #p => [ |- tunit]) [ |- elam (\x.(elam (\y. eapp x y)))];


