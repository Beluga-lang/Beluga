% Author: Brigitte Pientka
%
nat: type.
z: nat.
s: nat -> nat.

% Types
tp  : type.                %name tp T.
o   : tp.
arr : tp -> tp -> tp.


% Intrinsically well-typed expressions
exp   : tp -> type.        %name exp E.
value : tp -> type.
app   : exp (arr A B) -> exp A -> exp B.
lam   : {A:tp}(value A -> exp B) -> value (arr A B).
ret   : value A -> exp A.

% Translating to untyped deBruijn terms

exp'   : tp -> type.

one    : exp' A.
shift  : exp' A -> exp' A.  % ^
lam'   : {A:tp}exp' B  -> exp' (arr A B).
app'   : exp' (arr A B) -> exp' A -> exp' B.

schema ctx = value T ;

rec var2db : {g:ctx}{#p:[g. value S]}  [.exp' S] = / total g (var2db g _ ) /
mlam g => mlam #p => case [g.#p ..] of
| [h,x:value T. x] => [. one]

 | % {#p:[h. value S']} This is necessary in the absence of subordination, since we need S' to be closed.
 [h,x:value T. #p ..]  =>
 let [. Db] = var2db [h] [h. #p ..] in
 [. shift Db]
;

rec vhoas2db : (g:ctx) [g. value S]  -> [. exp' S] = / total v (vhoas2db _ _ v) /
fn v =>  case v of
  | [g. #p ..] => var2db [g] [g.#p ..]
  | [g. lam T (\x. E .. x)] =>
   let [. F]  =  hoas2db [g,x:value T. E .. x] in
     [. lam' T F]

and hoas2db : (g:ctx) [g. exp T] ->  [. exp' T] = / total e (hoas2db _ _ e) /
  fn e =>  case e of
  | [g. app (E1 .. ) (E2 .. )] =>
   let [. F1] = hoas2db [g. E1 ..]  in
   let [. F2] = hoas2db [g. E2 ..]  in
   [. app' F1 F2]
 | [g. ret (V ..)] =>
     vhoas2db [g. V ..]
;


