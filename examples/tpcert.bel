tp   : type.
nat  : tp.
bool : tp.
arr  : tp -> tp -> tp.

term : type.
z    : term.
tt   : term.
ff   : term.
suc  : term -> term.
eq   : term -> term -> term.
if_then_else : term -> term -> term -> term.
letv : term -> (term -> term) -> term.
lam  : tp -> (term -> term) -> term.


oft  : term -> tp -> type.
o_tt : oft tt bool.
o_ff : oft ff bool.
o_z  : oft z nat.
o_s  : oft E nat -> oft (suc E) nat.
o_if : oft E bool -> oft E1 T -> oft E2 T
    -> oft (if_then_else E E1 E2) T.

o_lam: ({x:term} oft x T1 -> oft (E x) T2)
       -> oft (lam T1 (\x. E x)) (arr T1 T2).
o_let: oft E1 T1 -> ({x:term} oft x T1 -> oft (E2 x) T2)
    -> oft (letv E1 (\x. E2 x)) T2.

cert: term -> type.

certify : cert E 
       <- oft E T.

certify' : {T:tp}cert E 
       <- oft E T.

schema tpCtx = some [t:tp] block x:term. oft x t;

rec infer : {g:(tpCtx)*} {U::term[g]} (cert (U ..))[g] =
  FN g => mlam U =>
   case [g] U .. of
     [g] z     => [g] certify o_z

   | [g] tt    => [g] certify o_tt

   | [g] #p.1 ..  => [g] certify (#p.2 ..)

 | [g] lam (T ..) \x. E .. x => 
    (case infer [g, b: block x:term. oft x (T ..)] <g, b. E .. b.1> of   
     {T2::tp[]} {T::tp[]}
     {D::(oft (E .. b.1) T2)[g, b: block x:term. oft x T]}
      [g, b: block x:term. oft x T] certify (D .. b)
      => [g] certify (o_lam \x.\u. D .. <x, u>)
    )

%{ | [g] letv (E1 ..) (\x. (E2 .. x)) => 
     let [g] certify (D1 ..) = infer [g] <g. E1 ..>  in 
     let [g, b: block x:term. oft x (S1 ..)] certify (D2 .. b) = 
             % We don't know the type of E1 so we can't give it in the next line,
             %  but writing _ leaves a free variable
	     % This is fixed in the version below by making T explicit in the definition of certify.
             infer [g, b: block x:term. oft x _ ] <g, b. E2 .. b.1> in 
         [g]  certify o_let (D1 ..) (\x.\u. D2 .. <x, u>)
}%
;


rec infer' : {g:(tpCtx)*} {U::term[g]} (cert (U ..))[g] =
  FN g => mlam U =>
   case [g] U .. of
 | [g] z     => [g] certify' nat o_z

 | [g] tt    => [g] certify' bool o_tt

 | [g] #p.1 ..  => [g] certify' _   (#p.2 ..)

 | [g] lam T \x. E .. x => 
   let [g, b: block x:term. oft x T1] certify' T2 (D .. b) = 
         infer' [g, b: block x:term. oft x T] <g, b. E .. b.1> 
   in
   	 [g] certify' (arr T1 T2) (o_lam \x.\u. D .. <x, u>)

 | [g] letv (E1 ..) (\x. (E2 .. x)) => 
     let [g] certify' T1 (D1 ..) = infer' [g] <g. E1 ..>  in 
     let [g, b: block x:term. oft x (S1 ..)] certify' T2 (D2 .. b) = 
             infer' [g, b: block x:term. oft x T1 ] <g, b. E2 .. b.1> in 
         [g]  certify' T2 (o_let (D1 ..) (\x.\u. D2 .. <x, u>))

;
