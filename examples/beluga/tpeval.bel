% Type-preserving environment based
% interpreter
%
% Author: Brigitte Pientka

tp   : type.
nat  : tp.
bool : tp.

exp  : tp -> type.

tt   : exp bool.
ff   : exp bool.

z    : exp nat.
suc  : exp nat -> exp nat.
eq   : exp nat -> exp nat -> exp bool.

if   : {T:tp} exp bool -> exp T -> exp T -> exp T.
letv : {T1:tp} {T2:tp} exp T1 -> (exp T1 -> exp T2) -> exp T2.

% schema W = some [T:tp] block exp t;

% rec eval : {g:(W)*} {T::tp[]} (exp T[.])[g] -> [g][] -> (exp T[.])[] =
% FN g => fn e => fn r => let sbox S[.] = r in
%     case e of 
%         box(g. z) : (exp nat)[g] => box( . z)
%       | {U::(exp nat)[g]} box(g. suc U[id(g)]) : (exp nat)[g] => 
%         let 
%             box( . V[.]) = eval [g] < . nat> box(g. U[id(g)]) r
%         in
%             box( . suc V[.])
%         end
%       | {T::tp[.]} {p::(exp T[.])[g]} box(g. p[id(g)]) : (exp T[.])[g] =>
%         box( . p[S[.]])
%       | {U::(exp nat)[g]}{V::(exp nat)[g]} box(g. eq U[id(g)] V[id(g)]) : (exp bool)[g] => 
%         let 
%             box( . W1[.]) = eval [g] < . nat> box(g. U[id(g)]) r
%             box( . W2[.]) = eval [g] < . nat> box(g. V[id(g)]) r
%         in
%             if boxeq( . W1[.], W2[.]) then box( . tt) else box( . ff)
%         end
%       | {T1::tp[.]}{T2::tp[.]}{W::(exp T1[.])[g]}{U::(exp T2[.])[g]}
%         box(g . letv T1[.] T2[.] W[id(g)] (\x. U[id(g), x])) : (exp T2[.])[g] => 
%             let 
%                 box V[.] = eval [g] < . T1[.]> (box g.W[id(g)]) r
%             in 
%                 eval [g,x:exp T1[.]]  < . T2[.]> box(g,x. U[id(g),x]) (sbox S[.], V[.])
%             end;
