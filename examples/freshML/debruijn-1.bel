% Author: Brigitte Pientka
%
nat: type.
z: nat.
s: nat -> nat.

% Types
tp  : type.                %name tp T.
o   : tp.
arr : tp -> tp -> tp.          


% Intrinsically well-typed expressions
exp   : tp -> type.        %name exp E.
value : tp -> type.
app   : exp (arr A B) -> exp A -> exp B.
lam   : {A:tp}(value A -> exp B) -> value (arr A B).
ret   : value A -> exp A.

% Translating to untyped deBruijn terms 

exp'   : tp -> type.  

one    : exp' A.
shift  : exp' A -> exp' A.  % ^
lam'   : {A:tp}exp' B  -> exp' (arr A B).
app'   : exp' (arr A B) -> exp' A -> exp' B.

schema ctx = value T + tp;
schema tctx = tp;

rec vhoas2db : {g:ctx} (value S)[g]  -> (exp' S)[ ] = 
fn v =>  case v of 
 | [h,x:value T] x => [ ] one 
 | {#p::(value S')[h]} % This is necessary in the absence of subordination, since we need S' to be closed.
   [h,x:value T] #p ..  => 
   let [ ] Db = vhoas2db ([h] #p ..) in 
     [ ] shift Db
 | [g] lam T (\x. E .. x) => 
   let [ ] F  =  hoas2db ([g,x:value T ] E .. x ) in 
     [ ] lam' T F

and hoas2db : {g:ctx} (exp T)[g] ->  (exp' T)[ ] = 
fn e =>  case e of 
 | [g] app (E1 .. ) (E2 .. ) =>
   let [ ] F1 = hoas2db ([g] E1 ..)  in 
   let [ ] F2 = hoas2db ([g] E2 ..)  in 
     [ ] app' F1 F2
 | [g] ret (V ..) => 
   vhoas2db ([g] V .. )   
;


rec db2vhoas : {g:ctx} (exp' T)[g] -> (value T)[g] = 
fn e => case e of 
| [h,x:value T] one : (exp' T)[h,x:value T] => 
    [h,x:value T] x

| {E::(exp' S)[ ]}
   [h,x:value T] shift E => 
  let [h] F .. = db2vhoas ([h] E)  in 
    [h,x:value T] F ..

| [h] lam' T E => 
    let [g,x:value T] F .. x = db2hoas  ([h, x:value T] E) in 
      [g] lam T (\x. F .. x)

 and db2hoas : {g:ctx} (exp' T)[g] -> (exp T)[g] = 
 fn e => case e of 
 | [g] app' E1 E2 =>
   let [g] F1 .. = db2hoas ([g] E1 )  in 
   let [g] F2 .. = db2hoas ([g] E2 ) in 
     [g] app (F1 ..) (F2 ..)

;


rec tohoas : (exp' T)[ ] -> (exp T)[ ] = 
fn e => db2hoas e ;


