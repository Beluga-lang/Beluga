nat: type.
z : nat.
s : nat -> nat.

tp : type.
un : tp.
 
schema w = block x:nat. nat;
schema tps = tp;

rec f : {g:(w)*} nat[g] -> nat[g] =
  FN g => fn e =>
    case e of
{#p::(block x:nat. nat)[g]}
      [g] #p.1 .. => [g] #p.2 ..
;

rec ffff : {g:(w)*} {h:(tps)*} nat[g] -> tp[h] -> nat[g] =
  FN g => FN h => fn eNat => fn eTp =>
%    case eTp of
    case eNat of
      [g] #p.1 .. => [g] z %[g] #p.1 ..
%      [h] #p.1 .. => [g] z %[g] #p.1 ..
;
