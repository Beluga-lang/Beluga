% Untyped closure conversion in beluga. 
%current states:
%b_map gives context clash
%convert is a stub
%
%
%By O. Savary, 260340147


%term is the source language
term: type.
elam:(term -> term) -> term. 
eapp:term -> term -> term.
elet:term -> (term -> term) -> term.

%targer is the target language
target:type.
tunit: target. %used as nil to list with pairs
tfst: target -> target.
tsnd: target -> target.
tpair: target -> target -> target.
tapp: target -> target -> target.
tlam: (target -> target) -> target.
tlet: target -> (target -> target) -> target.


nat: type.
z:nat.
suc: nat -> nat.

%list of term
fvlist: type.
nil:fvlist.
cons: term -> fvlist -> fvlist.

schema ctx = term;
schema tctx = target;

rec append:{g:ctx}fvlist[g] -> fvlist [g] -> fvlist [g] =
    fn a => fn b => case a of
         [g]nil => b
         |[g]cons (E..) (Ta..) => let [g](B'..) = append ([g]Ta..) b in
                                   [g]cons (E..) (B'..)
;

rec makeproj: nat [] -> target[y:target] =
fn n => case n of
	 []z => [y:target] tfst y
       |[]suc M => let [y:target]N = makeproj ([]M) in
		     [y:target] tsnd N
;

rec remove:{g:ctx}fvlist[g,x:term] -> fvlist[g] =
fn l => case l of
	 [g,x:term]nil => [g]nil
       |[g,x:term]cons x (L..x) => remove([g,x:term]L..x)
       |[g,x:term]cons (#p..) (L..x) => 
	  let [g] (L'..) = remove ([g,x:term]L..x) in
				  [g]cons (#p..) (L'..)
;

%Extend the mapping with id function
rec e_map:{g:ctx}{h:(tctx)*} (term [g] -> target[h])  ->  (term[g,x:term] -> target[h,x:target]) = 
 FN h => fn map => 
	     fn e' => case e' of
		       |[g,x:term] x => [h,x:target] x
		       |[g,x:term](#p..) => let [h](F..) = map([g]#p..) in 
					 [h,x:target](F..)
;

%Build a map from the free var x to its position in fvlist
rec b_map:{g:ctx}{h:tctx} (term [g] -> target [x:target]) -> fvlist[g] -> nat[] -> (term [g] -> target [x:target]) =
    fn map => fn l => fn n => case l of
			     [g] nil => map
			   |[g]cons (X..) (L..) =>
			      let []N = n in
			      (fn e => if ([g]X..) == e then
					  makeproj ([]N)
				      else 
				      	   b_map map ([g]L..) ([]suc N) e
			      )
;
					 


%Apply mapping to the free variable list(similar to built) 
rec b_env:{g:ctx}{h:(tctx)*} (term [g] -> target [h]) -> fvlist[g] -> target[h] =
  FN h => fn map => fn fvar => case fvar of
                [g]nil => [h]tunit
               |[g]cons (E..) (Ta..) => let [h](E'..) = map ([g]E..) in
                                let [h](Ta'..) = b_env [h] map ([g]Ta..) in
                               [h]tpair (E'..) (Ta'..)

;


rec fvar:{g:ctx} term[g] -> fvlist[g] =
 fn e => case e of
     [g] (#p ..) => [g]cons (#p ..) nil
    |[g] elam (\x.(U..x)) => let [g,x:term](L..x) = fvar ([g,x:term] (U..x)) in
			   let [g](L'..) = remove([g,x:term] L..x) in
                           [g] (L'..)
                           
   |[g] eapp (U..) (V..) => let [g](FVU..) = fvar ([g]U..) in
			 let [g](FVV..) = fvar ([g]V..) in
                          append ([g]FVU..) ([g]FVV..)
   |[g] elet (U..) (\x.(V..x)) => let [g](FVU..) = fvar ([g]U..) in
                               let [g,x:term](FVV..) = fvar ([g,x:term]V..x) in
			       let [g](FVV'..) = remove([g,x:term]FVV..) in
                                  append ([g]FVU..) ([g]FVV'..)
;

%outer conversion
%? -> Wrap app in tlet
%  -> Keep 2-lam, 3-arg app or 1-lam with pair
rec convert:{g:ctx}{h:(tctx)*} (term [g] -> target [h]) -> term [g] -> target [h] = 
    FN h => fn map => fn e => case e of
		    [g]#p.. => map ([g]#p..)
		    |[g]eapp (U..) (V..) => let [h](U'..) = convert [h] map ([g]U..) in
			     	   	    let [h](V'..) = convert [h] map ([g]V..) in
			   [h] tapp (tfst (U'..)) (tpair (tsnd (U'..)) (V'..))
			   %[h] tlet ...?
		  |[g]elam (\x.(U..x)) => 
		  	   	       	let [h,x:target] U'..x = convert  [h,x:target] (e_map [h] map) ([g,x:term]U..x) in 
					let [g](FV..) = fvar e in
					let [h](T2..) = b_env [h] map ([g]FV..) in
					[h]tpair (tlam (\x.(U'..x))) (T2..)
		  |[g]elet (U..) (\x.(V..x)) => let [h](U'..) = convert [h] map ([g]U..) in
					     let [h,x:target] V'..x = convert [h,x:target] (e_map [h] map) ([g,x:term]V..x) in
					     [h] tlet (U'..) (\x.(V'..x))
; 

 
let t3 = convert [ ] (fn e => ([ ] tunit)) ( [ ] elam (\x.(elam (\y. eapp x y))));
