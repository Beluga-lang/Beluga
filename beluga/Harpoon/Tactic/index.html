<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tactic (beluga.Harpoon.Tactic)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Harpoon</a> &#x00BB; Tactic</nav><header class="odoc-preamble"><h1>Module <code><span>Harpoon.Tactic</span></code></h1><p>All the high-level proof tactics. * In general, a tactic has inputs * 1. Some tactic-specific parameters * 2. A `proof_state` to act on * * Tactics are parameterized by a TacticContext that gives them * certain capabilities, such as manipulating the subgoal list or * showing messages to the user. * * Tactics are not obligated to solve the current subgoal!</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Command"><a href="#module-Command" class="anchor"></a><code><span><span class="keyword">module</span> Command</span><span> = <a href="../../Synext/Harpoon/index.html">Beluga_syntax.Ext.Harpoon</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Total"><a href="#module-Total" class="anchor"></a><code><span><span class="keyword">module</span> Total</span><span> = <a href="../../Beluga/Total/index.html">Beluga.Total</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="../Theorem/index.html#type-t">Theorem.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/Comp/index.html#type-proof_state">Beluga_syntax.Synint.Comp.proof_state</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Tactics operate on an incomplete proof in a tactic context. They may choose to solve the goal by removing it or add new subgoals, or both.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-solve"><a href="#val-solve" class="anchor"></a><code><span><span class="keyword">val</span> solve : <span><span class="optlabel">?action_name</span>:string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/Comp/index.html#type-proof">Beluga_syntax.Synint.Comp.proof</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Solves the subgoal with the given proof.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intros"><a href="#val-intros" class="anchor"></a><code><span><span class="keyword">val</span> intros : <span><span><span>string list</span> option</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Introduces the arguments to a function type, with the given names, if any.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-intros'_failure"><a href="#type-intros'_failure" class="anchor"></a><code><span><span class="keyword">type</span> intros'_failure</span><span> = </span></code><ol><li id="type-intros'_failure.DuplicateName" class="def variant constructor anchored"><a href="#type-intros'_failure.DuplicateName" class="anchor"></a><code><span>| </span><span><span class="constructor">DuplicateName</span> <span class="keyword">of</span> <a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../Synint/Comp/index.html#type-ctyp_decl">Beluga_syntax.Synint.Comp.ctyp_decl</a></span></code></li><li id="type-intros'_failure.NothingToIntro" class="def variant constructor anchored"><a href="#type-intros'_failure.NothingToIntro" class="anchor"></a><code><span>| </span><span><span class="constructor">NothingToIntro</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intros'"><a href="#val-intros'" class="anchor"></a><code><span><span class="keyword">val</span> intros' : 
  <span><a href="../Theorem/index.html#type-t">Theorem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>string list</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Syncom.Name.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-intros'_failure">intros'_failure</a>,
    <a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
    * <a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
    * <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>)</span>
    <a href="../../Support/Either/index.html#type-t">Support.Either.t</a></span></span></code></div><div class="spec-doc"><p>Introduces the arguments to a function type, with the given names, if any.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : 
  <span><span>[ `split <span>| `invert</span> <span>| `impossible</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Synint.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Performs a case analysis on the given synthesizable expression of the given type. The split_kind is used to perform an additional check on the split, regarding the number of branches. In particular, this is used to implement variants of splitting, e.g. inversion and impossible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unbox"><a href="#val-unbox" class="anchor"></a><code><span><span class="keyword">val</span> unbox : 
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Syncom.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-unbox_modifier">Beluga_syntax.Synint.Comp.unbox_modifier</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Performs unboxing of the given synthesizable expression of the given type. The tactic will itself verify that the type is a box-type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-invoke"><a href="#val-invoke" class="anchor"></a><code><span><span class="keyword">val</span> invoke : 
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Syncom.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>It is verified that the given expression is an application. The result of the invocation is assigned to the variable of the given name, in cG, in case the given boxity is (the default) `boxed. Otherwise, with `unboxed, the name is a new variable declaration in cD.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-suffices"><a href="#val-suffices" class="anchor"></a><code><span><span class="keyword">val</span> suffices : 
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-suffices_typ">Beluga_syntax.Synint.Comp.suffices_typ</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Solves the current goal with an implication whose conclusion is compatible with the goal type. Subgoals are generated for each premise of the implication.</p><p>The user needs to decide upfront what the types of all the premises are, and these given types must unify with the corresponding premise types. Furthermore, this unification must pin down all universally quantified variables, as there is no way to construct them using Harpoon. (Harpoon can only construct computational objects, not LF objects.)</p><p>Another restriction is that *all* universally quantified variables must appear at the beginning. That is, the type `tau` must be of the form</p><p>tau = Pi X_1:U_1. ... Pi X_n:U_n. tau_1 -&gt; ... -&gt; tau_k -&gt; tau'</p><p>(This is most common form of type for a Beluga function.)</p><p>Subject to the following requirements:</p><ul><li>cD; cG |- i ==&gt; tau</li><li>tau' unifies with the current goal type.</li><li>each tau_i unifies with the corresponding type in the args list.</li></ul><p>After all these unifications, there must be no remaining universally quantified variables. (Such a type would be very strange, so this requirement is quite weak.)</p><p>The concrete syntax of this command piggybacks off the syntax of `by` is</p><p>by &lt;lemma/ih&gt; i suffices tau_1, ..., tau_k</p></div></div></div></body></html>
