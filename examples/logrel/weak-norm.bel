```
# Weak head normalization for simply-typed lambda calculus
```

tp : type.    %name tp T.        
b :  tp.
arr : tp -> tp -> tp.

tm : tp -> type.          %name tm E.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).
c : tm i.

schema ctx = tm T;

step : tm A → tm A → type.
beta : step (app (lam M) N) (M N).
stepapp : step M M' -> step (app M N) (app M' N).

mstep : tm A -> tm A -> type.  %name mstep S.
refl : mstep M M.
onestep : step M M' -> mstep M' M'' -> mstep M M''.

val : tm A -> type. %name val V.
val/c : val c.
val/lam : val (lam M).

halts : tm A -> type.  %name halts H.
halts/m : mstep M M' -> val M' -> halts M.

```
## Reducibility

```

datatype Reduce : {M:[ |- tm A]} ctype =
| I : [ |- halts M] -> Reduce [ |- M]
| Arr :  [ |- halts M] ->
    ({N:[ |- tm A]} Reduce [ |- N] -> Reduce  [ |- app M N])
  -> Reduce  [ |- M]
;

rec halts_step : {S:[ |- step M M']} [ |- halts M'] -> [ |- halts M] =
mlam S ⇒ fn h =>
 let [ |- halts/m MS' V] = h in
 [ |- halts/m (onestep S MS') V]
;

rec bwd_closed : {S:[ |- step M M']} Reduce [ |- M'] -> Reduce [ |- M] =
mlam MS => fn r => case r of
| I ha => I (halts_step [ |- MS] ha)
| Arr ha f => Arr (halts_step [ |- MS] ha)
  (mlam N => fn rn =>
   bwd_closed [ |- stepapp MS] (f [ |- N] rn))
;

rec reduce_halts : Reduce [ |- M] -> [ |- halts M] =
fn r => case r of
| I h => h
| Arr h f => h
;

```
Reducibility of substitutions
```

datatype RedSub : {g:ctx}{#S: |- g} ctype =
| Nil : RedSub  [ ] [ |- ^ ]
| Dot : RedSub  [g] [ |- #S[^] ] → Reduce [ |- M]
     → RedSub [g, x:tm A] [ |- #S[^] M ] 
;

rec lookup : {g:ctx}{#p:[g |- tm A]}RedSub [g] [ |- #S[^]] -> Reduce [ |- #p #S[^]] =
mlam g => mlam #p => fn rs => case [g |- #p ..] of
 | [g',x:tm A |-  x] =>    let (Dot rs' rN) = rs in rN
 | [g',x:tm A |-  #q ..] => let Dot rs' rN = rs in
                      lookup [g'] [g' |-  #q ..] rs'
;

```
Main theorem:
```

rec main : {g:ctx}{M:[g |- tm A]} RedSub [g] [ |- #S[^]] -> Reduce  [ |- M #S[^]] =
 mlam g => mlam M => fn rs => case [g |- M ..] of
| [g |- #p ..] => lookup [g] [g |- #p ..] rs
| [g |- lam (\x. M1 .. x)] =>
 Arr [ |- halts/m refl val/lam]
   (mlam N => fn rN =>
    bwd_closed [ |- beta] (main [g,x:tm _] [g,x |- M1 .. x] (Dot rs rN)))
 | [g |- app (M1 ..) (M2 ..)] =>
  let Arr ha f = main [g] [g |- M1 ..] rs in
  f [ |- _ ] (main [g] [g |- M2 ..] rs)
| [g' |-  c] => I [ |- halts/m refl val/c]
;

rec weakNorm : {M:[ |- tm A]} [ |- halts M] =
mlam M => reduce_halts (main [] [ |- M] Nil)
;
