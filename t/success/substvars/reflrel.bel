tm: type.
app: tm -> tm -> tm.
lam: (tm -> tm) -> tm.

aeq: tm -> tm -> type.
ae_l: ({x:tm} aeq x x -> aeq (M x) (N x))
          -> aeq (lam (\x. M x)) (lam (\x. N x)).
ae_a: aeq M1 N1 -> aeq M2 N2 -> aeq (app M1 M2) (app N1 N2).

schema xG = tm;
schema xaG = block x:tm, u:aeq x x;

datatype CtxRel : {phi:xG} {psi: xaG} {#S:phi[psi]} ctype =
| Empty : CtxRel [] [] < $ ^ >
| Dot   : {phi:xG}{psi:xaG}{#S:phi[psi]}
              CtxRel [phi] [psi] <psi $ #S[..] >
           -> CtxRel [phi, x:tm] [psi, b: block (x:tm,u:aeq x x)] < psi, b $ #S[..] b.1 >
;
%{ Works but cannot write the program for it because we lack
   Meta^2-SVars
datatype CtxRel : {phi:xG} {psi: xaG} {#S:phi[psi]} ctype =
| Empty : CtxRel [] [] < $ ^ >
| Dot   :   CtxRel [phi] [psi] <psi $ #S[..] >
          -> CtxRel [phi, x:tm] [psi, b: block (x:tm,u:aeq x x)] < psi, b $ #S[..] b.1 >
;


rec refl : CtxRel [phi] [psi] < psi $ #S[..] > -> {M: [phi . tm]}
          [psi . aeq (M #S[..]) (M #S[..])] = ? ;
}%
rec refl : {phi:xG}{psi:xaG}{#S:phi[psi]}{M: [phi . tm]} CtxRel [phi] [psi] < psi $ #S[..] > ->
          [psi . aeq (M #S[..]) (M #S[..])] =
mlam phi => mlam psi => mlam #S => mlam M => fn cr => case [phi . M ..] of
%{ | [phi, x:tm . x] =>
  let {phi:xG}{psi:xaG}{#S:phi[psi]}
      Dot [phi] [psi] < psi $ #S[..] > cr' = cr in [psi, b: block (x:tm, u:aeq x x) . b.2]}
}%
| [phi, x:tm . #p ..] =>
  let % {phi:xG}{psi:xaG}{#S:phi[psi]}
      Dot [phi] [psi] < psi $ #R[..] > cr' = cr in
  refl [phi] [psi] [psi $ #R[..] ] [phi. #p ..] cr'

| [phi . app (M .. ) (N ..)] => ?

%{| [phi . app (M .. ) (N ..)] =>
  let [psi. D1 .. ] = refl [phi] [psi] [ psi $ #S[..] ] [phi.M ..] cr in
  let [psi. D2 .. ] = refl [phi] [psi] [ psi $ #S[..] ] [phi.N ..] cr in
    [psi. ae_a (D1 ..) (D2 ..) ]
}%


%{| [phi . lam \x.M .. x] =>
  let % {#S:phi[psi]}{M:[phi, x:tm. tm]}
      % {D:[psi, x:tm, u:aeq x x. aeq (M #S[^2] x) (M #S[^2] x)]}
      [psi, b:block (x:tm, u:aeq x x). D .. b.1 b.2] =
      % [psi, b . aeq (M #S[..] b.1) (M #S[..] b.1) ]
      refl [phi, x:tm] [psi, b:block (x:tm, u:aeq x x)]
           [psi, b $ #S[..] b.1 ] [phi,x:tm. M .. x]
           (Dot [phi] [psi] [ psi $ #S[..] ] cr)  % : CtxRel [phi,x:tm] [psi, b:block (x:tm, u:aeq x x)] < psi $ #S[..] b.1 >
 in ?

%  [psi. ae_l \x.\u. D .. x u]
                          % Inferred: D:[psi, x:tm, u:aeq x x. aeq (M #S[^2] x) (M #S[^2] x)]

                          % Inferred: :[psi. aeq (lam \x. M #S[^1] x) (lam \x.M #S[^1] x)]

                          % Expected:   [psi . aeq #S[..](lam \x. M .. x)   #S[..](lam \x.M .. x)
                          %          =  [psi . aeq (lam \x. M #S[^1] x) (lam \x.M #S[^1] x)
}%
 ;
