<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parser_combinator (beluga.Beluga_parser.Parser_combinator)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Beluga_parser</a> &#x00BB; Parser_combinator</nav><header class="odoc-preamble"><h1>Module <code><span>Beluga_parser.Parser_combinator</span></code></h1><p>General purpose parser combinator library.</p><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Jacob Thomas Errington</li></ul><ul class="at-tags"><li class="author"><span class="at-tag">author</span> Marc-Antoine Ouimet</li></ul></header><nav class="odoc-toc"><ul><li><a href="#introduction-to-parser-combinators">Introduction to Parser Combinators</a><ul><li><a href="#backtracking">Backtracking</a></li><li><a href="#language-design-considerations">Language Design Considerations</a></li></ul></li><li><a href="#parser-state">Parser State</a><ul><li><a href="#constructors">Constructors</a></li></ul></li><li><a href="#parsers">Parsers</a><ul><li><a href="#constructors_2">Constructors</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="introduction-to-parser-combinators"><a href="#introduction-to-parser-combinators" class="anchor"></a>Introduction to Parser Combinators</h2><p>This is a hand-made parser combinator system, inspired by Haskell's <a href="https://hackage.haskell.org/package/parsec">parsec library</a>. The basic idea in parser combinators is to use higher-order functions to manipulate <i>parsing functions</i> to build up more complex parsers. The most basic type we can give for a parsing function would be something like:</p><pre class="language-ocaml"><code>type 'a parser = char list -&gt; char list * 'a option</code></pre><p><code>char list</code> represents the input stream. We must return a new stream, perhaps with some characters removed since we parsed them. The result of the parse is parametric. Since parsing may fail, we use a type constructor to represent this, namely <code>option</code>.</p><p>However this design has many shortcomings.</p><ol><li>Representing the input as a <code>char list</code> requires the entire input to be buffered in memory. This is wasteful. Instead, we should progressively read input as we need it. Therefore in our implementation we use a lazily-evaluated persistent sequence.</li><li>Using <code>option</code> to represent failure doesn't give us a means to specify what the error is. Instead we use <code>('a, exn) result</code> in order to also return some information in case of failure.</li><li>Finally, in order to control backtracking and other parsing features, we will need to not only pass around and transform the <i>input</i>, but a more general <i>parser state</i>.</li></ol><p>So our parsing function type now looks like:</p><pre class="language-ocaml"><code>type 'a parser = state -&gt; state * ('a, exn) result</code></pre><p>where <code>state</code> contains a <code>Located_token.t Seq.t</code> for the input as well as extra stuff for handling backtracking. This is an instance of the state monad as defined in <a href="../../Support/State/module-type-STATE/index.html"><code>Support.State.STATE</code></a>.</p><h3 id="backtracking"><a href="#backtracking" class="anchor"></a>Backtracking</h3><p>The naive implementation of the <code>alt</code> alternation combinator is to say that <code>alt p1 p2</code> first runs <code>p1</code>, and if it fails, runs <code>p2</code>. This implementation has the major drawback of allowing <i>unlimited</i> backtracking. This is undesirable because it results in terrible error messages. What we would like is a way to control the backtracking behaviour of parsers on a more fine-grained level.</p><p>Instead, the library below is non-backtracking, so it introduces the <code>trying</code> combinator to selectively enable backtracking. <code>trying p</code> runs <code>p</code>, and if <code>p</code> fails having even consumed input, then <code>trying p</code> can still be backtracked out of. The <code>alt</code> combinator is implemented like this:</p><ul><li>Run <code>p1</code>. If it succeeds, return its result without trying <code>p2</code>.</li><li>If <code>p1</code> failed without consuming any input, then run <code>p2</code>.</li><li>If <code>p1</code> failed under a <code>trying</code>, then run <code>p2</code>.</li><li>Otherwise, the error generated by <code>p1</code> was fatal, so return it.</li></ul><p>The rationale for this is that it allows the parser writer to commit to a parse tree once certain conditions have been met. For example, in Beluga, after a <code>case</code> keyword, we know for sure that we're parsing a case expression. Therefore, if we fail afterwards to parse the scrutinee of the case (a synthesizable expression), we should not backtrack out of the parser for case expressions.</p><h3 id="language-design-considerations"><a href="#language-design-considerations" class="anchor"></a>Language Design Considerations</h3><p>This parser combinator library is only suited for top-down data-independent parsing. That is, tokens are parsed sequentially from left to right, and no auxiliary data is accumulated during parsing. This means that left-recursive grammars and data-dependent grammars are not supported without either rewriting the grammar, or disambiguating and rewriting parsed ASTs at a later stage.</p><p>It is best to implement a parser with a pre-defined context-free grammar in a language specification document. This grammar may need rewriting to eliminate left recursion, assign precedences and associativities using recursive descent parsing.</p><h2 id="parser-state"><a href="#parser-state" class="anchor"></a>Parser State</h2><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-PARSER_STATE"><a href="#module-type-PARSER_STATE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PARSER_STATE/index.html">PARSER_STATE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Abstract parser state definition.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-LOCATED"><a href="#module-type-LOCATED" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LOCATED/index.html">LOCATED</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module type definition for elements having location annotations.</p></div></div><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Make_persistent_state"><a href="#module-Make_persistent_state" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make_persistent_state/index.html">Make_persistent_state</a></span><span> (<a href="Make_persistent_state/argument-1-Token/index.html">Token</a> : <a href="module-type-LOCATED/index.html">LOCATED</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Functor creating an instance of <a href="module-type-PARSER_STATE/index.html"><code>PARSER_STATE</code></a> backed by an immutable data structure.</p></div></div><h2 id="parsers"><a href="#parsers" class="anchor"></a>Parsers</h2><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-PARSER"><a href="#module-type-PARSER" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PARSER/index.html">PARSER</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h3 id="constructors_2"><a href="#constructors_2" class="anchor"></a>Constructors</h3><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span>
  (<a href="Make/argument-1-State/index.html">State</a> : <a href="module-type-PARSER_STATE/index.html">PARSER_STATE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-PARSER_STATE/index.html#type-location">location</a> = <a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a></span>) : 
  <a href="module-type-PARSER/index.html">PARSER</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-PARSER/index.html#type-state">state</a> = <a href="Make/argument-1-State/index.html#type-state">State.state</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-PARSER/index.html#type-token">token</a> = <a href="Make/argument-1-State/index.html#type-token">State.token</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <a href="module-type-PARSER/index.html#type-location">location</a> = <a href="Make/argument-1-State/index.html#type-location">State.location</a></span></span></code></div></div></div></body></html>
