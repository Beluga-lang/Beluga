term :  type.
z    : term.
suc  : term -> term.
app  : term -> term -> term.    

schema termCtx = some [] term;

rec copy : {g:(termCtx)*} term[g] -> term[g] =
FN g => fn e =>
 (case e of
  | [g]  z     => [g] z
  | [g] suc (U ..) => let [g] V .. = copy [g] ([g] U ..) in [g] suc (V .. )
  | [g] #p .. => [g] #p ..
  | [g] app (U ..) (V ..)  => 
    let [g] U' ..  = copy [g] ([g] U ..) in 
    let [g] V' ..  = copy [g] ([g] V ..) in 
       [g] app (U' ..) (V' ..)
);


rec copyBroken : {g:(termCtx)*} term[g] -> term[g] =
FN g => fn e =>
 (case e of %not
  | [g]  z     => [g] z
  | [g] suc (U ..) => let [g] V .. = copy [g] ([g] U ..) in [g] suc (V .. )
  | [g] #p .. => [g] #p ..
  | [g] app (U ..) (U ..)  =>  [g] z   % Doesn't cover because only matches app U U, not app U V
);
