%{
  CH 6:  Lambda-terms
  Author: Brigitte Pientka

  SYNTAX
}%

term: type.

lam: (term -> term) -> term.
app: term -> term -> term.


value:  term -> type.
v_lam: value (lam M).


% ---------------------------------------------------------- %
% Small-step operational semantics

step: term -> term -> type.

step_app_1    : step (app E1 E2) (app E1' E2)
                 <- step E1 E1'.
step_app_2    : step (app E1 E2) (app E1 E2')
                 <- value E1
                 <- step E2 E2'.

step_app_beta : step (app (lam (\x. E x)) E2) (E E2)
                 <- value E2.


equal : term -> term -> type.
refl: equal E E .

not_possible : type.

rec values_dont_step : [ |- step M M' ] -> [ |- value M  ] -> [ |- not_possible]=
fn s => fn v => case v of
| [ |- v_lam] => impossible s in []
;

steps_to_terms: term -> term -> term -> type.
andalso: step T T1 -> step T T2 -> steps_to_terms T T1 T2.

rec det : [ |- steps_to_terms T T1 T2 ] -> [ |- equal T1 T2 ] =
fn s => case s of
| [ |- andalso (step_app_1 DstepE1') (step_app_1 DstepE1'')] =>
  let [ |- refl] = det [ |- andalso DstepE1' DstepE1''] in
    [ |- refl]

| [ |- andalso (step_app_2 DstepE2' _ ) (step_app_2 DstepE2'' _)] =>
  let [ |- refl] = det [ |- andalso DstepE2' DstepE2'' ] in
  [ |- refl]

| [ |- andalso (step_app_beta _ ) (step_app_beta _ )] =>  [ |- refl]

%{ Note: impossible cases cannot be proven directly to be impossible, since we only look ahead one step to see whether a contextual type is empty. However, see file small-step-2.bel where we use computation-level pairs, we can circumvent this problem and omit these cases while still retaining coverage.
}%
| [ |- andalso (step_app_1 DstepE1') (step_app_2 DstepE2' V)] =>
  impossible values_dont_step [ |- DstepE1'] [ |- V] in [ ]

| [ |- andalso (step_app_2 DstepE2' V) (step_app_1 DstepE1')]  =>
  impossible values_dont_step [ |- DstepE1'] [ |- V] in [ ]

| [ |- andalso (step_app_1 DstepE1') (step_app_beta _ )] =>
  impossible values_dont_step [ |- DstepE1'] [ |- v_lam ] in [ ]

| [ |- andalso (step_app_beta _ ) (step_app_1 DstepE1')] =>
  impossible values_dont_step [ |- DstepE1'] [ |- v_lam ] in [ ]

| [ |- andalso (step_app_2 DstepE2' V) (step_app_beta V2 )] =>
  impossible values_dont_step [ |- DstepE2'] [ |- V2] in [ ]

| [ |- andalso (step_app_beta V2 ) (step_app_2 DstepE2' _)] =>
  impossible values_dont_step [ |- DstepE2'] [ |- V2] in [ ]

;
