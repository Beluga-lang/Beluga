<html>
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		body {
			padding: 2em 1em 2em 1em;
			margin: 0;
			font-family: sans-serif;
			color: black;
			background: white;}
		a{text-decoration:none;}
		a:link { color: #00C; background: transparent }
		a:visited { color: #00C; background: transparent }
		a:active { color: #C00; background: transparent }
		keyword { color: #3333cc ; background: transparent }
		p {display: inline;}
		pre {
			border: 1px dashed maroon;  display:block;
			padding:8px; background-color: #dddddd;}
		code {
			background-color: #dddddd;
			color: black; font-family: "courier";margin:0;
			white-space: pre-wrap; }
		.typ {color: #660000; font-weight:bold}
		.constructor {color: #335C85; font-weight:bold}
		.function {color: #660033; font-weight:bold}
		.schema {color: #6600CC; font-weight:bold}
	</style>
</head>
<body>

<p></p><p>
<h1> Algorithmic Equality for the Polymorphic Lambda-calculus (G-version)</h1>
This case-study is a mechanization of <a href="https://github.com/pientka/ORBI/blob/master/benchmarks/EqualPoly.orbi" target="_blank">EqualPoly.orbi</a>. We examine Theorems 11, 18, & 19 and Lemma 18 from <a href="orbi-jar.pdf" target="_blank">(Felty et al, 2014)</a>, proving each by the <i>generalized context</i> (G) approach.<br></p>
<p><ul>
<ul><li><b>Theorem 11(Admissibility of Reflexivity for Types):</b> If <code>g &#8866; is_tp A</code> then <code>g &#8866; atp A A</code>.<br></li>
<li><b>Theorem 13 (Admissibility of Reflexivity for Terms):</b> If <code>g &#8866; is_tm M</code> then <code>g &#8866; aeq M M</code>.<br></li>
<li><b>Lemma 18 (G-Promotion for Reflexivity, Symmetry, and Transitivity):</b></li></ul>
<ol><br>
<ul><li>If <code>g:atpCtx</code> and <code>g &#8866; is_tm M</code> then <code>g &#8866; aeq M M</code>.<br></li>
<li>If <code>g:atpCtx</code> and <code>g &#8866; aeq M L</code> and <code>g &#8866; aeq L N</code> then <code>g &#8866; aeq M N</code>.<br></li>
<li>If <code>g:atpCtx</code> and <code>g &#8866; aeq M N</code> then <code>g &#8866; aeq N M</code>.<br></li></ul>
</ol>
<ul><li><b>Theorem 19 (Completeness):</b> If <code>g:dtpCtx</code> and <code>g &#8866; deq M N</code> then <code>g &#8866; aeq M N</code>.</li></ul>
</ul></p>
<p><h2> Syntax</h2>
The polymorphic lambda-calculus is introduced with the following declarations: </p><br><pre><code><span class="typ" id="tp">tp</span> : <keyword>type</keyword>.
<br><keyword>%name</keyword> tp T a
<br><span class="constructor" id="arr">arr</span> : <a href="#tp">tp</a> &#x2192 <a href="#tp">tp</a> &#x2192 <a href="#tp">tp</a>.
<br><span class="constructor" id="all">all</span> : (<a href="#tp">tp</a> &#x2192 <a href="#tp">tp</a>) &#x2192 <a href="#tp">tp</a>.
<br><span class="typ" id="term">term</span> : <keyword>type</keyword>.
<br><keyword>%name</keyword> term M x
<br><span class="constructor" id="app">app</span> : <a href="#term">term</a> &#x2192 <a href="#term">term</a> &#x2192 <a href="#term">term</a>.
<br><span class="constructor" id="lam">lam</span> : (<a href="#term">term</a> &#x2192 <a href="#term">term</a>) &#x2192 <a href="#term">term</a>.
<br><span class="constructor" id="tlam">tlam</span> : (<a href="#tp">tp</a> &#x2192 <a href="#term">term</a>) &#x2192 <a href="#term">term</a>.
<br><span class="constructor" id="tapp">tapp</span> : <a href="#term">term</a> &#x2192 <a href="#tp">tp</a> &#x2192 <a href="#term">term</a>.
</code></pre>
<p>Note that we extend the untyped syntax with constructors for type abstraction <code>tlam</code>, type application <code>tapp</code>, and existential quantification over types <code>all</code>.</p>
<p><h2> Judgements and Rules</h2>
We describe algorithmic and declarative equality for the polymorphic lambda-calculus as judgements using axioms and inference rules. The Beluga code is a straightforward HOAS encoding of the associated rules.</p>
<p><h3> Algorithmic Equality for types</h3>
We of course cannot define a term equality judgement only in our Untyped Equality case studies. We add the judgement for type equality, <code>atp A B</code></p><br><pre><code><span class="typ" id="atp">atp</span> : <a href="#tp">tp</a> &#x2192 <a href="#tp">tp</a> &#x2192 <keyword>type</keyword>.
<br><keyword>%name</keyword> atp Q u
<br><span class="constructor" id="at_al">at_al</span> : {a : <a href="#tp">tp</a>} <a href="#atp">atp</a> a a &#x2192 <a href="#atp">atp</a> T a S a &#x2192 <a href="#atp">atp</a> <a href="#all">all</a> T <a href="#all">all</a> S.
<br><span class="constructor" id="at_arr">at_arr</span> : <a href="#atp">atp</a> T1 T2 &#x2192 <a href="#atp">atp</a> S1 S2 &#x2192 <a href="#atp">atp</a> <a href="#arr">arr</a> T1 S1 <a href="#arr">arr</a> T2 S2.
</code></pre>
<p><h3> Algorithmic Equality for terms</h3>
We extend the term equality judgement given for the untyped lambda-calculus with rules for type abstraction <code>ae_tl</code> and type application <code>ae_ta</code>.</p><br><pre><code><span class="typ" id="aeq">aeq</span> : <a href="#term">term</a> &#x2192 <a href="#term">term</a> &#x2192 <keyword>type</keyword>.
<br><keyword>%name</keyword> aeq D u
<br><span class="constructor" id="ae_a">ae_a</span> : <a href="#aeq">aeq</a> M1 N1 &#x2192 <a href="#aeq">aeq</a> M2 N2 &#x2192 <a href="#aeq">aeq</a> <a href="#app">app</a> M1 M2 <a href="#app">app</a> N1 N2.
<br><span class="constructor" id="ae_l">ae_l</span> : {x : <a href="#term">term</a>} <a href="#aeq">aeq</a> x x &#x2192 <a href="#aeq">aeq</a> M x N x &#x2192 <a href="#aeq">aeq</a> <a href="#lam">lam</a> (&lambda;x. M x) <a href="#lam">lam</a> (&lambda;x. N x).
<br><span class="constructor" id="ae_tl">ae_tl</span> : {a : <a href="#tp">tp</a>} <a href="#atp">atp</a> a a &#x2192 <a href="#aeq">aeq</a> M a N a &#x2192 <a href="#aeq">aeq</a> <a href="#tlam">tlam</a> (&lambda;a. M a) <a href="#tlam">tlam</a> (&lambda;a. N a).
<br><span class="constructor" id="ae_ta">ae_ta</span> : <a href="#aeq">aeq</a> M N &#x2192 <a href="#atp">atp</a> T S &#x2192 <a href="#aeq">aeq</a> <a href="#tapp">tapp</a> M T <a href="#tapp">tapp</a> N S.
</code></pre>
<p>Note that type equality <code>atp A B</code> can be defined independently of term equality <code>aeq M N</code>. In other words, <code>aeq M N</code> depends on <code>atp A B</code>, but not vice-versa.</p>
<p><h3> Declarative Equality for types</h3>
We define declarative equality for types in order to establish its equivalence with algorithmic equality and prove completeness. Rules for reflexivity, transitivity, and symmetry are explicitly derived.</p><br><pre><code><span class="typ" id="dtp">dtp</span> : <a href="#tp">tp</a> &#x2192 <a href="#tp">tp</a> &#x2192 <keyword>type</keyword>.
<br><keyword>%name</keyword> atp P u
<br><span class="constructor" id="dt_al">dt_al</span> : {a : <a href="#tp">tp</a>} <a href="#dtp">dtp</a> a a &#x2192 <a href="#dtp">dtp</a> T a S a &#x2192 <a href="#dtp">dtp</a> <a href="#all">all</a> T <a href="#all">all</a> S.
<br><span class="constructor" id="dt_arr">dt_arr</span> : <a href="#dtp">dtp</a> T1 T2 &#x2192 <a href="#dtp">dtp</a> S1 S2 &#x2192 <a href="#dtp">dtp</a> <a href="#arr">arr</a> T1 S1 <a href="#arr">arr</a> T2 S2.
<br><span class="constructor" id="dt_r">dt_r</span> : <a href="#dtp">dtp</a> T T.
<br><span class="constructor" id="dt_t">dt_t</span> : <a href="#dtp">dtp</a> T R &#x2192 <a href="#dtp">dtp</a> R S &#x2192 <a href="#dtp">dtp</a> T S.
<br><span class="constructor" id="dt_s">dt_s</span> : <a href="#dtp">dtp</a> T S &#x2192 <a href="#dtp">dtp</a> S T.
</code></pre>
<p><h3> Declarative Equality for terms</h3>
Declarative equality for terms is encoded similarly to its counterpart. Again, we are extending the Untyped Equality case study to account for polymorphism with constructors for type abstraction <code>de_tl</code> and type application <code>de_ta</code> </p><br><pre><code><span class="typ" id="deq">deq</span> : <a href="#term">term</a> &#x2192 <a href="#term">term</a> &#x2192 <keyword>type</keyword>.
<br><span class="constructor" id="de_l">de_l</span> : {x : <a href="#term">term</a>} <a href="#deq">deq</a> x x &#x2192 <a href="#deq">deq</a> M x N x &#x2192 <a href="#deq">deq</a> <a href="#lam">lam</a> (&lambda;x. M x) <a href="#lam">lam</a> (&lambda;x. N x).
<br><span class="constructor" id="de_a">de_a</span> : <a href="#deq">deq</a> M1 N1 &#x2192 <a href="#deq">deq</a> M2 N2 &#x2192 <a href="#deq">deq</a> <a href="#app">app</a> M1 M2 <a href="#app">app</a> N1 N2.
<br><span class="constructor" id="de_tl">de_tl</span> : {a : <a href="#tp">tp</a>} <a href="#dtp">dtp</a> a a &#x2192 <a href="#deq">deq</a> M a N a &#x2192 <a href="#deq">deq</a> <a href="#tlam">tlam</a> (&lambda;a. M a) <a href="#tlam">tlam</a> (&lambda;a. N a).
<br><span class="constructor" id="de_ta">de_ta</span> : <a href="#deq">deq</a> M N &#x2192 <a href="#dtp">dtp</a> T S &#x2192 <a href="#deq">deq</a> <a href="#tapp">tapp</a> M T <a href="#tapp">tapp</a> N S.
<br><span class="constructor" id="de_r">de_r</span> : <a href="#deq">deq</a> M M.
<br><span class="constructor" id="de_t">de_t</span> : <a href="#deq">deq</a> M L &#x2192 <a href="#deq">deq</a> L N &#x2192 <a href="#deq">deq</a> M N.
<br><span class="constructor" id="de_s">de_s</span> : <a href="#deq">deq</a> T S &#x2192 <a href="#deq">deq</a> S T.
</code></pre>
<p><h2> Context declarations</h2>
To establish reflexivity, transitivity, and symmetry of type equality, we define context of schema <code>atpCtx</code>.</p><br><pre><code><keyword>schema</keyword> <span class="schema" id="atpCtx">atpCtx</span> = <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a);
</code></pre>
<p>Since the case for lambda-abstraction <code>lam</code> deals with term assumptions while the type abstraction <code>tlam</code> introduces type assumptions, we need to specify <i>alternating</i> assumptions. This alternation of blocks is described by using <code>+</code> in Beluga's concrete syntax.</p><br><pre><code><keyword>schema</keyword> <span class="schema" id="aeqCtx">aeqCtx</span> = <keyword>block</keyword> (x:<a href="#term">term</a>, _u:<a href="#aeq">aeq</a> x x) + <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a);
</code></pre>
<p>We encode schemas to define meaningful contexts for declarative equality in a similar fashion. Clearly, <code>dtpCtx</code> and <code>deqCtx</code> are linear extensions of <code>atpCtx</code> and <code>aeqCtx</code>. respectively.</p><br><pre><code><keyword>schema</keyword> <span class="schema" id="dtpCtx">dtpCtx</span> = <keyword>block</keyword> (a:<a href="#tp">tp</a>, u:<a href="#atp">atp</a> a a, _t:<a href="#dtp">dtp</a> a a);
<br><keyword>schema</keyword> <span class="schema" id="deqCtx">deqCtx</span> = <keyword>block</keyword> (x:<a href="#term">term</a>, u:<a href="#aeq">aeq</a> x x, _t:<a href="#deq">deq</a> x x) + <keyword>block</keyword> (a:<a href="#tp">tp</a>, u:<a href="#atp">atp</a> a a, _t:<a href="#dtp">dtp</a> a a);
</code></pre>
<p><h2> Proof of Reflexivity for Types</h2>
The reflexivity for types (Theorem 11) can be implemented as a recursive function called <code>reftp</code> of type: <code>{g:atpCtx}{T:[g &#8866; tp ]}[g &#8866; atp (T &hellip;)(T &hellip;)]</code>. This can be read as: for all contexts <code>g</code> that have schema <code>atpCtx</code>, for all types <code>T</code>, we have a proof that <code>[ g &#8866; atp (T &hellip;)(T &hellip;)]</code>. Quantification over contexts and contextual objects in computation-level types is denoted by curly braces; the corresponding abstraction on the level of expressions is written as <code>mlam g => mlam T1 => e</code>.</p><br><pre><code><keyword>rec</keyword> <span class="function" id="reftp">reftp</span> : {g : <a href="#atpCtx">atpCtx</a>} {T : [g &#x22A2 <a href="#tp">tp</a>]} [g &#x22A2 <a href="#atp">atp</a> (T &hellip;) (T &hellip;)] =
<keyword>mlam</keyword> g &#x21D2 <keyword>mlam</keyword> T &#x21D2 <keyword>case</keyword> [g &#x22A2 T &hellip;] <keyword>of</keyword> 
  | [g &#x22A2 #p.1 &hellip;] &#x21D2 [g &#x22A2 #p.2 &hellip;]
  | [g &#x22A2 <a href="#all">all</a> (&lambda;x. T &hellip; x)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#reftp">reftp</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a)] [g, b &#x22A2 T &hellip; b.1] <keyword>in</keyword>
    [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;x. &lambda;w. D &hellip; x w)]
  | [g &#x22A2 <a href="#arr">arr</a> (T &hellip;) (S &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#reftp">reftp</a> [g] [g &#x22A2 T &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#reftp">reftp</a> [g] [g &#x22A2 S &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#at_arr">at_arr</a> (D1 &hellip;) (D2 &hellip;)];
</code></pre>
<p>In the proof for <code>refltp</code> we begin by introducing and <code>T</code> followed by a case analysis on <code>[g &#8866; T &hellip;]</code> using pattern matching. There are three possible cases for <code>T</code>:
<ul>
<ul><li><b>Variable case.</b> If <code>T</code> is a variable from <code>g</code>, we write <code>[g &#8866; #p.1 &hellip;]</code> where <code>#p</code> denotes a parameter variable declared in the context <code>g</code>. Operationally, <code>#p</code> can be instantiated with any bound variable from the context <code>g</code>. Since the context <code>g</code> has schema <code>atpCtx</code>, it contains blocks <code>a:tp , _t:atp a a;</code>. The first projection allows us to extract the type component, while the second projection denotes the proof of <code>_t:atp a a;</code>.</li>
<li><b>Existential case.</b> If <code>T</code> is an existential quantification, then we extend the context and appeal to the induction hypothesis by making a recursive call. Beluga supports declaration weakening as described in the companion paper (Felty et al, 2014), which allows us to use <code>T</code> that has type <code>[g, a:tp &#8866; tp ]</code> in the extended context <code>[g, b:block a:tp , _t: atp a a]</code>. We simply construct a weakening substitution <code>&hellip; b.1</code> with domain <code>g,a:tp</code> and range <code>g, b:block a:tp , _t: atp a a</code> that essentially renames <code>a</code> to <code>b.1</code> in <code>T</code>. The recursive call returns <code>[g,b:block a:tp , _t:atp a a &#8866; D &hellip; b.1 b.2]</code>. Using it together with rule <code>at_la</code> we build the final derivation.</li>
<li><b>Arrow case.</b> If <code>T</code> is an arrow type, we appeal twice to the induction hypothesis and build a proof for <code>[g &#8866; atp (arr (T &hellip;) (S &hellip;)) (arr (T &hellip;) (S &hellip;))]</code>.</li></ul>
</ul></p>
<p><h2> Proof of Reflexivity for Terms</h2>
The reflexivity for terms (Theorem 13) is likewise implemented as a recursive function, called <code>ref</code> of type: <code>{g:aeqCtx} {M:[g &#8866; term]} [g &#8866; aeq (M &hellip;) (M &hellip;)]]</code>. This can be read as: for all contexts <code>g</code> that have schema <code>aeqCtx</code>, for all terms <code>M</code>, we have a proof that <code>[ g &#8866; aeq (M &hellip;)(M &hellip;)]</code>.</p><br><pre><code><keyword>rec</keyword> <span class="function" id="ref">ref</span> : {g : <a href="#aeqCtx">aeqCtx</a>} {M : [g &#x22A2 <a href="#term">term</a>]} [g &#x22A2 <a href="#aeq">aeq</a> (M &hellip;) (M &hellip;)] =
<keyword>mlam</keyword> g &#x21D2 <keyword>mlam</keyword> M &#x21D2 <keyword>case</keyword> [g &#x22A2 M &hellip;] <keyword>of</keyword> 
  | [g &#x22A2 #p.1 &hellip;] &#x21D2 [g &#x22A2 #p.2 &hellip;]
  | [g &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (y:<a href="#term">term</a>, _t:<a href="#aeq">aeq</a> y y) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#ref">ref</a> [g, b : <keyword>block</keyword> (y:<a href="#term">term</a>, _t:<a href="#aeq">aeq</a> y y)] [g, b &#x22A2 M &hellip; b.1] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;w. D &hellip; x w)]
  | [g &#x22A2 <a href="#app">app</a> (M1 &hellip;) (M2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ref">ref</a> [g] [g &#x22A2 M1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#ref">ref</a> [g] [g &#x22A2 M2 &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)]
  | [g &#x22A2 <a href="#tlam">tlam</a> (&lambda;a. M &hellip; a)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#ref">ref</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a)] [g, b &#x22A2 M &hellip; b.1] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;x. &lambda;w. D &hellip; x w)]
  | [g &#x22A2 <a href="#tapp">tapp</a> (M &hellip;) (T &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ref">ref</a> [g] [g &#x22A2 M &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#reftp">reftp</a> [g] [g &#x22A2 T &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D1 &hellip;) (D2 &hellip;)];
</code></pre>
<p>This time, there are five possible cases for our meta-variable <code>M</code>:
<ul>
<ul><li><b>Variable case.</b> If <code>M</code> is a variable from <code>g</code>, we write <code>[g &#8866; #p.1 &hellip;]</code> where <code>#p</code> denotes a parameter variable declared in the context <code>g</code>. Operationally, <code>#p</code> can be instantiated with any bound variable from the context <code>g</code>. Since the context <code>g</code> has schema <code>aeqCtx</code>, it contains blocks <code>x:tm , ae_v:aeq x x.</code> The first projection allows us to extract the term component, while the second projection denotes the proof of <code>aeq x x</code>.</li>
<li><b>Lambda-abstraction case.</b> If <code>M</code> is a lambda-term, then we extend the context and appeal to the induction hypothesis by making a recursive call. Beluga supports declaration weakening as described in the companion paper (Felty et al, 2014), which allows us to use M that has type <code>[g, x:tm &#8866; tm ]</code> in the extended context <code>[g, b:block y:tm , ae_v: aeq y y]</code>. We simply construct a weakening substitution <code>&hellip; b.1</code> with domain <code>g,y:tm</code> and range <code>g, b:block y:tm , ae_v:aeq y y.</code> that essentially renames <code>y</code> to <code>b.1</code> in <code>M</code>. The recursive call returns <code>[g,b:block y:tm ,ae_v:aeq y y &#8866; D &hellip; b.1 b.2]</code>. Using it together with rule <code>ae_l</code> we build the final derivation.</li>
<li><b>Term application case.</b> If <code>M</code> is an application, we appeal twice to the induction hypothesis and build a proof for <code>[g &#8866; aeq (app (M1 &hellip;) (M2 &hellip;)) (app (M1 &hellip;) (M2 &hellip;))]</code>.</li>
<li><b>Type abstraction case.</b> If <code>M</code> is a type abstraction, then we extend the context and appeal to the induction hypothesis by making a recursive call. We use <code>M</code> that has type <code>[g, a:tp &#8866; tp ]</code> in the extended context <code>[g, b:block a:tp , _t: atp a a]</code> and construct a weakening substitution <code>&hellip; b.1</code> with domain <code>g,a:tp</code> and range <code>g, b:block a:tp , _t: atp a a</code> that essentially renames <code>a</code> to <code>b.1</code> in <code>T</code>. The recursive call returns <code>[g,b:block a:tp , _t:atp a a &#8866; D &hellip; b.1 b.2]</code>. Using it together with rule <code>at_la</code> we build the final derivation.</li>
<li><b>Type application case.</b> If <code>M</code> is a type application, we appeal twice to the induction hypothesis and build a proof for <code>[g &#8866; aeqCtx (tapp (M &hellip;) (T &hellip;)) (tapp (M &hellip;) (T &hellip;))]</code>.</li></ul>
</ul></p>
<p><h2> Proof of Transitivity for Types</h2></p><br><pre><code><keyword>rec</keyword> <span class="function" id="transtp">transtp</span> : (g:<a href="#atpCtx">atpCtx</a>) [g &#x22A2 <a href="#atp">atp</a> (T &hellip;) (R &hellip;)] &#x2192 [g &#x22A2 <a href="#atp">atp</a> (R &hellip;) (S &hellip;)] &#x2192 [g &#x22A2 <a href="#atp">atp</a> (T &hellip;) (S &hellip;)] =
<keyword>fn</keyword> ae1 &#x21D2 <keyword>fn</keyword> ae2 &#x21D2 <keyword>case</keyword> ae1 <keyword>of</keyword> 
  | [g &#x22A2 #p.2 &hellip;] &#x21D2 ae2
  | [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;a. &lambda;u. D1 &hellip; a u)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;a. &lambda;u. D2 &hellip; a u)] = ae2 <keyword>in</keyword>
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#transtp">transtp</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D1 &hellip; b.1 b.2] [g, b &#x22A2 D2 &hellip; b.1 b.2] <keyword>in</keyword>
    [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;a. &lambda;u. D &hellip; a u)]
  | [g &#x22A2 <a href="#at_arr">at_arr</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 <a href="#at_arr">at_arr</a> (D3 &hellip;) (D4 &hellip;)] = ae2 <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D &hellip;] = <a href="#transtp">transtp</a> [g &#x22A2 D1 &hellip;] [g &#x22A2 D3 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D' &hellip;] = <a href="#transtp">transtp</a> [g &#x22A2 D2 &hellip;] [g &#x22A2 D4 &hellip;] <keyword>in</keyword>
    [g &#x22A2 <a href="#at_arr">at_arr</a> (D &hellip;) (D' &hellip;)];
</code></pre>
<p><h2> Proof of Transitivity for Terms</h2></p><br><pre><code><keyword>rec</keyword> <span class="function" id="trans">trans</span> : (g:<a href="#aeqCtx">aeqCtx</a>) [g &#x22A2 <a href="#aeq">aeq</a> (T &hellip;) (R &hellip;)] &#x2192 [g &#x22A2 <a href="#aeq">aeq</a> (R &hellip;) (S &hellip;)] &#x2192 [g &#x22A2 <a href="#aeq">aeq</a> (T &hellip;) (S &hellip;)] =
<keyword>fn</keyword> ae1 &#x21D2 <keyword>fn</keyword> ae2 &#x21D2 <keyword>case</keyword> ae1 <keyword>of</keyword> 
  | [g &#x22A2 #p.2 &hellip;] &#x21D2 ae2
  | [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D1 &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D2 &hellip; x u)] = ae2 <keyword>in</keyword>
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (x:<a href="#term">term</a>, _t:<a href="#aeq">aeq</a> x x) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#trans">trans</a> [g, b : <keyword>block</keyword> (x':<a href="#term">term</a>, _t:<a href="#aeq">aeq</a> x' x') &#x22A2 D1 &hellip; b.1 b.2] [g, b &#x22A2 D2 &hellip; b.1 b.2] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D &hellip; x u)]
  | [g &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 <a href="#ae_a">ae_a</a> (D3 &hellip;) (D4 &hellip;)] = ae2 <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D &hellip;] = <a href="#trans">trans</a> [g &#x22A2 D1 &hellip;] [g &#x22A2 D3 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D' &hellip;] = <a href="#trans">trans</a> [g &#x22A2 D2 &hellip;] [g &#x22A2 D4 &hellip;] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_a">ae_a</a> (D &hellip;) (D' &hellip;)]
  | [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;a. &lambda;u. D1 &hellip; a u)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;a. &lambda;u. D2 &hellip; a u)] = ae2 <keyword>in</keyword>
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#trans">trans</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D1 &hellip; b.1 b.2] [g, b &#x22A2 D2 &hellip; b.1 b.2] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;x. &lambda;u. D &hellip; x u)]
  | [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D1 &hellip;) (Q1 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D2 &hellip;) (Q2 &hellip;)] = ae2 <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D &hellip;] = <a href="#trans">trans</a> [g &#x22A2 D1 &hellip;] [g &#x22A2 D2 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 Q &hellip;] = <a href="#transtp">transtp</a> [g &#x22A2 Q1 &hellip;] [g &#x22A2 Q2 &hellip;] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D &hellip;) (Q &hellip;)];
</code></pre>
<p><h2> Proof of Symmetry for Types</h2></p><br><pre><code><keyword>rec</keyword> <span class="function" id="symtp">symtp</span> : (g:<a href="#atpCtx">atpCtx</a>) [g &#x22A2 <a href="#atp">atp</a> (T &hellip;) (R &hellip;)] &#x2192 [g &#x22A2 <a href="#atp">atp</a> (R &hellip;) (T &hellip;)] =
<keyword>fn</keyword> ae &#x21D2 <keyword>case</keyword> ae <keyword>of</keyword> 
  | [g &#x22A2 #p.2 &hellip;] &#x21D2 ae
  | [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;x. &lambda;u. D &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D' &hellip; b.1 b.2] =
    <a href="#symtp">symtp</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D &hellip; b.1 b.2] <keyword>in</keyword>
    [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;x. &lambda;u. D' &hellip; x u)]
  | [g &#x22A2 <a href="#at_arr">at_arr</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1' &hellip;] = <a href="#symtp">symtp</a> [g &#x22A2 D1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2' &hellip;] = <a href="#symtp">symtp</a> [g &#x22A2 D2 &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#at_arr">at_arr</a> (D1' &hellip;) (D2' &hellip;)];
</code></pre>
<p><h2> Proof of Symmetry for Terms</h2></p><br><pre><code><keyword>rec</keyword> <span class="function" id="sym">sym</span> : (g:<a href="#aeqCtx">aeqCtx</a>) [g &#x22A2 <a href="#aeq">aeq</a> (T &hellip;) (R &hellip;)] &#x2192 [g &#x22A2 <a href="#aeq">aeq</a> (R &hellip;) (T &hellip;)] =
<keyword>fn</keyword> ae &#x21D2 <keyword>case</keyword> ae <keyword>of</keyword> 
  | [g &#x22A2 #p.2 &hellip;] &#x21D2 ae
  | [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (x:<a href="#term">term</a>, _t:<a href="#aeq">aeq</a> x x) &#x22A2 D' &hellip; b.1 b.2] =
    <a href="#sym">sym</a> [g, b : <keyword>block</keyword> (x:<a href="#term">term</a>, _t:<a href="#aeq">aeq</a> x x) &#x22A2 D &hellip; b.1 b.2] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D' &hellip; x u)]
  | [g &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1' &hellip;] = <a href="#sym">sym</a> [g &#x22A2 D1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2' &hellip;] = <a href="#sym">sym</a> [g &#x22A2 D2 &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#ae_a">ae_a</a> (D1' &hellip;) (D2' &hellip;)]
  | [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;x. &lambda;u. D &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D' &hellip; b.1 b.2] =
    <a href="#sym">sym</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, _t:<a href="#atp">atp</a> a a) &#x22A2 D &hellip; b.1 b.2] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;x. &lambda;u. D' &hellip; x u)]
  | [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D &hellip;) (Q &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D' &hellip;] = <a href="#sym">sym</a> [g &#x22A2 D &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 Q' &hellip;] = <a href="#symtp">symtp</a> [g &#x22A2 Q &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D' &hellip;) (Q' &hellip;)];
</code></pre>
<p><h2> Proof of Completeness for Types</h2></p><br><pre><code><keyword>rec</keyword> <span class="function" id="ctp">ctp</span> : (g:<a href="#dtpCtx">dtpCtx</a>) [g &#x22A2 <a href="#dtp">dtp</a> (T &hellip;) (S &hellip;)] &#x2192 [g &#x22A2 <a href="#atp">atp</a> (T &hellip;) (S &hellip;)] =
<keyword>fn</keyword> e &#x21D2 <keyword>case</keyword> e <keyword>of</keyword> 
  | [g &#x22A2 #p.3 &hellip;] &#x21D2 [g &#x22A2 #p.2 &hellip;]
  | [g &#x22A2 <a href="#dt_r">dt_r</a>] &#x21D2 <a href="#reftp">reftp</a> [g] [g &#x22A2 _]
  | [g &#x22A2 <a href="#dt_arr">dt_arr</a> (F1 &hellip;) (F2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ctp">ctp</a> [g &#x22A2 F1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#ctp">ctp</a> [g &#x22A2 F2 &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#at_arr">at_arr</a> (D1 &hellip;) (D2 &hellip;)]
  | [g &#x22A2 <a href="#dt_al">dt_al</a> (&lambda;x. &lambda;u. F &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, u:<a href="#atp">atp</a> a a, _t:<a href="#dtp">dtp</a> a a) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#ctp">ctp</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, u:<a href="#atp">atp</a> a a, _t:<a href="#dtp">dtp</a> a a) &#x22A2 F &hellip; b.1 b.3] <keyword>in</keyword>
    [g &#x22A2 <a href="#at_al">at_al</a> (&lambda;x. &lambda;v. D &hellip; x v)]
  | [g &#x22A2 <a href="#dt_t">dt_t</a> (F1 &hellip;) (F2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#ctp">ctp</a> [g &#x22A2 F2 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ctp">ctp</a> [g &#x22A2 F1 &hellip;] <keyword>in</keyword>
    <a href="#transtp">transtp</a> [g &#x22A2 D1 &hellip;] [g &#x22A2 D2 &hellip;]
  | [g &#x22A2 <a href="#dt_s">dt_s</a> (F &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D &hellip;] = <a href="#ctp">ctp</a> [g &#x22A2 F &hellip;] <keyword>in</keyword> <a href="#symtp">symtp</a> [g &#x22A2 D &hellip;];
</code></pre>
<p><h2> Proof of Completeness for Terms</h2></p><br><pre><code><keyword>rec</keyword> <span class="function" id="ceq">ceq</span> : (g:<a href="#deqCtx">deqCtx</a>) [g &#x22A2 <a href="#deq">deq</a> (T &hellip;) (S &hellip;)] &#x2192 [g &#x22A2 <a href="#aeq">aeq</a> (T &hellip;) (S &hellip;)] =
<keyword>fn</keyword> e &#x21D2 <keyword>case</keyword> e <keyword>of</keyword> 
  | [g &#x22A2 #p.3 &hellip;] &#x21D2 [g &#x22A2 #p.2 &hellip;]
  | [g &#x22A2 <a href="#de_r">de_r</a>] &#x21D2 <a href="#ref">ref</a> [g] [g &#x22A2 _]
  | [g &#x22A2 <a href="#de_a">de_a</a> (F1 &hellip;) (F2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ceq">ceq</a> [g &#x22A2 F1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#ceq">ceq</a> [g &#x22A2 F2 &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)]
  | [g &#x22A2 <a href="#de_l">de_l</a> (&lambda;x. &lambda;u. F &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (x:<a href="#term">term</a>, u:<a href="#aeq">aeq</a> x x, _t:<a href="#deq">deq</a> x x) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#ceq">ceq</a> [g, b : <keyword>block</keyword> (x:<a href="#term">term</a>, u:<a href="#aeq">aeq</a> x x, _t:<a href="#deq">deq</a> x x) &#x22A2 F &hellip; b.1 b.3] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;v. D &hellip; x v)]
  | [g &#x22A2 <a href="#de_t">de_t</a> (F1 &hellip;) (F2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D2 &hellip;] = <a href="#ceq">ceq</a> [g &#x22A2 F2 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ceq">ceq</a> [g &#x22A2 F1 &hellip;] <keyword>in</keyword> <a href="#trans">trans</a> [g &#x22A2 D1 &hellip;] [g &#x22A2 D2 &hellip;]
  | [g &#x22A2 <a href="#de_s">de_s</a> (F &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 D &hellip;] = <a href="#ceq">ceq</a> [g &#x22A2 F &hellip;] <keyword>in</keyword> <a href="#sym">sym</a> [g &#x22A2 D &hellip;]
  | [g &#x22A2 <a href="#de_tl">de_tl</a> (&lambda;a. &lambda;u. F &hellip; a u)] &#x21D2
    <keyword>let</keyword>  [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, u:<a href="#atp">atp</a> a a, _t:<a href="#dtp">dtp</a> a a) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#ceq">ceq</a> [g, b : <keyword>block</keyword> (a:<a href="#tp">tp</a>, u:<a href="#atp">atp</a> a a, _t:<a href="#dtp">dtp</a> a a) &#x22A2 F &hellip; b.1 b.3] <keyword>in</keyword>
    [g &#x22A2 <a href="#ae_tl">ae_tl</a> (&lambda;x. &lambda;v. D &hellip; x v)]
  | [g &#x22A2 <a href="#de_ta">de_ta</a> (F1 &hellip;) (P2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [g &#x22A2 Q2 &hellip;] = <a href="#ctp">ctp</a> [g &#x22A2 P2 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [g &#x22A2 D1 &hellip;] = <a href="#ceq">ceq</a> [g &#x22A2 F1 &hellip;] <keyword>in</keyword> [g &#x22A2 <a href="#ae_ta">ae_ta</a> (D1 &hellip;) (Q2 &hellip;)];
</code></pre><br><br><h3>To download the code: <a href="Alternating_Assumptions.bel" target="_blank">Alternating_Assumptions.bel</a></h3>

</body>
</html>
