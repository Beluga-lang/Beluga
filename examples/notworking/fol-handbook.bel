% Natural Deduction - Hilbert Translation
% adapted from Handbook article on Logical Frameworks
% by F. Pfenning
%
% Author: Brigitte Pientka
%
% Comment: 
% - This is a good example to 
%   illustrate the differences
%   between Twelf, Delphin and our language.
% - illustrate the need for context schema
%   subsumption
% - proper context coercions should be added
% - should be extended to include the proof
%   that every Hilber-style derivation has 
%   a natural deduction derivation

i : type.  % individual
o : type.  % formulas

imp : o -> o -> o.  
all : (i -> o) -> o.
not : o -> o.     

nd : o -> type. % Natural deduction
impi : (nd A -> nd B) -> nd (imp A B).
impe : nd (imp A B) -> nd A -> nd B.
noti : ({p:o} nd A -> nd p) -> nd (not A).
note : nd (not A) -> {C:o} nd A -> nd C.
alli : ({a:i} nd (A a)) -> nd (all (\x. A x)).
alle : nd (all (\x. A x)) -> {T:i} nd (A T).

hil : o -> type.  % Hilbert deductions
k  : hil (imp A (imp B A)).
s  : hil (imp (imp A (imp B C)) (imp (imp A B) (imp A C))).
n1 : hil (imp (imp A (not B)) (imp (imp A B) (not A))).
n2 : hil (imp (not A) (imp A B)).
f1 : {T:i} hil (imp (all (\x.A x)) (A T)).
f2 : hil (imp (all (\x.(imp B  (A x))))  (imp B (all (\x.A x)))).
mp : hil (imp A B) -> hil A -> hil B.
ug : ({a:i} hil (A a)) -> hil (all (\x.A x)).

% Implementation of the Deduction Theorem
%
%   If G, u:hil A |- hil B then G |- hil (A imp B).
%
% NOTE: WE OMIT IMPLICIT TYPE ARGUMENTS a AND b IN THE SUBSEQUENT
% PROGRAM FOR BETTER READABILITY 

schema w =  i + some [ a:o ] hil a;

 rec ded: {g:(w)*} 
    (hil (B ..))[g, u:hil (A ..)] -> (hil (imp (A ..) (B ..)))[g] = 
 FN g => fn h =>  
 case h of 
   [g, u: hil _ ] #p .. =>  [g] mp k #p ..  % SPECIAL!
 | [g, u: hil _ ] u     => [g] (mp (mp s k) k)
 | [g, u: hil _ ] k  => [g] mp k k
 | [g, u: hil _ ] n1 => [g] mp k n1
 | [g, u: hil _ ] n2 => [g] mp k n2
 | [g, u: hil _ ] f1 (T ..) => [g]  mp k (f1 (T ..))
 | [g, u: hil _ ] f2 => [g] mp k f2

 | [g, u: hil _ ] ug (\x. (H .. x u)) => 
  let
      [g,x:i] (H' .. x) = ded [g, x:i]  ([g, x, u]  H .. x u)
  in
       [g] mp f2 (ug  \x.H' .. x)

%{ | [g, u: hil _ ] (mp (H1 .. u) (H2 .. u)) => 
  let [g] H2' .. = ded [g] ([g,u] H2 .. u) in
  let [g] H1' .. = ded [g] ([g,u] H1 .. u) in
       [g] mp (mp s (H1' ..)) (H2' ..)

}%
;

% % Theorem: If G |- nd A  where G = nd B1 .... nd Bn 
% %          then G* |- hil A   where G' = hil B1 ... hil Bn

% schema l = i + (some {A:o} block {u:nd A} {h:hil A}) + o; % where l < w 

% rec ndhil : {g:(l)*}{a::o[g]} (nd a[id(g)])[g] -> (hil a[id(g)])[g] =
% FN g => mlam a => fn D => 
% case D of 
%   [g] fst #p ..) => [g] snd #p ..)
% | [g] impi A[id(g)]  B[id(g)]  \u. D[id(g),u]) => 
%   let 
%       box(g,u.H[id(g),u]) = ndhil [g, u:Sigma u:nd A[id(g)].hil A[id(g)]] 
%                                 < . B[id(g)]> box(g,u. D[id(g), fst u])
%   in
%     % NOTE HERE WE NEED THE FACT THAT l < w !!!
%       ded [g] box(g,u.H[id(g),u]
%   end
% | [g] impe A[id(g)] B[id(g)] D1[id(g)] D2[id(g)]) => 
%   let
%       [g]H1[id(g)]) = ndhil [g] <g.A[id(g)]> <g.B[id(g)] [g] D1[id(g)]		
%       [g]H2[id(g)]) = ndhil [g] <g.B[id(g)] [g] D2[id(g)]		
%   in 
%       [g] mp A[id(g)] B[id(g)] H1[id(g)] H2[id(g)])
%   end
% | [g] noti \p.\u.D[id(g),p,u]) => 
%   let
%       box(g,w,p. H[id(g),w,p]) = ndhil [g, w:(nd A[id(g)] * hil A[id(g)],  p:o]
%                            <g,w p.p> box(g,w,p. D[id(g),p, fst w])
%       % NOTE HERE WE NEED THE FACT THAT l < w !!!
%       [g] H1'[id(g)]) = ded [g] <g. not A[id(g)> 
%                              box(g,w. H[id(g),w, not A[id(g)]])
%       % NOTE HERE WE NEED THE FACT THAT l < w !!!
%       [g] H1''[id(g)]) = ded [g] <g. A[id(g)]>
%                              box(g,w. H[id(g),w, A[id(g)]])
%   in 
%       [g] mp (mp n1 H1'[id(g)]) H1''[id(g)])
%   end
% | [g] (note A[id(g)] D1[id(g)] C[id(g)] D2[id(g)]) => 
%   let
%       [g] H1[id(g)]) = ndhil [g] <g.A[id(g)]> [g]D1[id(g)]
%       [g] H2[id(g)]) = ndhil [g] <g.A[id(g)]> [g]D2[id(g)]
%   in
%       [g] mp (mp n2 H1[id(g)]) H2[id(g)])
%   end
% | [g] alle (\x.A[id(t),x]) D1[id(g)] T[.]) => 
%   let
%       [g]H1[id(g)]) =  ndhil [g] <g.A[id(g),T[.]]> D1[id(g)]
%   in
%       box(g .  mp (f1 T[.]) H1[id(g)])
%   end
% | [g] alli \x. D[id(g), x]) => 
%   let
%       box(g,x.H[id(g),x]) =  ndhil [g, x:i] box(g, x. D[id(g),x])
%   in
%       [g] ug \x.H[id(g),x])
%   end;
