% ----------------------------------------------------------------------------
% Weak normalization for lambda-calculus with 
% parallel reduction (in particular with reduction 
% under binder)
% Author: A. Cave
% ----------------------------------------------------------------------------
% Definition of types and intrinsically typed terms
LF tp : type = 
| i :  tp
| arr: tp -> tp -> tp
;
%name tp T.

LF tm : tp -> type = 
| app : tm (arr T S) -> tm T -> tm S
| lam : (tm T -> tm S) -> tm (arr T S)
;
%name tm E.

schema ctx = tm T;
% ----------------------------------------------------------------------------
% Multi-step parallel reduction
LF step : tm A -> tm A -> type = 
| s_beta : step (app (lam M) N) (M N)
| s_eta : {M:tm (arr A B)} step M (lam (\x. app M x))
| s_lam : ({x:tm A} step (M x) (M' x)) -> step (lam M) (lam M')
| s_app : step M M' -> step N N' -> step (app M N) (app M' N')
| s_refl : step M M
| s_trans : step M M' -> step M' M'' -> step M M''
;
%name step S.
% -----------------------------------------------------------------------------
% Defining Normal and Neutral Terms
% We define them using inductive types rather than using LF to not clutter 
% our LF context.  We do not enforce eta-longness here, although this can in principle be done.
% To avoid clutter, we do not explicitly enforce in the definition of normal/neutral that the type A is closed. This is only enforced when we define the predicate Halts.
%

LF normal : tm A -> type =
| n_lam : ({x:tm A} neutral x -> normal (M x)) -> normal (lam (\x. M x))
| n_neut : neutral M -> normal M
and neutral : tm A -> type =
| n_app : neutral M -> normal N -> neutral (app M N)
;

schema nctx = some [t:tp] block x:tm t, y:neutral x;

inductive Halts : (gamma:nctx) {A:[ |- tp]}{M:[gamma |- tm A[]]} ctype =
| Halts : {V:[gamma |- tm A[]]} [gamma |- step M V] -> [gamma |- normal V] -> Halts [ |- A] [gamma |- M];

% -----------------------------------------------------------------------------
% Reducibility Definition 
% It is defined inductively over the type A.
% In the case where A is a function type we quantify over
% the context h0, a substitution #R which maps variables from the context h to the
% context h0. While we use built-in simultanteous substitutions to model #R, our 
% built-in substitutions are more general and do not restrict #R to be a variable 
% substitution (i.e. a possible a weakening substitution).
% We hence define explicitly a predicate that checks whether a given substitution is a 
% variable-to-variable substitution.

stratified Reduce : (gamma:nctx) {A:[ |- tp]}{M:[gamma |- tm A[]]} ctype =
| Base : Halts [ |- i] [gamma |- M] -> Reduce [ |- i] [gamma |- M]
| Arr :  {M:[gamma |- tm (arr A[] B[])]}
         ({phi:nctx} {#S:[phi |- gamma]} {N:[phi |- tm A[]]}
            Reduce [ |- A] [phi |- N]
          -> Reduce [ |- B ] [phi |- app M[#S] N])
         -> Reduce [ |- arr A B] [gamma |-  M];

% -----------------------------------------------------------------------------
% Lemma [ Backwards Closed ]
% If step M M'   and   M' is reducible at type A  
% then M is reducible at type A

rec haltsStep : {S:[g |- step M M']} Halts [ |- A] [g |- M'] -> Halts [ |- A] [g |- M] =
/ total (haltsStep) /
mlam S => fn h => let (h : Halts [ |- A] [g |- M']) = h in
let Halts [_ |- _] [g |- R] v = h in Halts [_ |- _] [g |- s_trans S R] v;


rec closed : {A:[|- tp]}{M:[g |- tm A[]]}{M':[g |- tm A[]]}
             {S:[g |- step M M']} Reduce [ |- A] [g |- M'] -> Reduce [ |- A] [g |- M] =
/ total a (closed _ a) /
mlam A,M,M',S => fn r => case [|- A] of 
| [|- i] =>  
   let Base ha = r in 
   let (ha : Halts [ |- i] [g |- M]) = ha in Base (haltsStep  [g |- S] ha)

| [|- arr A B] => 
  let Arr [g |- M] f = r in 
  Arr [g |- _]
  (mlam h => mlam #W => mlam N => fn rn =>
    closed [ |- B] [h |- _ ] [h |- _ ] [h |- s_app S[#W] s_refl] (f [h] [h |- #W] [h |- N] rn))
;

% -----------------------------------------------------------------------------
% Lemma: If M is reducible at type A then M halts

rec reflect : {g:nctx}{A:[|-tp]}{R:[g |- tm A[]]}{NR:[g |- neutral R]} Reduce [ |- A] [g |- R] =
/ total a (reflect g a) /
mlam g, A,R,NR => case [ |- A] of
| [ |- i] => 
    Base (Halts [_ |- _] [g |- s_refl] [g |- n_neut NR])
| [ |- arr A B] =>
  Arr [g |- R]
  (mlam h => mlam #W => mlam M2 => fn rm2 =>
    let Halts [_ |- _] [h |- MS] [_ |- N] = reify [h] [|- A] [h |- M2] rm2 in
    closed [|- _ ] [h |- _ ]  [h |- _ ] [h |- s_app s_refl (MS)] 
           (reflect [h] [|- B] [h |- _ ] [_ |- n_app NR[#W] N]))

and reify : {g:nctx}{A:[|- tp]}{M:[g |- tm A[]]}
            Reduce [ |- A] [g |- M] -> Halts [ |- A] [g |- M] =
 / total a (reify g a ) /
mlam g,A,M => fn r => case [|- A] of 
| [|- i] => let Base h = r in h
| [|- arr A B] => 
  let Arr [g |- M] f = r in 
  let q1 = f [g,b:block x:tm _,y:neutral x] [g,b |- ..] [g,b |- b.1]
             (reflect [g,b:block x:tm _,y:neutral x ] [|- A] [g,b |- b.1] [g,b:block x:tm _,y:neutral x |- b.2]) in
  let Halts [g,b:block x:tm A[],y:neutral x |- _]
            [g,b:block x:tm A[],y:neutral x |- MS]
            [g,b:block x:tm A[],y:neutral x |- N]
          = reify [g,b:block x:tm A[],y:neutral x ] [|- B] [g,b:block x:tm A[],y:neutral x |- app M[..] b.1] q1 in
  let [g,b:block x:tm A[],y:neutral x |- MS'[..,b.1]] = [g,b:block x:tm A[],y:neutral x |- MS] in % I am not sure why I have to do this separately
  Halts [_ |- _] [g |- s_trans (s_eta _) (s_lam (\x. MS'))] [g |- n_lam (\x. \y. N[..,<x;y>])]
;

% -----------------------------------------------------------------------------
% Defining reducibility of simultaneous substitutions.

inductive RedSub : {g:ctx}(h:nctx){#S:[h |- g]} ctype =
| Nil : RedSub [] [h |- ^ ]
| Dot : RedSub [g] [h |- #S ] -> Reduce [ |- A] [h |- M] -> RedSub [g,x:tm A[]] [h |- #S, M ];

% Lemmas about reducible simultaneous substitutions.
% Weakening a term M that is reducible at type A
rec wknRed : (h:nctx) {#W:[h |- g]} Reduce  [ |- A] [g |- M] -> Reduce [ |- A] [h |- M[#W]] =
/ total (wknRed) /
mlam #W => fn r =>
case r of
| Base (Halts [_ |- _] [g |- S] [g |- NR]) => Base (Halts [_ |- _] [_ |- S[#W]] [_ |- NR[#W]])
| Arr [g |- M] f =>
  Arr [_ |- M[#W]]
   (mlam h', #W2, N => fn rn =>
    f [h'] [h' |- #W[#W2]] [h' |-  N] rn);


% Composing a reducible substitution with a variable substitution yields a 
% reducible substitution
rec wknRedSub : {#W:[h' |- h]} RedSub [g] [h |- #S] -> RedSub [g] [h' |- #S[#W]] =
/ total rs (wknRedSub _ _ _ _ _ rs) /
mlam #W => fn rs => case rs of
| Nil => Nil
| Dot rs' rN => Dot (wknRedSub [_ |- #W] rs') (wknRed [_ |- #W] rN);

% If sigma is a reducible substitution then applying sigma to a variable yields a term 
% that is reducible
rec redVar : {g:ctx}{#p:[g |- tm T[]]} RedSub [g] [h |- #S] ->  Reduce [ |- T] [h |- #p[#S] ] =
/ total g (redVar g) / 
mlam g, #p => fn rs => case [g] of 
| [] => impossible [ |- #p] 
| [g', x:tm A[]] => (case [g', x:tm A[] |- #p[..,x]] of 
   | [g',x:tm A[] |-  x]      =>    let Dot rs' rN = rs in rN
   | [g',x:tm A[] |-  #q[..]] => let Dot rs' rN = rs in redVar [g'] [g' |-  #q] rs');

% % The identity substitution is reducible
% rec idRedSub : {g:ctx} RedSub [g] [g |- ..] =
% / total g (idRedSub g) /
% mlam g => case [g] of 
% | [ ] => Nil
% | [g',x:tm A[]] =>
%   Dot (wknRedSub (idRedSub [g']) (shiftIsVarSub [g']))
%       (reflect [g', x:tm A[]] [|- _ ] [g', x:tm A[] |- x ] (Var (IsVar [g',x:tm A[] |-  x])));

% -----------------------------------------------------------------------------
% Main Lemma: 
% If g |- M : A   and  h |- sigma : g   and sigma is reducible 
% then M[sigma] is reducible at type A in the context h.

rec eval : {M:[g |- tm A[]]} RedSub [g] [h |- #S ] -> Reduce [ |- A] [h |- M[#S] ] =
/ total m (eval g a h sigma m) /
mlam M => fn rs => let (rs : RedSub [g] [h |- #S] ) = rs in
 case [g |- M] of
| [g' |-  #p] => redVar [g'] [g' |-  #p] rs
| [g' |-  app M1 M2]  =>
  let Arr [h0 |- N1] f = eval [g' |-  M1]  rs in
   f [h] [h |- ..] [h |- _] (eval [g' |-  M2] rs)
| [g' |-  lam (\x. M1)] =>
   Arr [h |- lam (\x. M1[#S[..], x])]
   (mlam h',#W,N => fn rN =>
     closed [|- _ ] [h' |- _ ] [h' |- _ ] 
            [h' |-  s_beta] (eval [g',x:tm _ |-  M1] (Dot (wknRedSub [h' |- #W] rs) rN)));

% -----------------------------------------------------------------------------
% THEOREM: Well-typed terms halt. 

% #Id is a substitution which moves from a term context to a neutral term context in the obvious way
inductive IdSub : (g':nctx){g:ctx}{#Id:[g' |- g]} ctype =
| INil : IdSub [] [|- ^]
| ISnoc : IdSub [g] [g' |- #Id] -> IdSub [g,x:tm A[]] [g',b:block x:tm A[],y:neutral x |- #Id[..], b.1];

rec idLogSub : IdSub [g] [g' |- #Id] -> RedSub [g] [g' |- #Id] =
/ total r (idLogSub g g s r) /
fn r => case r of
| INil => Nil
| ISnoc r' =>
  Dot (wknRedSub [_,b:block x:tm _,y:neutral x |- ..] (idLogSub r'))
      (reflect [_] [|- _] [_ |- _] [_,b:block x:tm _,y:neutral x |- b.2])
;  

rec weakNorm : {M:[g |- tm A[]]} IdSub [g] [g' |- #Id] -> Halts  [ |- A] [g' |- M[#Id]] =
/ total (weakNorm) /
mlam M => fn s => reify [_] [|- _] [_ |- _] (eval [_ |- M] (idLogSub s));

% We probably want to show also that for any g:ctx there exists g':nctx and #Id:[g' |- g]
% such that IdSub [g] [g' |- #Id]...
