%{
Paths through lambda-calculus
(distinguishing normal forms from non-normal forms)
Author: Brigitte Pientka
}%

datatype tm: type =
| abs: (tm -> tm) -> tm
| app: tm -> tm -> tm
| beta: (tm -> tm) -> tm -> tm
;
%name tm M.

datatype nf: type =
| nabs: (nf -> nf) -> nf
| napp: nf -> nf -> nf
;
%name nf U.

datatype p : type =
| left : p -> p
| right: p -> p
| bnd  : (p -> p) -> p
;
%name p P.

datatype bred : tm -> nf -> type =
| r_abs : ({x:tm}{y:nf}  bred x y -> bred (M x) (N y))
       -> bred (abs M) (nabs N)
| r_app : bred M M' -> bred N N'
          -> bred (app M N) (napp M' N')
| r_beta: ({x:tm} ({u:nf} bred N u -> bred x u) -> bred (R x) V)
      -> bred (beta R N) V
;
%name bred R.

datatype path : tm -> p -> type =
| p_abs   : ({x:tm}{p:p} path x p -> path (M x) (P p))
               -> path (abs M) (bnd P)
| p_app_l : path M P
         -> path (app M N) (left P)
| p_app_r : path N P
         -> path (app M N) (right P)
| p_beta : ({x:tm}({q:p} path N q -> path x q) -> path (R x) P)
           -> path (beta R N) P
;

%name path Pf.

datatype npath : nf -> p -> type =
| np_abs   : ({x:nf}{p:p} npath x p -> npath (M x) (P p))
               -> npath (nabs M) (bnd P)
| np_app_l : npath M P
         -> npath (napp M N) (left P)
| np_app_r : npath N P
         -> npath (napp M N) (right P)

;
%name path Qf.

schema tctx = tm ;

schema rctx = block x:tm, y:nf, _r: bred x y +
              some [n:tm] block x:tm, _b: ({u:nf} bred n u -> bred x u) ;

schema pctx = block x:tm, p:p, _pt: path x p +
              some [n:tm] block x:tm, _b: ({q:p} path n q -> path x q);

schema jctx = block x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _npt: npath y p +
  some [n:tm] block x:tm, _b: ({u:nf} bred n u -> bred x u),
                          _d: ({q:p} path n q -> path x q) ;


rec bred_ltr :  (g:jctx) [g. bred (N ..) (V  ..)]
             -> [g.path (N ..) (P ..)] -> [g.npath (V ..) (P ..)]
    =
fn br => fn pt => case br of
| [g.#p.4 ..] => let [g.#p.5 ..] = pt in [g.#p.6 ..]
| [g.r_app (R1 ..) (R2 ..)] =>
    (case pt of
       | [g. p_app_l (Q1 ..)] =>
           let [g. Q1' .. ] = bred_ltr [g.R1 ..] [g. Q1 ..] in
           [g.np_app_l (Q1' ..)]
       | [g. p_app_r (Q2 ..)] =>
           let [g. Q2' .. ] = bred_ltr [g.R2 ..] [g. Q2 ..] in
           [g.np_app_r (Q2' ..)]
    )

| [g.r_abs (\x.\y.\u. R .. x y u)] =>
   let [g.p_abs (\x.\q.\qt. Q .. x q qt)] = pt in
   let [g, b:block (x:tm, q:p, y:nf, r: bred x y, qt: path x q, nq: npath y q) . Q' .. b.3 b.2 b.6] =
       bred_ltr [g, b:block (x:tm, q:p, y:nf, r: bred x y, qt: path x q, nq: npath y q ) . R .. b.1 b.3 b.4]
                [g,b . Q .. b.1 b.2 b.5]
   in
       [g.np_abs (\y.\q.\qt. Q' .. y q qt)]



| [g.r_beta (\x.\bf. R .. x bf)] =>
   let [g.p_beta (\x. \qf. Q .. x qf)] = pt in
   let [g, b:block (x:tm,  _b: ({u:nf} bred _ u -> bred x u), %% covers
                           _d: ({q:p} path _ q -> path x q)) . Q' .. ] =
       bred_ltr [g,b: block (x:tm,  _b: ({u:nf} bred _ u -> bred x u),
                           _d: ({q:p} path _ q -> path x q)) . R .. b.1 b.2]
                [g,b . Q .. b.1 b.3]
   in
       [g. Q' ..]


| {#p:[g. block (x:tm, _b:({u : nf}  bred (N ..) u -> bred x u), _q: ({q : p} path  (N ..) q -> path x q))]}
  [g. (#p.2 ..) (U ..) (R ..)] => % [g. bred x (U ..)]
   % R : bred (N ..) (U ..)
   % pt: path x (P ..)
  case pt of
    |{#p:[g. block (x:tm, _b:({u : nf}  bred (N ..) u -> bred x u), _q: ({q : p} path  (N ..) q -> path x q))]}
       [g. (#p.3 ..) (Q ..) (Qp ..)] => % [g. path x (Q ..)]
        % Qp : path (N ..) (Q ..)
          bred_ltr [g. R ..] [g. Qp ..] % path (U ..) (Q ..)

 ;

rec bred_rtl : (g:jctx)[g. bred (M ..) (U ..)] ->
               [g. npath (U ..) (P ..)] -> [g. path (M ..) (P ..)]
   =
fn br => fn pt => case br of
| [g.#p.4 ..] => let [g.#p.6 ..] = pt in [g.#p.5 ..]
| [g.r_app (R1 ..) (R2 ..)] =>
    (case pt of
       | [g. np_app_l (Q1 ..)] =>
           let [g. Q1' .. ] = bred_rtl [g.R1 ..] [g. Q1 ..] in
           [g.p_app_l (Q1' ..)]
       | [g. np_app_r (Q2 ..)] =>
           let [g. Q2' .. ] = bred_rtl [g.R2 ..] [g. Q2 ..] in
           [g.p_app_r (Q2' ..)]
    )

| [g.r_abs (\x.\y.\u. R .. x y u)] =>
   let [g.np_abs (\x.\q.\qt. Q .. x q qt)] = pt in
   let [g, b:block (x:tm, q:p, y:nf, r: bred x y, qt: path x q, nq: npath y q) . Q' .. b.1 b.2 b.5] =
       bred_rtl [g, b:block (x:tm, q:p, y:nf, r: bred x y, qt: path x q, nq: npath y q ) . R .. b.1 b.3 b.4]
                [g,b . Q .. b.3 b.2 b.6]
   in
       [g.p_abs (\y.\q.\qt. Q' .. y q qt)]



| [g.r_beta (\x.\bf. R .. x bf)] : [g. bred (beta (M ..) (N ..)) (U ..)] =>
  let [g. Qt ..] = pt in          % [g. npath (U ..) (P ..)]
  let [g, b:block (x:tm,  _b: ({u:nf} bred _ u -> bred x u), %% covers
                           _d: ({q:p} path _ q -> path x q)) . Q' .. b.1 b.3] =
       bred_rtl [g,b: block (x:tm,  _b: ({u:nf} bred (N ..) u -> bred x u),
                           _d: ({q:p} path (N ..) q -> path x q)) . R .. b.1 b.2]
                [g,b . Qt .. ]
   in
       [g. p_beta (\x. \qf. Q' .. x qf)]


| {#p:[g. block (x:tm, _b:({u : nf}  bred (N ..) u -> bred x u), _q: ({q : p} path  (N ..) q -> path x q))]}
  [g. (#p.2 ..) (U ..) (R ..)] => % [g. bred x (U ..)]
  let ([g. Pt ..] : [g.npath (U ..) (P ..)]) = pt in
  let [g.Qt ..] = bred_rtl [g. R ..] pt % path (N ..) (P ..)
  in [g. (#p.3 ..) (P ..) (Qt ..)]
 ;

datatype eq : tm -> tm -> type =
| ref : eq M M;

datatype nf_eq : nf -> nf -> type =
| nref : nf_eq M M;

datatype ExNPath : (g:jctx) [g.nf] -> ctype =
| ExPath : [g. npath (U ..) (P ..)] -> ExNPath [g.U ..] ;

rec path_exists : {g:jctx} {U:[g.nf] }  ExNPath [g.U ..] =
mlam g => mlam U => case [g.U ..] of
| [g.nabs \x. U .. x] =>
let {Ql: [g, x:nf, p:p, pt: npath x p . npath (U .. x) (P .. p)]}
    ExPath [g, b:block (x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _np: npath y p) . Ql .. b.3 b.2 b.6] =
    path_exists [g, b:block (x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _np:
                             npath y p) ]
               [g,b. U .. b.3]
in
    ExPath [g. np_abs \x.\p.\pt. Ql .. x p pt]

| [g. napp (U ..) (V ..)] =>
    let ExPath [g. Ql .. ] = path_exists [g] [g .U ..] in
    ExPath [g. np_app_l (Ql ..)]  % ???


| {#p: [g. block x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _np: npath y p]}
  [g.#p.3 ..] => ExPath [g. #p.6 ..]
;


rec tm_same: {g:jctx} {U:[g. nf ]} {V: [g. nf ]}
    ({P:[g.p]} [g. npath (U ..)(P ..)] -> [g. npath (V ..) (P ..)]) ->
     [g. nf_eq (U ..) (V ..)]
  =
mlam g => mlam U => mlam V => fn pf => case [g. U ..] of
| {#p: [g. block x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _np: npath y p]}
  [g. #p.3 ..] =>
  let [g.#q.6 ..] = pf [g.#p.2 ..] [g.#p.6 ..] in
  [g. nref ]

| [g.napp (U1 ..) (U2 ..)] =>
  let ExPath np = path_exists [g] [g.napp (U1 ..) (U2 ..)] in
  (case np of  % [g.npath (napp (U1 ..) (U2 ..)) (P ..)]
  | [g.np_app_l (Pf1 ..)] =>   %   [g. npath (napp (U1 ..) (U2 ..)) (left (P1 ..))]
    let ([g.np_app_l (Qt1 ..)]  : [g. npath (napp (V1 ..) (V2 ..)) (left (P1 ..))])
          = pf [g. left _ ] [g.np_app_l (Pf1 ..)] in
    let [g.nref] = tm_same  [g] [g. U1 ..] [g. V1 ..]
                   (mlam Q1 => fn qt1 =>
                    let [g.Pt1 ..] = qt1 in
                    let [g.np_app_l (Qt1 ..)]  = pf [g. left (Q1 ..) ] [g.np_app_l (Pt1 ..)] % [g. npath (V ..) (left (P1 ..))]
                    in [g. Qt1 ..]) in
    let [g.nref] = tm_same  [g] [g. U2 ..] [g. V2 ..]
                   (mlam Q1 => fn qt1 =>
                    let [g.Pt1 ..] = qt1 in
                    let [g.np_app_r (Qt1 ..)]  = pf [g. right (Q1 ..) ] [g.np_app_r (Pt1 ..)] % [g. npath (V ..) (left (P1 ..))]
                    in [g. Qt1 ..])
    in [g.nref]

 | [g. np_app_r (Pt2 ..)] => % [g. npath (napp (U1 ..) (U2 ..)) (right (P2 ..))]
    let ([g.np_app_r (Qt2 ..)] : [g. npath (napp (V1 ..) (V2 ..)) (right (P1 ..))])
            =  pf [g. right _ ] [g.np_app_r (Pt2 ..)] in

    let [g.nref] = tm_same  [g] [g. U1 ..] [g. V1 ..]
                   (mlam Q1 => fn qt1 =>
                    let [g.Pt1 ..] = qt1 in
                    let [g.np_app_l (Qt1 ..)]  = pf [g. left (Q1 ..) ] [g.np_app_l (Pt1 ..)] % [g. npath (V ..) (left (P1 ..))]
                    in [g. Qt1 ..]) in
    let [g.nref] = tm_same  [g] [g. U2 ..] [g. V2 ..]
                   (mlam Q1 => fn qt1 =>
                    let [g.Pt1 ..] = qt1 in
                    let [g.np_app_r (Qt1 ..)]  = pf [g. right (Q1 ..) ] [g.np_app_r (Pt1 ..)] % [g. npath (V ..) (left (P1 ..))]
                    in [g. Qt1 ..])
    in [g.nref]

   )

| [g.nabs \x. U .. x] =>
  let ExPath np = path_exists [g] [g.nabs \x.U .. x] in
  let  [g.np_abs (\x.\p.\pf. Pf .. x p pf)]  : [g.npath (nabs \x. U .. x) (bnd \p.P .. p)] = np in
  let ([g.np_abs (\x.\p.\pf.Qt1 .. x p pf)]  : [g.npath (nabs \y. V .. y) (bnd \p. P ..p)])
          = pf [g. bnd \p. P .. p] [g.np_abs (\x.\p.\pf. Pf .. x p pf)] in
  let [g,b:block (x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _npt: npath y p) . nref] =
                 tm_same [g,b:block (x:tm, p:p, y:nf, _r: bred x y, _pt: path x p, _npt: npath y p)]
                    [g,b. U .. b.3] [g,b. V .. b.3]
                    (mlam Q => fn qt =>
                      let [g, b: block (x:tm, p:p, y:nf, _r:  bred x y, _pt: path x p, _npt: npath y p) . Q' .. b.2 ] =
                             [g, b: block (x:tm, p:p, y:nf, _r:  bred x y, _pt: path x p, _npt: npath y p) . Q .. b] in
                      % strengthen Q
                      let [g, b: block (x:tm, p:p, y:nf, _r:  bred x y, _pt: path x p, _npt: npath y p) . Pt .. b.3 b.2 b.6] = qt in
                      let [g.np_abs  \y.\p.\pt. Qt .. y p pt ] = pf [g. bnd \b. Q' .. b] [g . np_abs \x.\p.\pt. Pt .. x p pt] in
                      [g,b: block (x:tm, p:p, y:nf, _r:  bred x y, _pt: path x p, _npt: npath y p) . Qt .. b.3 b.2 b.6]
                    )
  in
      [g.nref]
;


rec same_paths_join_c : {U:[.nf]}{V:[.nf]}
                      [. bred M U] -> [. bred N V] ->
                       ({P:[.p]} [. path M P] -> [. path N P])
                      -> [. nf_eq U V]
=
mlam U => mlam V => fn r1 => fn r2 => fn pf =>
 tm_same [] [.U] [.V]  (mlam P => fn l => bred_ltr r2 (pf [. P] (bred_rtl r1 l)))
 ;


rec same_paths_join : {g:jctx}{U:[g.nf]}{V:[g.nf]}
                      [g. bred (M ..) (U ..)] -> [g. bred (N ..) (V ..)] ->
                       ({P:[g.p]} [g. path (M ..) (P ..)] -> [g. path (N ..) (P ..)])
                      -> [g. nf_eq (U ..) (V ..)]
=
mlam g => mlam U => mlam V => fn r1 => fn r2 => fn pf =>
 tm_same  [g] [g.U ..] [g. V ..]
      (mlam P => fn l => bred_ltr r2 (pf [g. P ..] (bred_rtl r1 l)))
 ;


