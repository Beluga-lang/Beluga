%%% Admissibility of Cut in Intuitionistic Sequent Calculus
%%% Author: Frank Pfenning

ca : {A:o} conc A -> (hyp A -> conc C) -> conc C -> type.
%mode ca +A +D +E -F.

%% Axiom Conversions

ca_axiom_l : ca A (axiom H) E (E H).

ca_axiom_r : ca A D ([h] axiom h) D.

%% Essential Conversions

ca_and1 : ca (& A1 A2) (andr D1 D2) ([h] andl1 ([h1] E1 h h1) h) F
	   <- ({h1:hyp A1}
		 ca (& A1 A2) (andr D1 D2)
		 ([h] E1 h h1) (E1' h1))
	   <- ca A1 D1 E1' F.

ca_and2 : ca (& A1 A2) (andr D1 D2) ([h] andl2 ([h1] E2 h h1) h) F
	   <- ({h2:hyp A2}
		 ca (& A1 A2) (andr D1 D2)
		 ([h] E2 h h2) (E2' h2))
	   <- ca A2 D2 E2' F.

ca_imp  : ca (imp A1 A2) (impr D2) ([h] impl (E1 h) ([h2] E2 h h2) h) F
	   <- ca (imp A1 A2) (impr D2) E1 E1'
	   <- ({h2:hyp A2}
		 ca (imp A1 A2) (impr D2)
		 ([h] E2 h h2) (E2' h2))
	   <- ca A1 E1' D2 D2'
	   <- ca A2 D2' E2' F.

ca_or1  : ca (or A1 A2) (orr1 D1) ([h] orl ([h1] E1 h h1) ([h2] E2 h h2) h) F
	   <- ({h1:hyp A1}
		 ca (or A1 A2) (orr1 D1)
		 ([h] E1 h h1) (E1' h1))
	   <- ca A1 D1 E1' F.
ca_or2  : ca (or A1 A2) (orr2 D2)
	   ([h] orl ([h1] E1 h h1) ([h2] E2 h h2) h) F
	   <- ({h2:hyp A2}
		 ca (or A1 A2) (orr2 D2)
		 ([h] E2 h h2) (E2' h2))
	   <- ca A2 D2 E2' F.

ca_not  : ca (not A1) (notr D1)
	   ([h] notl (E1 h) h) (F2 C)
	   <- ca (not A1) (notr D1) E1 F1
	   <- ({p:o} ca A1 F1 ([h1] D1 p h1) (F2 p)).


ca_forall : ca (forall A1) (forallr D1)
	     ([h] foralll T ([h1] E1 h h1) h) F
	     <- ({h2:hyp (A1 T)}
		   ca (forall A1) (forallr D1)
		   ([h] E1 h h2) (E1' h2))
	     <- ca (A1 T) (D1 T) E1' F.


ca_exists : ca (exists ([x] A1 x)) (existsr T D1)
	     ([h] existsl ([a][h1] E1 h a h1) h) F
	     <- ({a:i} {h1:hyp (A1 a)}
		   ca (exists A1) (existsr T D1)
		   ([h] E1 h a h1) (E1' a h1))
	     <- ca (A1 T) D1 ([h1] E1' T h1) F.



%% Left Commutative Conversions

cal_andl1  : ca A (andl1 D1 H) E (andl1 D1' H)
	      <- {h1:hyp B1} ca A (D1 h1) E (D1' h1).

cal_andl2  : ca A (andl2 D2 H) E (andl2 D2' H)
	      <- {h2:hyp B2} ca A (D2 h2) E (D2' h2).

cal_impl   : ca A (impl D1 D2 H) E (impl D1 D2' H)
	      <- ({h2:hyp B2} ca A (D2 h2) E (D2' h2)).

cal_orl    : ca A (orl D1 D2 H) E (orl D1' D2' H)
	      <- ({h1:hyp B1} ca A (D1 h1) E (D1' h1))
	      <- ({h2:hyp B2} ca A (D2 h2) E (D2' h2)).

cal_notl   : ca A (notl D1 H) E (notl D1 H).

cal_falsel  : ca A (falsel H) E (falsel H).

cal_foralll : ca A (foralll T D1 H) E (foralll T D1' H)
	       <- ({h:hyp _} ca A (D1 h) E (D1' h)).

cal_existsl : ca A (existsl D1 H) E (existsl D1' H)
	       <- ({a:i} {h:hyp (B1 a)}
		     ca A (D1 a h) E (D1' a h)).


%% Right Commutative Conversions

% was commented out
car_axiom : ca A D ([h] axiom H1) (axiom H1).

car_andr : ca A D ([h] andr (E1 h) (E2 h)) (andr E1' E2')
	    <- ca A D E1 E1'
	    <- ca A D E2 E2'.

car_andl1: ca A D ([h] andl1 ([h1] E1 h h1) H) (andl1 ([h1] E1' h1) H)
	    <- ({h1:hyp B1} ca A D ([h] E1 h h1) (E1' h1)).

car_andl2: ca A D ([h] andl2 ([h1] E2 h h1) H) (andl2 ([h] E2' h) H)
	    <- ({h2:hyp B2} ca A D ([h] E2 h h2) (E2' h2)).

car_impr : ca A D ([h] impr ([h1] E2 h h1)) (impr E2')
	    <- ({h1:hyp B1} ca A D ([h] E2 h h1) (E2' h1)).

car_impl : ca A D ([h] impl (E1 h) ([h1] E2 h h1) H) (impl E1' E2' H)
	    <- ca A D E1 E1'
	    <- ({h2:hyp B2} ca A D ([h] E2 h h2) (E2' h2)).


car_orr1 : ca A D ([h] orr1 (E1 h)) (orr1 E1')
	    <- ca A D E1 E1'.

car_orr2 : ca A D ([h] orr2 (E2 h)) (orr2 E2')
	    <- ca A D E2 E2'.

car_orl  : ca A D ([h] orl ([h1] E1 h h1) ([h2] E2 h h2) H) (orl E1' E2' H)
	    <- ({h1:hyp B1} ca A D ([h] E1 h h1) (E1' h1))
	    <- ({h2:hyp B2} ca A D ([h] E2 h h2) (E2' h2)).

car_notr : ca A D ([h] notr ([p][h1] E1 h p h1)) (notr E1')
	    <- ({p:o} {h1:hyp B1} ca A D ([h] E1 h p h1) (E1' p h1)).

car_notl : ca A D ([h] notl (E1 h) H) (notl E1' H)
	    <- ca A D E1 E1'.

car_truer: ca A D ([h] truer) (truer).

car_falsel : ca A D ([h] falsel H) (falsel H).

car_forallr : ca A D ([h] forallr ([a] E1 h a)) (forallr ([a] E1' a))
	       <- ({a:i} ca A D ([h] E1 h a) (E1' a)).

car_foralll: ca A D ([h] foralll T ([h1] E1 h h1) H) (foralll T ([h] E1' h) H)
	      <- ({h1:hyp _} ca A D ([h] E1 h h1) (E1' h1)).

car_existsr : ca A D ([h] existsr T (E1 h)) (existsr T E1')
	       <- ca A D E1 E1'.

car_existsl : ca A D ([h] existsl ([a][h1] E1 h a h1) H) (existsl ([a][h1] E1'  a h1) H)
	       <- ({a:i} {h1:hyp (B1 a)}
		     ca A D ([h] E1 h a h1) (E1' a h1)).





%block l1 : some {A:o} block {h:hyp A}.
%block l2 : block {a:i}.
%block l3 : block {p:o}.
%worlds (l1 | l2 | l3) (ca A D E F).
%covers ca +A +D +E -F.
%terminates {A [D E]} (ca A D E _).
%total {A [D E]} (ca A D E _).
