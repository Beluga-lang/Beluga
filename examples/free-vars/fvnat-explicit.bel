tp: type.
nat: tp.
bool: tp.

exp : tp -> type.
z   : exp nat.
suc : exp nat -> exp nat.
andalso : exp bool -> exp bool -> exp bool.
tt  : exp bool.
ff  : exp bool.

opt: type.

nothing: opt.

something: {T:tp} exp T -> opt.

schema expCtx = some [t:tp] exp t;

rec free_var : {g:(expCtx)*} {T::tp[ ]} (exp T)[g] -> opt[g] =
FN g => mlam T => fn e => 
 (case e of
    [g] z            : (exp nat)[g]   => [g] nothing
  | [g] tt           : (exp bool)[g]  => [g] nothing
  | [g] ff           : (exp bool)[g]  => [g] nothing

 | {T'::tp[ ]} {#p::(exp T')[g]}
    [g] (#p ..)     : (exp T')[g] => [g] something T' (#p ..)

  | {U::(exp nat)[g]}
    [g] suc (U ..) : (exp nat)[g]   => free_var [g] < . nat >  ([g] (U ..))

 | {U::(exp bool)[g]} {V::(exp bool)[g]}
    [g] andalso (U ..) (V ..) : (exp bool)[g]  => 

       (case free_var [g] < . bool > ([g] (U ..)) of
          [g] nothing                : opt[g] => free_var [g] < . bool > ([g] (V ..))

       | {T'::tp[ ]} {#p::(exp T')[g]}
          [g] something T' (#p ..) : opt[g] => [g] something T' (#p ..)
	   )
);
