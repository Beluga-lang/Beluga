% Type-preserving substitution-based interpreter
%
% Author: Brigitte Pientka
%
% TODO extend with functions and function application

tp   : type.
nat  : tp.
bool : tp.

exp  : tp -> type.  

tt   : exp bool.
ff   : exp bool.

z    : exp nat.
suc  : exp nat -> exp nat.
eq   : exp nat -> exp nat -> exp bool.

iff   : exp bool -> exp T -> exp T -> exp T.
letv :  exp T1 -> (exp T1 -> exp T2) -> exp T2.

rec equal : (exp nat)[ ] -> (exp nat)[ ] -> (exp bool)[ ] =
fn x => fn y => 
  case x of
    [ ] z  => 
      (case y of
          [ ] z     => [ ] tt
        | [ ] suc U => [ ] ff)

  | [ ] suc U => 
      (case y of
         [ ]  z      => [ ] ff
      |  [ ]  suc V  => equal ([ ] U) ([ ] V))
;




rec eval : (exp T)[ ] -> (exp T)[ ] = 
 fn e => case e of 
  | [ ] tt => [ ] tt

  | [ ] ff => [ ] ff

  | [ ] z  => [ ] z

  | [ ] suc U => 
    let [ ] V  = eval ([ ] U) in [ ] suc V   

  | [ ]  eq U V =>
    equal (eval ([ ] U))  (eval  ([ ] V))

  | [ ] iff  U V W  =>
    (case eval ([ ] U) of
       [ ] tt => eval ([ ] V)
     | [ ] ff => eval ([ ] W)
     )

   | [ ] letv  U (\x . (W x))  =>
   let [ ] V = eval ([ ] U) in eval ([ ] (W V))
;

let y1 = eval ([ ] suc z) ;

let x1 = eval ([ ] z) ;



let y2 = eval ([ ] tt);

let y3 = eval ([ ] iff tt (suc z) z) ;

let a1 = equal ([ ] suc z) ([ ] suc z) ;
let a2 = equal (eval ([ ] suc z)) (eval ([ ] suc z)) ;

let a2 = (equal y1) y1;

let y4 = eval ([ ] eq (suc z) (suc z)) ;

let y5 = eval ([ ] letv (iff tt (suc z) z) (\y. iff (eq y (suc z)) (suc y) y)) ;

