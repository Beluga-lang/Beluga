%%% Lemmas concerning ordinary multi-step reduction
%%% Author: Frank Pfenning
%%% Adapted to Beluga: Brigitte Pientka

% Terms can contain free variables without explicit
% assumptions about them (for multi-step reduction)

%block ltm : block {x:term}.
schema tctx = term;

% Transitivity of multi-step reduction
rec appd: (g:tctx) [g |- -->* (M ..) (M'..)]  ->  [g |- -->*  (M' ..) (M'' ..)]
        ->  [g |- -->* (M ..) (M'' ..)] =
fn r => fn s => case r of
| [g |- id1] => s
| [g |- step1 (R1 ..) (R2* ..)] =>
  let [g |- S2*' ..] = appd [g |- R2* .. ] s in
    [g |- step1 (R1 ..) (S2*' ..)]

;

% Multi-step reduction is a congruence
rec lm1* : (g:tctx) [g,x:term |-  -->* (M .. x) (M' .. x)]
      ->  [g |- -->* (lam (\x. M .. x)) (lam (\x. M' .. x))] =
fn r => case r of
| [g,x:term |-  id1] => [g |- id1]
| [g,x:term |-  step1 (R1 .. x) (R2* .. x)] =>
  let [g |- S2* ..] = lm1* [g,x |- R2* .. x] in
    [g |- step1 (lm1 \x. R1 .. x) (S2* ..)]
;


rec apl1* :(g:tctx) {M2:[g |- term]} [g |- -->* (M1 ..) (M1' ..)]
                 ->  [g |- -->*  (app (M1 ..) (M2 ..)) (app (M1' ..) (M2 ..))] =
mlam M2 => fn r => case r of
| [g |- id1] => [g |- id1]
| [g |- step1 (R1 ..) (R2* ..)] =>
  let [g |- S2* ..] = apl1* [g |- M2 .. ] [g |- R2* ..] in
    [g |- step1 (apl1 (R1 .. )) (S2* ..)]
;

rec apr1* :(g:tctx){M1:[g |- term]} [g |- -->* (M2 ..) (M2' ..)]
                 ->  [g |- -->*  (app (M1 ..) (M2 ..)) (app (M1 ..) (M2' ..))] =
mlam M1 => fn r => case r of
| [g |- id1] => [g |- id1]
| [g |- step1 (R1 ..) (R2* ..)] =>
  let [g |- S2* ..] = apr1* [g |- M1 .. ] [g |- R2* ..] in
    [g |- step1 (apr1 (R1 .. )) (S2* ..)]
;

