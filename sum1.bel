nat : type.     
z : nat.
s : nat -> nat.

add : nat -> nat -> nat -> type. 
a_z : {R:nat} add z R R.
a_s : add N1 N2 N3 -> add (s N1) N2 (s N3).


less : nat -> nat -> type. 
l_one : {N:nat} less N (s N). 
l_trans : less N M -> less M O -> less N O.

rec sumzr1 : {N::nat []} (add N z N) [] =
mlam N => case ([] N) of
 | [] z => [] (a_z N)
 | [] (s N) => 
   let [] F = sumzr1 < . N> in
     [] a_s F
;
%{ try to get this to work
rec plus3 : {N::nat []} (add (s (s (s z))) N (s (s (s N)))) [] =
mlam N => let [] E = [] (a_z N) in let [] F = [] (a_s E) in let [] G = [] (a_s F) in [] (a_s G)
;
}%

rec zless :  (less z (s z)) []  = [] l_one z
;

rec ssless : {N::nat []} (less N (s(s N))) [] =
mlam N =>
 let [] E = [] (l_one N) in
 let [] F = [] l_one (s N) in
 [] l_trans E F
;
  
rec sumzr : {N::nat []} (add N z N) [] =
mlam N => case ([] N) of
 | [] z => [] (a_z z)
 | [] (s N) => 
   let [] F = sumzr < . N> in
     [] a_s F
;

rec sumsr :{D1::(add Nat1 Nat2 Nat3)[]} (add Nat1 (s Nat2) (s Nat3))[] =
mlam D1 => case ([] D1) of
 | [] a_z E => [] (a_z (s E))
 | [] a_s I =>
   let [] H = sumsr < . I> in
     [] a_s H
;

let v2 = sumzr < . z>;

rec sumcom : {A::(add M N O)[]} (add N M O) [] =
mlam A => case ([] A) of
 | [] a_z E => sumzr < . E>
 | [] a_s F => 
    let [] G = sumcom < . F> in
       sumsr < . G>
;
