% Type-preserving substitution-based interpreter
%
% Author: Brigitte Pientka
%

tp   : type.
nat  : tp.
bool : tp.
arr  : tp -> tp -> tp.

exp  : tp -> type.  

tt   : exp bool.
ff   : exp bool.

z    : exp nat.
suc  : exp nat -> exp nat.
% eq   : exp nat -> exp nat -> exp bool.

iff  : exp bool -> exp T -> exp T -> exp T.
letv :  exp T1 -> (exp T1 -> exp T2) -> exp T2.

lam  : (exp T1 -> exp T2) -> exp (arr T1 T2).


rec typeCase : {T::tp[ ]} (exp T)[ ] -> (exp T)[ ] = 
mlam T => fn e => case [ ] T of  
   [ ] nat => (case e of [ ] z   => [ ] z 
                       | [ ] suc U => e
                       | [ ] suc U => let [ ] V = typeCase <. nat> ([ ] U) in [ ] suc V
              ) 
 | [ ] bool => (case e of [ ] tt => [ ] tt
                        | [ ] ff => [ ] ff
               ) 

 | [ ] arr S' S => 
   let [ ] lam (\x. E x) = e  in [ ] lam (\x. E x)
;
