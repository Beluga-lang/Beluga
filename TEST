#!/bin/bash

usage() {
    echo "Usage: $0 [test-options] -- [beluga-options]"
    echo
    echo "Synopsis: test harness for Beluga."
    echo
    echo "Notes:"
    echo "    - Pure LF signatures are in files sources.cfg."
    echo "    - Proofs written in Beluga are in test.cfg."
    echo "    - Files ending in .bel contain Beluga programs."
    echo "    - If a test.cfg file is found in a subdirectory, only it will be tested."
    echo "    - If no test.cfg file is found, all .bel files in the subdirectory"
    echo "      will be tested."
    echo "    - To inhibit testing .bel files, put an empty test.cfg in that directory."
}

echo "Parameters for this run (override as necessary using environment variables):"
echo

# Path to the Beluga source distribution.
echo -e "\t" BELUGADIR: ${BELUGADIR:=$(dirname $0)}

# Set $EXE to the executable to test.
echo -e "\t" EXE: ${EXE:=$BELUGADIR/bin/interpreter}

# Test scripts.
echo -e "\t" TESTDIR: ${TESTDIR:=$BELUGADIR/examples}

# Time limit.
echo -e "\t" TIMEOUT: ${TIMEOUT:=2} seconds

echo

# Find test cases.
test_cases() {
    for dir in $(find $TESTDIR -type d)
    do
	[[ -f $dir/sources.cfg ]] && echo $dir/sources.cfg
	if [[ -f $dir/test.cfg ]]
	then
	    echo $dir/test.cfg
	else
	    find $dir/ -maxdepth 1 -name '*.bel' -type f
	fi
    done
}

sort_cases() {
    cases=($(</dev/stdin))
    cases_cfg=($(find ${cases[@]} -name '*.cfg'))
    cases_bel=($(find ${cases[@]} -name '*.bel'))
    # Need to count lines explicitly for compatibily with BSD head.
    echo ${cases_bel[@]} | xargs wc -c | head -n ${#cases_bel[@]} | sort -n | awk '{print $2}'
    find ${cases_cfg[@]}
}

do_testing() {
    local n=0 success=0 fail=0 timeout=0

    # Limit runtime of each test case, in seconds.
    ulimit -t $TIMEOUT

    for i in $(test_cases | sort_cases)
    do
	n=$((n+1))
	echo -ne "${C[start]}**$CEND TEST $n: $i ... "

	result=$($EXE -noprint $* $i 2>&1)
	exit_code=$?
	if [[ $exit_code -eq 0 ]]
	then
	    echo -e "${C[done]}DONE$CEND"
	    success=$((success+1))
	elif [[ $exit_code -eq 137 ]]
	then
	    echo -e "${C[timeout]}TIMEOUT$CEND"
	    timeout=$((timeout+1))
	else
	    echo -e "${C[fail]}FAIL$CEND"
	    echo "$result"
	    fail=$((fail+1))
	fi
    done

    echo
    echo Successes: $success
    echo Failures: $fail
    echo Timeouts: $timeout
    echo Total: $n

    echo
    times

    # If not all tests succeeded then exit with non-zero status.
    [[ $success -eq $n ]] || exit 1
    exit 0
}

GETOPT=$(getopt -o hc --long help,colour,color -n $0 -- "$@")

# Bail out if argument parsing failed.
[[ $? != 0 ]] && exit 2

eval set -- "$GETOPT"

while true
do
    case "$1" in
	-h|--help)
	    usage
	    exit 0
	    ;;
	-c|--colour|--color)
	    CEND="\e[0m"
	    typeset -A C
	    C=( [start]="\e[0;34m"
		[done]="\e[1;32m"
	        [timeout]="\e[1;35m"
		[fail]="\e[1;31m" )
	    shift
	    ;;
	--)
	    shift
	    break
	    ;;
    esac
done

do_testing $*
