% Completeness of algorithmic equality for declarative equality (beta eta equivalence)

tp : type.                %name tp T.
i :  tp.
arr: tp -> tp -> tp.

tm : type.          %name tm E.
app : tm -> tm -> tm.
lam : (tm -> tm) -> tm.

oft : tm -> tp -> type.
of/app : oft M (arr T S) -> oft N T -> oft (app M N) S.
of/lam : ({x:tm} oft x T -> oft (M x) S) -> oft (lam M) (arr T S).

schema ctx = tm;
schema tctx = some [t:tp] block x:tm,y:oft x t;

mstep : tm -> tm -> type.  %name mstep S.
beta : mstep (app (lam M) N) (M N).
stepapp : mstep M M' -> mstep (app M N) (app M' N').
refl : mstep M M.
trans : mstep M M' -> mstep M' M'' -> mstep M M''.


% I suspect we could allow g' to be longer than g everywhere...
datatype CtxRel : {g:tctx}{g':ctx} ctype =
| RNil : CtxRel [] []
| RCons : CtxRel [g] [g'] -> CtxRel [g,b:block x:tm,d:oft x T] [g',x:tm];

datatype Lookup : {g:tctx}(g':ctx) {A:[.tp]}{M:[g'. tm]} ctype =
| Top : Lookup [g,b:block x:tm,y:oft x T] [. T] [g',x:tm. x]
| Pop : Lookup [g] [. T] [g'. M ..]
      -> Lookup [g,b:block x:tm,y:oft x S] [.T] [g',x:tm. M ..];

% Interesting that it looks like we needed to code up what it means to check
% equivalence of variables
% datatype EqV : {g:tctx}(g':ctx) {A:[.tp]}{M:[g'. tm]}{N:[g'. tm]} ctype =
% | Top : EqV [g,b:block x:tm,y:oft x T] [. T] [g',x:tm. x] [g',x:tm. x]
% | Pop : EqV [g] [. T] [g'. #p ..] [g'. #q ..]
%       -> EqV [g,b:block x:tm,y:oft x S] [.T] [g',x:tm. #p ..] [g',x:tm. #q ..];

% Think of g' as an output
datatype AlgEqN : {g:tctx}(g':ctx){A:[.tp]}{M:[g'. tm]} {N:[g'.tm]} ctype =
| AlgBase : [g'. mstep (M ..) (P ..)]
          -> [g'. mstep (N ..) (Q ..)]
          -> AlgEqR [g] [. i] [g'. P ..] [g'. Q ..]
          -> AlgEqN [g] [. i] [g'. M ..] [g'. N ..]
| AlgArr :  AlgEqN [g,b:block x:tm,d:oft x T] [. S] [g',x:tm. app (M ..) x] [g',x. app (N ..) x]
          -> AlgEqN [g] [. arr T S] [g'. (M ..)] [g'. (N ..)]
% The type A is output
and      AlgEqR : {g:tctx}(g':ctx){A:[.tp]}{M:[g'. tm]} {N:[g'.tm]} ctype =
| AlgVar : % {#p:[g'. tm]}
           Lookup [g] [. T] [g'. #p ..]
         -> AlgEqR [g] [. T] [g'. #p ..] [g'. #p ..]
| AlgApp : AlgEqR [g] [. arr T S] [g'. M1 ..] [g'. M2 ..]
         -> AlgEqN [g] [. T] [g'. N1 ..] [g'. N2 ..]
         -> AlgEqR [g] [. S] [g'. app (M1 ..) (N1 ..)] [g'. app (M2 ..) (N2 ..)]
;

datatype IsVarSub : {g:tctx}{g':ctx}{h:tctx}(h':ctx) {#S: g'[h']}ctype =
| Nil : IsVarSub [] [] [h] [h' $ ^ ]
| Cons :  IsVarSub [g] [g'] [h] [h' $ #S[..]] -> Lookup [h] [. A] [h'. M ..]
         -> IsVarSub [g,b:block x:tm,y:oft x A] [g',x:tm] [h] [h' $ #S[..] (M ..)];

datatype LogEq : {g:tctx}(g':ctx) {A:[.tp]}{M:[g'. tm]}{N:[g'. tm]} ctype =
| LogBase : AlgEqN [g] [. i] [g'. M ..] [g'. N ..]
          -> LogEq [g] [. i] [g'. M ..] [g'. N ..]
| LogArr  : {M1:[g'.tm]}{M2:[g'.tm]}
             ({h:tctx}{h':ctx} {#R:g'[h']} {N1:[h'.tm]}{N2:[h'.tm]}
                CtxRel [h] [h'] ->
                IsVarSub [g] [g'] [h] [h' $ #R[..]] ->
                LogEq [h] [. T] [h'. N1 ..] [h'. N2 ..]
              -> LogEq [h] [. S] [h'. app (M1 #R[..]) (N1 ..)] [h'. app (M2 #R[..]) (N2 ..)])
            -> LogEq [g] [. arr T S] [g'. M1 ..] [g'. M2 ..]
;

% Obviously false without fact that #W is weakening and well-typed
rec algEqR_Monotone : {g':ctx}{#W:g'[h']} AlgEqR [g] [. A] [g'. M1 ..] [g'. M2 ..]
                                -> AlgEqR [h] [. A] [h'. M1 #W[..]] [h'. M2 #W[..]] =
mlam g' => mlam #W => fn r => case r of
%| AlgVar [g'. #p..] [g'. #q..] v => ? % TODO: Need to actually enforce that #W is var-for-var
| AlgApp r' n' => ?
;

rec wknVarSub : IsVarSub [g] [g'] [h] [h' $ #S[..]]
 -> IsVarSub [g] [g'] [h,b:block x:tm,y:oft x T] [h',x:tm $ #S[..] ] =
fn r => case r of
| Nil => Nil
| Cons r' v => Cons (wknVarSub r') (Pop v);

rec extVarSub : IsVarSub [g] [g'] [h] [h' $ #S[..]]
 -> IsVarSub [g,b:block x:tm,y:oft x A] [g',x:tm] [h,b:block x:tm,y:oft x A] [h',x:tm $ #S[..] x ] =
fn r => let r : IsVarSub [g] [g'] [h] [h' $ #S[..]] = r in Cons (wknVarSub r) Top;

rec idIsVarSub : CtxRel [g] [g'] -> IsVarSub [g] [g'] [g] [g' $ .. ] =
fn r => case r of
| RNil => Nil
| RCons r' => extVarSub (idIsVarSub r');

rec shiftIsVarSub : CtxRel [g] [g'] -> IsVarSub [g] [g'] [g,b:block x:tm,y:oft x A] [g',x:tm $ .. ] =
fn r => wknVarSub (idIsVarSub r);

rec reflect : {A:[.tp]} AlgEqR [g] [. A] [g'. M1 ..] [g'. M2 ..] -> LogEq [g] [. A] [g'. M1 ..] [g'. M2 ..] =
mlam A => fn r => let r : AlgEqR [g] [. A] [g'. M1 ..] [g'. M2 ..] = r in case [. A] of
| [.i] => LogBase (AlgBase [g'. refl] [g'. refl] r)
| [. arr A B] =>
  LogArr [g'. M1 ..] [g'. M2 ..]
   (mlam h => mlam h' => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
    reflect [. B] (AlgApp (algEqR_Monotone [g'] [h' $ #W[..]] r) (reify rh rn))
   )
and reify : CtxRel [g] [g'] -> LogEq [g] [. A] [g'. M1 ..] [g'. M2 ..] -> AlgEqN [g] [. A] [g'. M1 ..] [g'. M2 ..] =
fn r => fn e => let e : LogEq [g] [. A] [g'. M1 ..] [g'. M2 ..] = e in case e of
| LogBase a => a
| LogArr [g'. M1 ..] [g'. M2 ..] f =>
  AlgArr (reify (RCons r) (f [g,b:block x:tm,y:oft x _] [g',x:tm] [g',x $ ..] [g',x. x] [g',x. x]
                 (RCons r) (shiftIsVarSub r) (reflect [._] (AlgVar Top))))
;

datatype DecEq : {g:tctx}(g':ctx) {A:[.tp]}{M:[g'. tm]} {N:[g'.tm]} ctype =
| DecBeta : DecEq [g,b:block x:tm,d:oft x T] [. S] [g',x:tm. M2 .. x] [g',x. N2 .. x]
          -> DecEq [g] [. T] [g'. M1 ..] [g'. N1 ..]
          -> DecEq [g] [. S] [g'. (app (lam (\x. M2 .. x)) (M1 ..))] [g'. N2 .. (N1 ..)]
| DecLam :  DecEq [g,b:block x:tm,d:oft x T] [. S] [g',x:tm. M .. x] [g',x. N .. x]
          -> DecEq [g] [. arr T S] [g'. lam (\x. M .. x)] [g'. lam (\x. N .. x)]
| DecExt :  DecEq [g,b:block x:tm,d:oft x T] [. S] [g',x:tm. app (M ..) x] [g',x. app (N ..) x]
          -> DecEq [g] [. arr T S] [g'. (M ..)] [g'. (N ..)]
| DecVar : % {#p:[g'. tm]}{#q:[g'.tm]}
           Lookup [g] [. T] [g'. #p ..]
         -> DecEq [g] [. T] [g'. #p ..] [g'. #p ..]
| DecApp : DecEq [g] [. arr T S] [g'. M1 ..] [g'. M2 ..]
         -> DecEq [g] [. T] [g'. N1 ..] [g'. N2 ..]
         -> DecEq [g] [. S] [g'. app (M1 ..) (N1 ..)] [g'. app (M2 ..) (N2 ..)]
| DecSym : DecEq [g] [. T] [g'. M ..] [g'. N ..]
         -> DecEq [g] [. T] [g'. N ..] [g'. M ..]
| DecTrans : DecEq [g] [. T] [g'. M ..] [g'. N ..]
           -> DecEq [g] [. T] [g'. N ..] [g'. O ..]
           -> DecEq [g] [. T] [g'. M ..] [g'. O ..]
;

% Could we actually say #S1:g'[h] and let subordination do that part?
datatype LogEqSub : {g:tctx}{g':ctx}{h:tctx}(h':ctx){#S1:g'[h']}{#S2:g'[h']} ctype =
| Nil : %CtxRel [h] [h'] -> % Is this necessary?
        LogEqSub [] [] [h] [h' $ ^] [h' $ ^]
| Dot : LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]] -> LogEq [h] [. T] [h'. M1 ..] [h'. M2 ..]
      -> LogEqSub [g,b:block x:tm,d:oft x T] [g',x:tm] [h] [h' $ #S1[..] (M1 ..)] [h' $ #S2[..] (M2 ..)]
;

% % TODO: This is also false. Need to say that #W is var-for-var and well-typed
rec wknLogEqSub : {h0:tctx}{h':ctx}{#W:h'[h0']} % {#S1:g'[h']}{#S2:g'[h']}
                               LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]]
                             -> LogEqSub [g] [g'] [h0] [h0' $ #S1[#W[..]]] [h0' $ #S2[#W[..]]] =
?
;

rec closed : {S1:[g'. mstep (N1 ..) (M1 ..)]} {S2:[g'. mstep (N2 ..) (M2 ..)]}
    LogEq [g] [. T] [g'. M1 ..] [g'. M2 ..]
  -> LogEq [g] [. T] [g'. N1 ..] [g'. N2 ..] =
mlam S1 => mlam S2 => fn e => case e of
| LogBase (AlgBase [g'. S1' ..] [g'. S2' ..] a) =>
  LogBase (AlgBase [g'. trans (S1 ..) (S1' ..)] [g'. trans (S2 ..) (S2' ..)] a)
| LogArr [g'. M1 ..] [g'. M2 ..] f =>
  LogArr [g'. _] [g'. _] (mlam h => mlam h' => mlam #W => mlam P1 => mlam P2 => fn rh => fn iv => fn rp =>
   let q0 = f [h] [h'] [h' $ #W[..]] [h'. P1 ..] [h'. P2 ..] rh iv rp in
   closed [h'. stepapp (S1 #W[..])] [h'. stepapp (S2 #W[..])] q0
  )
;

rec lookup : Lookup [g] [. T] [g'. M1 ..]
 -> LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]]
 -> LogEq [h] [. T] [h'. M1 #S1[..]] [h'. M1 #S2[..]] =
fn v => fn s => case v of
| Top =>    let Dot s' e = s in e
| Pop v' => let Dot s' e = s in lookup v' s'
;

rec algEqRSym :
  AlgEqR [g] [. T] [g'. N1 ..] [g'. N2 ..]
-> AlgEqR [g] [. T] [g'. N2 ..] [g'. N1 ..] =
fn a => case a of
| AlgVar v => AlgVar v
| AlgApp a1 a2 => AlgApp (algEqRSym a1) (algEqNSym a2)
and algEqNSym :
  AlgEqN [g] [. T] [g'. N1 ..] [g'. N2 ..]
-> AlgEqN [g] [. T] [g'. N2 ..] [g'. N1 ..] =
fn a => case a of
| AlgBase s1 s2 a' => AlgBase s2 s1 (algEqRSym a')
| AlgArr a' => AlgArr (algEqNSym a')
;

rec logEqSym :
   LogEq [g] [. T] [g'. M1 ..] [g'. M2 ..]
 -> LogEq [g] [. T] [g'. M2 ..] [g'. M1 ..] =
fn e => case e of
| LogBase a => LogBase (algEqNSym a)
| LogArr [g'. M1 ..] [g'. M2 ..] f =>
  LogArr [g'. M2 ..] [g'. M1 ..] (mlam h => mlam h' => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
   logEqSym (f [h] [h'] [h' $ #W[..]] [h'. N2 ..] [h'. N1 ..] rh iv (logEqSym rn))
  )
;

rec logEqSubSym :
   LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]]
 -> LogEqSub [g] [g'] [h] [h' $ #S2[..]] [h' $ #S1[..]] =
fn e => case e of
| Nil => Nil
| Dot e' e1 => Dot (logEqSubSym e') (logEqSym e1)
;

datatype EqTp : [.tp] -> [.tp] -> ctype =
| ReflTp : EqTp [. T] [. T];

rec varEqUnique :
  Lookup [g] [. T] [g'. M ..]
-> Lookup [g] [. S] [g'. M ..]
-> EqTp [. T] [. S] =
fn e1 => fn e2 => case (e1,e2) of
| (Top,Top) => ReflTp
| (Pop e1', Pop e2') => varEqUnique e1' e2'
;

rec algEqRUnique :
  AlgEqR [g] [. T] [g'. N1 ..] [g'. N2 ..]
-> AlgEqR [g] [. S] [g'. N2 ..] [g'. N3 ..]
-> EqTp [. T] [. S] =
fn e1 => fn e2 => case (e1,e2) of
| (AlgVar e1', AlgVar e2') =>
  varEqUnique e1' e2'
| (AlgApp a1 a2, AlgApp b1 b2) =>
  let ReflTp = algEqRUnique a1 b1 in ReflTp
;

rec algEqRTrans :
  AlgEqR [g] [. T] [g'. N1 ..] [g'. N2 ..]
-> AlgEqR [g] [. T] [g'. N2 ..] [g'. N3 ..]
-> AlgEqR [g] [. T] [g'. N1 ..] [g'. N3 ..] =
fn a1 => fn a2 => case (a1,a2) of
| (AlgVar e1, AlgVar e2) =>
  AlgVar e1
| (AlgApp a1' b1, AlgApp a2' b2) =>
  let ReflTp = algEqRUnique a1' a2' in
  AlgApp (algEqRTrans a1' a2') (algEqNTrans b1 b2)
and algEqNTrans :
  AlgEqN [g] [. T] [g'. N1 ..] [g'. N2 ..]
-> AlgEqN [g] [. T] [g'. N2 ..] [g'. N3 ..]
-> AlgEqN [g] [. T] [g'. N1 ..] [g'. N3 ..] =
fn a1 => fn a2 => case (a1,a2) of
| (AlgBase s1 s2 a1', AlgBase s2' s3 a2') => ? % This one requires more lemmas (determinacy)
| (AlgArr a1', AlgArr a2') =>
  AlgArr (algEqNTrans a1' a2')
;

rec logEqTrans :
   LogEq [g] [. T] [g'. M ..] [g'. N ..]
 -> LogEq [g] [. T] [g'. N ..] [g'. P ..]
 -> LogEq [g] [. T] [g'. M ..] [g'. P ..] =
fn e1 => fn e2 => case (e1, e2) of
| (LogBase a1, LogBase a2) => LogBase (algEqNTrans a1 a2)
| (LogArr [g'. M ..] [g'. N ..] f1, LogArr [g'. N ..] [g'. P ..] f2) =>
  LogArr [g'. M ..] [g'. P ..] (mlam h => mlam h' => mlam #W => mlam V1 => mlam V2 => fn rh => fn iv => fn v =>
   logEqTrans (f1 [h] [h'] [h' $ #W[..]] [h'. V1 ..] [h'. V2 ..] rh iv v)
              (f2 [h] [h'] [h' $ #W[..]] [h'. V2 ..] [h'. V2 ..] rh iv
                (logEqTrans (logEqSym v) v))
  )
;

rec logEqSubTrans :
   LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]]
 -> LogEqSub [g] [g'] [h] [h' $ #S2[..]] [h' $ #S3[..]]
 -> LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S3[..]] =
fn e1 => fn e2 => case (e1, e2) of
| (Nil, Nil) => Nil
| (Dot e1' x1, Dot e2' x2) => Dot (logEqSubTrans e1' e2') (logEqTrans x1 x2)
;

rec thm : {g:tctx}{h:tctx} DecEq [g] [. T] [g'. M1 ..] [g'. M2 ..]
        -> CtxRel [h] [h']
        -> LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]]
        -> LogEq [h] [. T] [h'. M1 #S1[..]] [h'. M2 #S2[..]] =
mlam g => mlam h => fn d => let d : DecEq [g] [. T] [g'. M1 ..] [g'. M2 ..] = d in
 fn r => fn s => let s : LogEqSub [g] [g'] [h] [h' $ #S1[..]] [h' $ #S2[..]] = s in
case d of
| DecVar v => lookup v s
| DecApp d1 d2 =>
   let LogArr [h'. M1 ..] [h'. M2 ..] f = thm [g] [h] d1 r s in
    f [h] [h'] [h' $ ..] [h'. _] [h'. _] r (idIsVarSub r) (thm [g] [h] d2 r s)
| DecLam d1 =>
   LogArr [h'. _] [h'. _] (mlam h0 => mlam h0' => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
     let q0 = wknLogEqSub [h0] [h'] [h0' $ #W[..]] s in
     let q2 = thm [g,b:block x:tm,y:oft x _] [h0] d1 rh (Dot q0 rn) in
     ? %closed [h0'. beta] [h0'. beta] q2 % Should work?
   )
| DecExt d1 =>
  LogArr [h'. _] [h'. _] (mlam h0 => mlam h0' => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
   let q0 = wknLogEqSub [h0] [h'] [h0' $ #W[..]]  s in
   let q1 = Dot q0 rn in
   ? %thm [g,b:block x:tm,y:oft x _] [h0] d1 q1 % Should work?
  )
| DecBeta d1 d2 =>
   let q0 = thm [g] [h] d2 r s in
   let q1 = thm [g,b:block x:tm,y:oft x _] [h] d1 r (Dot s q0) in
   closed [h'. beta] [h'. refl] q1
| DecSym d1 =>
   logEqSym (thm [g] [h] d1 r (logEqSubSym s))
| DecTrans d1 d2 =>
  logEqTrans (thm [g] [h] d1 r s)
             (thm [g] [h] d2 r (logEqSubTrans (logEqSubSym s) s))
;


rec idLogEqSub : CtxRel [g] [g']
-> LogEqSub [g] [g'] [g] [g' $ ..] [g' $ ..] =
fn r => case r of
| RNil => Nil
| RCons r' => let r' : CtxRel [g0] [g0'] = r' in
  Dot (wknLogEqSub [g0,b:block x:tm,y:oft x _] [g0'] [g0',x:tm $ ..] (idLogEqSub r'))
      (reflect [._] (AlgVar Top))
;

rec corollary : {g:tctx} CtxRel [g] [g']
-> DecEq [g] [. T] [g'. M1 ..] [g'. M2 ..]
-> LogEq [g] [. T] [g'. M1 ..] [g'. M2 ..] =
mlam g => fn r => fn e => thm [g] [g] e r (idLogEqSub r);

rec completeness : {g:tctx} CtxRel [g] [g']
-> DecEq [g] [. T] [g'. M1 ..] [g'. M2 ..]
-> AlgEqN [g] [. T] [g'. M1 ..] [g'. M2 ..] =
mlam g => fn r => fn e => reify r (corollary [g] r e);
