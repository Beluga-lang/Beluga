#opts +strengthen;
% Weak normalization under binders.

tp : type.                %name tp T.
i :  tp.
arr: tp -> tp -> tp.

tm : tp -> type.          %name tm E.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).

schema ctx = tm T;

mstep : tm A -> tm A -> type.  %name mstep S.
beta : mstep (app (lam M) N) (M N).
eta : {M:tm (arr A B)} mstep M (lam (\x. app M x)).
steplam : ({x:tm A} mstep (M x) (M' x)) -> mstep (lam M) (lam M').
stepapp : mstep M M' -> mstep N N' -> mstep (app M N) (app M' N').
refl : mstep M M.
trans : mstep M M' -> mstep M' M'' -> mstep M M''.

datatype IsVar : (g:ctx){M:[g |- tm A]} ctype =
| IsVar : {#p:[g |- tm A]} IsVar [g |- #p ..];

datatype IsVarSub : {g:ctx} (h:ctx) {#S: h |- g}ctype =
| Nil : IsVarSub [] [h |- ^ ]
| Cons :  IsVarSub [g] [h |- #S[..]] -> IsVar [h |- M ..]
         -> IsVarSub [g,x:tm A] [h |- #S[..] (M ..)];

% This could be defined at the LF layer, but then it would require a bigger schema,
% and I don't want to deal with that
% Could enforce also eta longness easily, but meh
datatype IsNormal : (g:ctx) {M:[g |- tm A]} ctype =
| Neut : IsNeutral [g |- M ..] -> IsNormal [g |- M ..]
| Lam : IsNormal [g,x:tm A |-  M .. x] -> IsNormal [g |- lam (\x. M .. x)]
and IsNeutral : (g:ctx) {M:[g |- tm A]} ctype =
| Var : IsVar [g |- M ..] -> IsNeutral [g |- M ..]
| App : IsNeutral [g |- M ..] -> IsNormal  [g |- N ..]
     -> IsNeutral [g |- app (M ..) (N ..)];

datatype Halts : (g:ctx) {A:[ |- tp]}{M:[g |- tm A]} ctype =
| Halts : [g |- mstep (M ..) (V ..)] -> IsNormal [g |- V .. ] -> Halts [ |- A] [g |- M ..];

% The type is explicit because I need to be explicit that
% Base only applies to base type, not arrow type! (important for coverage later)
datatype Reduce : (g:ctx) {A:[ |- tp]}{M:[g |- tm A]} ctype =
| Base : Halts [ |- i] [g |- M ..] -> Reduce [ |- i] [g |- M ..]
| Arr :  {M:[h0 |- tm (arr A B)]}
         ({h:ctx} {#R:h |- h0} {N:[h |- tm A]}
          IsVarSub [h0] [h |- #R[..] ] -> Reduce [ |- A] [h |- N ..]
          -> Reduce [ |- B ] [h |- app (M #R[..]) (N ..)])
         -> Reduce [ |- arr A B] [h0 |-  M ..];

rec wknVar' : IsVar [g |- M ..] -> IsVarSub [g] [h |- #W[..]] -> IsVar [h |- M #W[..]] =
fn iv => fn ivs => case iv of
| IsVar [g',x:tm B |-  x] =>    let Cons ivs' iv = ivs in iv
| IsVar [g',x:tm B |-  #q ..] => let Cons ivs' iv = ivs in wknVar' (IsVar [g' |-  #q ..]) ivs';

rec varSubCompose' : IsVarSub [g] [h  |- #W[..]] -> IsVarSub [h] [h' |- #W2[..]] -> IsVarSub [g] [h' |- #W[#W2[..]]] =
fn r1 => fn r2 => case r1 of
| Nil => Nil
| Cons ivs' iv => Cons (varSubCompose' ivs' r2) (wknVar' iv r2);

rec haltsMstep2 : {S:[g |- mstep (M ..) (M' ..)]} Halts [ |- A] [g |- M' ..] -> Halts [ |- A] [g |- M ..] =
 mlam S => fn h => let (h : Halts [ |- A] [g |- M' ..]) = h in
let Halts [g |- R ..] v = h in Halts [g |- trans (S ..) (R ..)] v;

rec closed2 : {S:[g |- mstep (M ..) (M' ..)]} Reduce [ |- A] [g |- M' ..] -> Reduce [ |- A] [g |- M ..] =
mlam S => fn r => let (r : Reduce [ |- A] [g |- M' ..]) = r in  case r of
| Base ha => Base (haltsMstep2  [g |- S ..] ha)
| Arr [g |- M ..] f => Arr [g |- _]
  (mlam h => mlam #W => mlam N => fn iv => fn rn =>
    closed2 [h |- stepapp (S #W[..]) refl] (f [h] [h |- #W[..]] [h |- N ..] iv rn));

rec wknVarSub : IsVarSub [g] [h |- #S[..]] -> IsVarSub [g] [h,x:tm A |- #S[..] ] =
fn r => case r of
| Nil => Nil
| Cons r' (IsVar [h |- #p ..]) => Cons (wknVarSub r') (IsVar [h,x:tm _  |-  #p ..]);

rec extVarSub : IsVarSub [g] [h |- #S[..]] -> IsVarSub [g,x:tm A] [h,x:tm A |- #S[..] x ] =
fn r => let r : IsVarSub [g] [h |- #S[..]] = r in Cons (wknVarSub r) (IsVar [h,x:tm _  |-  x]);

rec idIsVarSub : {g:ctx} IsVarSub [g] [g |- .. ] =
mlam g => case [g |- i] of % pattern match on context
| [ |- i] => Nil
| [g,x:tm T |-  i] => extVarSub (idIsVarSub [g]);

rec shiftIsVarSub :  {g:ctx} IsVarSub [g] [ g,x:tm A |- .. ] =
mlam g => wknVarSub (idIsVarSub [g]);

rec rwkn : IsNeutral [g |- R ..] -> IsVarSub [g]  [h |- #W[..]] -> IsNeutral [h |- R #W[..]] =
fn r => fn iv => case r of
| Var i => Var (wknVar' i iv)
| App r' n => App (rwkn r' iv) (nwkn n iv)
and nwkn : IsNormal [g |- N ..] -> IsVarSub [g] [h |- #W[..]] -> IsNormal [h |- N #W[..]] =
fn r => fn iv => case r of
| Neut r' => Neut (rwkn r' iv)
| Lam n => Lam (nwkn n (extVarSub iv));

rec reflect : IsNeutral [g |- R ..] -> Reduce [ |- A] [g |- R ..] =
fn r => let r : IsNeutral [g |- R ..] = r in let [g |- R ..] : [g |- tm A] = [g |- R ..] in
case [ |- A] of
| [ |- i] => Base (Halts [g |- refl] (Neut r))
| [ |- arr A B] =>
  Arr [g |- R ..]
  (mlam h => mlam #W => mlam M2 => fn iv => fn rm2 =>
    let Halts [h |- MS ..] n = reify rm2 in
    closed2 [h |- stepapp refl (MS ..)] (reflect (App (rwkn r iv) n)))

and reify : Reduce [ |- A] [g |- M ..] -> Halts [ |- A] [g |- M ..] =
fn r => case r of
| Base h => h
| Arr [g |- M ..] f =>
  let q1 = f [g,x:tm _] [g,x |- ..] [g,x |- x] (shiftIsVarSub [g]) (reflect (Var (IsVar [g,x:tm _ |-  x]))) in
  let Halts [g,x:tm _ |-  MS .. x] q2 = reify q1 in
  Halts [g |- trans (eta _) (steplam (\x. MS .. x))] (Lam q2);

rec wknRed : Reduce  [ |- A] [g |- M ..] -> IsVarSub [g] [h |- #W[..]] -> Reduce [ |- A] [h |- M #W[..]] =
fn r => fn iv => let (iv : IsVarSub [g] [h |- #W[..] ] ) = iv in
case r of
| Base (Halts [g |- S ..] q2) => Base (Halts [h |- S #W[..]] (nwkn q2 iv))
| Arr [g |- M ..] f =>
  Arr [h |- M #W[..]]
   (mlam h' => mlam #W2 => mlam N => fn iv2 => fn rn =>
    f [h'] [h' |- #W[#W2[..]]] [h' |-  N ..] (varSubCompose' iv iv2) rn);

datatype RedSub : {g:ctx}(h:ctx){#S:h |- g} ctype =
| Nil : RedSub [] [h |- ^ ]
| Dot : RedSub [g] [h |- #S[..] ] -> Reduce [ |- A] [h |- M ..] -> RedSub [g,x:tm A] [h |- #S[..] (M ..) ];

rec wknRedSub : RedSub [g] [h |- #S[..]] -> IsVarSub [h] [h' |- #W[..]] -> RedSub [g] [h' |- #S[#W[..]]] =
fn rs => fn iv => case rs of
| Nil => Nil
| Dot rs' rN => Dot (wknRedSub rs' iv) (wknRed rN iv);

rec redVar : {g:ctx}{#p:[g |- tm T]} RedSub [g] [h |- #S[..]] ->  Reduce [ |- T] [h |- #p #S[..] ] =
mlam g => mlam #p => fn rs => case [g |- #p ..] of
| [g',x:tm A |-  x] =>    let Dot rs' rN = rs in rN
| [g',x:tm A |-  #q ..] => let Dot rs' rN = rs in redVar [g'] [g' |-  #q ..] rs';

rec eval : {M:[g |- tm A]} RedSub [g] [h |- #S[..] ] -> Reduce [ |- A] [h |- M #S[..] ] =
mlam M => fn rs => let (rs : RedSub [g] [h |- #S[..]] ) = rs in
 case [g |- M ..] of
| [g' |-  #p ..] => redVar [g'] [g' |-  #p ..] rs
| [g' |-  app (M1 ..) (M2 ..)]  =>
  let Arr [h0 |- N1 ..] f = eval [g' |-  M1 ..]  rs in
   f [h] [h |- ..] [h |- _] (idIsVarSub [h]) (eval [g' |-  M2 ..] rs)
| [g' |-  lam (\x. M1 .. x)] =>
   Arr [h |- lam (\x. M1 #S[..] x)]
   (mlam h' => mlam #W => mlam N => fn isVS => fn rN =>
     closed2 [h' |-  beta] (eval [g',x:tm _ |-  M1 .. x] (Dot (wknRedSub rs isVS) rN)));

rec idRedSub : {g:ctx} RedSub [g] [g |- ..] =
mlam g => case [g |- i] of % Can't pattern match directly on g
| [ |- i] => Nil
| [g',x:tm A |-  i] =>
  Dot (wknRedSub (idRedSub [g']) (shiftIsVarSub [g']))
      (reflect (Var (IsVar [g',x:tm A |-  x])));

rec weakNorm : {g:ctx}{M:[g |- tm A]} Halts  [ |- A] [g |- M ..] =
mlam g => mlam M => reify (eval [g |- M ..] (idRedSub [g]));
