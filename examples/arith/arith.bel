nat :  type.     %name nat N x.
z : nat.
s : nat -> nat.

add : nat -> nat -> nat -> type. 
a_z : add z R R.
a_s : add N1 N2 N3 -> add (s N1) N2 (s N3).

rec plus1 : {N:[. nat]} [. add N (s z) (s N)] =
mlam N => case [. N] of
 | [. z] => [. a_z]

 %{| [. s N] => 
   let [. F] = plus1 [ . N] in
    [. a_s F]
}%
;
%{
rec plus : [. nat] -> [. nat] -> [. nat] = 
fn x => fn y =>  case x of 
| [. z]  => y 
| [. s U]  =>  
  let [. V] = plus [. U ] y in 
    [. s V] 
;

rec plus' : [. nat] -> [. nat] -> [. nat] = 
fn x => case x of 
| [. z]  => (fn y => y)
| [. s U] => 
  fn y => 
   let [. V] = plus' [. U] y in 
     [. s V]
;


rec mult : [. nat] -> [. nat] -> [. nat] = 
fn x => fn y =>  case x of 
| [. z]  => y 
| [. s U]  =>  
  let [. V] = mult [. U ] y  in 
    plus [. V] y
;


rec mult : [. nat] -> [. nat] -> [. nat] =
fn x => fn y => case x of
| [. z] => [. z]
| [. s U] =>
  let [. V] = mult [. U] y in
    plus [. V] y
;


rec fact : [. nat] -> [. nat] =
fn x => case x of 
| [. z] => [. s z]
| [. s U] => 
  let [. V] = fact [. U]  in
     mult [. V] x
;

let x = plus [. z] [. s z] ;
let y = fact [. s (s z)];
let w = fact [. s (s (s z))];
}%
