nat:type.
zero: nat.
succ: nat -> nat.

even:nat -> type.
ev_z: even zero.
ev_s: even N -> even (succ (succ N)).

odd : nat -> type.
od_sz : odd (succ zero).
od_s : odd N -> odd (succ (succ N)).

le : nat -> nat -> type.
le_z : le zero N.
le_s : le N M -> le (succ N) (succ M).


--mquery 1 * [ |- even (succ (succ zero))].

%% --mquery 0 * [ |- even (succ (succ (succ zero)))].
--mquery 1 * [ |- odd (succ (succ (succ zero)))].

--mquery 1 * [ |- le (succ (succ zero)) (succ (succ (succ (succ zero))))].

--mquery 1 * {N:[ |- nat]}{D:[ |- even N]} [ |- even (succ (succ N))].

--mquery 0 * {N:[ |- nat]}[ |- even (succ (succ N))].


% --mquery 2 2 D :  even (succ N)

--mquery 1 * {N: [ |- nat]}{D: [|- even N]} [|- even (succ (succ zero))].

schema ctx = nat;
% 
% --mquery  1 * {g:ctx}{N:[g |- nat]}{D : [g |- even N]} [g |- even (succ (succ N))].
%   ERROR: does not produce any solution but should produce as an answer [g |- ev_s D]
%
% --mquery  1 * {g:ctx}{N:[ |- nat]} {D : [g |- even N[]]} [g |- even (succ (succ N[]))].
%   ERROR: does not produce a solution, but should produce as an answer [g |- ev_s D]

node:type.
a:node.
b:node.
c:node.
d:node.
     
edge:node -> node -> type.
e_ab: edge a b.
e_bc: edge b c.
e_ad: edge a d.
e_cd: edge c d.

reach: node -> node -> type.
r_edge: edge A B -> reach A B.
r_reach: reach B C -> edge A B -> reach A C.
% NOTE: the order of subgoals depends on how the implication is written.
%       in this example our 1. subgoal will be edge A B and our 2. subgoal reach B C.
%       This is important, when we use depth first search

--mquery 1 * [ |- reach a d].
% succeeds, finding the first solution, but in fact there are 2 expected solutions.

--mquery 2 * [ |- reach a d].
% finds the correct 2 solutions

--mquery 2 * {N:[ |- node]}{E: [ |- edge N a]}[ |- reach N d].

% To be tested with bounded depth-first search when we introduce some cycles in the graph


tree: type.
leaf: tree.
node: nat → tree → tree → tree.

rec plus : [ ⊢ nat] → [ |- nat] → [ ⊢ nat] = fn x ⇒ fn y ⇒ case x of
  | [ ⊢ zero] ⇒ ?
  | [ ⊢ succ N] ⇒ ? ;

rec size : [ ⊢ tree] → [ ⊢ nat] = fn t ⇒ case t of
      | [ |- leaf] ⇒ [ ⊢ zero]
      | [ ⊢ node D L R] ⇒ let [ ⊢ N1] = size [ ⊢ L] in
			  let [ ⊢ N2] = size ? in
			  plus ? (plus [ ⊢ N1] ?)
;


% Bi-directional typing
% -- checking an expression against a type (\x.M, [ ⊢ ....],  )
% -- synthesizing a type for an expression 
% 
