% Natural Deduction - Hilbert Translation
% adapted from Handbook article on Logical Frameworks
% by F. Pfenning
%
% Author: Brigitte Pientka
%
% Comment: 
% - This is a good example to 
%   illustrate the differences
%   between Twelf, Delphin and our language.
% - illustrate the need for context schema
%   subsumption
% - proper context coercions should be added
% - should be extended to include the proof
%   that every Hilber-style derivation has 
%   a natural deduction derivation

i : type.  % individual
o : type.  % formulas

imp : o -> o -> o.  
all : (i -> o) -> o.
not : o -> o.     

nd : o -> type. % Natural deduction
impi : (nd A -> nd B) -> nd (imp A B).
impe : nd (imp A B) -> nd A -> nd B.
noti : ({p:o} nd A -> nd p) -> nd (not A).
note : nd (not A) -> {C:o} nd A -> nd C.
alli : ({a:i} nd (A a)) -> nd (all (\x. A x)).
alle : nd (all (\x. A x)) -> {T:i} nd (A T).

hil : o -> type.  % Hilbert deductions
k  : hil (imp A (imp B A)).
s  : hil (imp (imp A (imp B C)) (imp (imp A B) (imp A C))).
n1 : hil (imp (imp A (not B)) (imp (imp A B) (not A))).
n2 : hil (imp (not A) (imp A B)).
f1 : {T:i} hil (imp (all (\x.A x)) (A T)).
f2 : hil (imp (all (\x.(imp B  (A x))))  (imp B (all (\x.A x)))).
mp : hil (imp A B) -> hil A -> hil B.
ug : ({a:i} hil (A a)) -> hil (all (\x.A x)).

% Implementation of the Deduction Theorem
%
%   If G, u:hil A |- hil B then G |- hil (A imp B).
%

schema w =  i + some [ a:o ] hil a;

rec ded: {g:w} 
    [g, u:hil (A ..). hil (B ..)] -> [g. hil (imp (A ..) (B ..))] = 
 mlam g => fn h =>  
 case h of 
   [g, u: hil _ . #p ..] =>  [g. mp k #p ..]  % SPECIAL!

% Can only be done by giving type annotation to k or s in
% the output; this is also done in the Twelf implementation
% 
% ded_id : ded ([u:hil A] u) (mp (mp s k) (k : hil (A imp (A imp A)))).
% | [g, u: hil _ ] u     => [g] (mp (mp s k) k)
 | [g, u: hil _ . k]  => [g. mp k k]
 | [g, u: hil _ . n1] => [g. mp k n1]
 | [g, u: hil _ . n2] => [g. mp k n2]
 | [g, u: hil _ . f1 (T ..)] => [g. mp k (f1 (T ..))]
 | [g, u: hil _ . f2] => [g. mp k f2]

 | [g, u: hil (A ..). ug (\x. (H .. x u))] => 
  let      
    [g,x:i. (H' .. x)] = 
      ded [g, x:i]  [g, x, u. (H .. x u)]
  in
     [g. mp f2 (ug  \x. (H' .. x))]

| {H1 : [g, u : hil (A ..). hil (imp (B1 ..) (B2 ..))]}
  {H2 : [g, u : hil (A ..). hil (B1 ..)]}
  [g, u: hil (A ..) . (mp (H1 .. u) (H2 .. u))] => 
  let [g. H2' ..] = ded [g] [g,u. H2 .. u] in
  let [g. H1' ..] = ded [g] [g,u. H1 .. u] in
       [g. mp (mp s (H1' ..)) (H2' ..)]

;

% % Theorem: If G |- nd A  where G = nd B1 .... nd Bn 
% %          then G* |- hil A   where G' = hil B1 ... hil Bn


schema ndCtx  = i + o + some [a:o] nd a ; 
schema hilCtx = i + o + some [a:o] hil a ;

coercion nd2hil : ndCtx -> hilCtx = 
              i => i 
    |         o => o
    | some [a:o] nd a => hil a ;

%{
 rec ndhil : {g:(ndCtx)*} (nd (A ..))[g] -> (hil (A .. ))[nd2hil(g)] =
 FN g => fn d => 
 case d of 
   [g] (#p ..) => [g] (nd2hil (#p ..))

 | [g] impi \u. D .. u => 
   let [nd2hil(g), u: hil (A ..)] H .. u = 
     ndhil [g, u:nd (A ..)] ([g,u] D .. u)
   in
       ded [nd2hil(g)] ([nd2hil(g),u] H .. u)

 | [g] impe (D1 ..) (D2 ..) => 
   let [nd2hil(g)] H1 .. = ndhil [g] ([g] D1 ..) in		
   let [nd2hil(g)] H2 .. = ndhil [g] ([g] D2 ..) in 
       [nd2hil(g)] mp (H1 ..) (H2 ..)

 | [g] noti \p.\u.D .. p u => 
   let [nd2hil(g)s,p:o,w:nd (A ..)]  H .. w p = 
     ndhil [g, p:o, w:nd (A ..) ]   ([g,p, w] D .. p w) in 

   let [nd2hil(g)] H1' .. = ded [nd2hil(g)]  ([nd2hil(g),w] H .. w (not (A ..))) in 
   let [nd2hil(g)] H1'' .. = ded [nd2hil(g)] ([nd2hil(g),w] H .. w (A ..)) in
     [nd2hil(g)] mp (mp n1 (H1' ..)) (H1'' ..)

 | [g] note (D1 ..) (C ..) (D2 ..) => 
   let [nd2hil(g)] H1 ..   = ndhil [g]  ([g]D1 ..) in
   let [nd2hil(g)] H2 ..   = ndhil [g]  ([g]D2 ..) in
     [nd2hil(g)] mp (mp n2 (H1 ..)) (H2 ..)

 | [g] alle  (D1 ..) T => 
   let [nd2hil(g)]H1 .. =  ndhil [g] ([g] D1 ..) in
      [nd2hil(g)] mp (f1 T) (H1 ..)

 | [g] alli \x. D .. x => 
   let [nd2hil(g),x:i] H .. x =  ndhil [g, x:i] ([g, x] D .. x) in 
     [nd2hil(g)] ug \x. (H .. x)

;
}%
