%{ 
  CH 3:  Untyped arithmetic expressions
  Author: Brigitte Pientka

  Big-step semantics together with the proof 
  that the big step rules are equivalent to the
  small-step rules.

}%


eval: term -> term -> type.

ev_true  : 
  eval true  true.
ev_false : 
  eval false false.
ev_switch_true: 
  eval M true -> eval M1 V 
  -> eval (switch M M1 M2) V.
ev_switch_false: 
  eval M false -> eval M2 V 
  -> eval (switch M M1 M2) V.

ev_z     : 
  eval z z.
ev_succ  :
  eval M V 
-> eval (succ M) (succ V).

ev_pred_zero:
  eval N z 
->  eval (pred N) z.
ev_pred_succ:
  eval N (succ V)
-> eval (pred N) V.

ev_iszero_zero: 
  eval N z
-> eval (iszero N) true.

ev_iszero_succ: 
  eval N (succ V)
-> eval (iszero N) false.



% ---------------------------------------------------------- %
%{

THEOREM:

1) big_to_small : If eval M V then multi-step M V 
2) small_to_big : If multi-step M V and value V  then eval M V.

}%
 
rec big_to_small : (eval M V)[ ] -> (multi_step M V)[ ] =
fn d => case d of 
| [ ] ev_true  => [ ] ms_ref
| [ ] ev_false => [ ] ms_ref

| [ ] ev_switch_true D D1 : (eval (switch M M1 M2) V) [ ] => 
  let [ ] Mtrue  = big_to_small ([ ] D) in   
    % Mtrue : multi_step M true
  let [ ] MS     = mstep_switch < . M1 > < . M2 > ([ ] Mtrue ) in 
    % MS : multi_step (switch M M1 M2) (switch true M1 M2)
  let [ ] MS1    = big_to_small ([ ] D1) in   
    % MS1 : multi_step  M1 V
    [ ] ms_tr MS (ms_tr (ms_step  e_switch_true) MS1) 


| [ ] ev_switch_false D D1 : (eval (switch M M1 M2) V) [ ] => 
  let [ ] Mfalse  = big_to_small ([ ] D) in   
    % Mfalse : multi_step M false
  let [ ] MS     = mstep_switch < . M1 > < . M2 > ([ ] Mfalse ) in 
    % MS : multi_step (switch M M1 M2) (switch false M1 M2)
  let [ ] MS1    = big_to_small ([ ] D1) in   
    % MS1 : multi_step  M1 V
    [ ] ms_tr MS (ms_tr (ms_step  e_switch_false) MS1) 

| [ ] ev_z        => [ ] ms_ref

| [ ] ev_succ D   => 
  let [ ] MS   = big_to_small ([ ] D) in 
    % MS: multi_step N V 
    mstep_succ ([ ] MS)

| [ ] ev_pred_zero D => 
  let [ ] Mzero = big_to_small ([ ] D) in 
    % Mzero: multi_step M z 
  let [ ] MS    = mstep_pred ([ ] Mzero) in 
    % MS   : multi_step (pred M)  (pred z)
    [ ] ms_tr MS (ms_step e_pred_zero)

| [ ] ev_pred_succ D => 
  let [ ] Msucc = big_to_small ([ ] D) in 
    % Msucc : multi_step M (succ V) 
  let [ ] MS    = mstep_pred ([ ] Msucc) in 
    % MS    : multi_step (pred M) (pred (succ V))
    [ ] ms_tr MS (ms_step e_pred_succ)

| [ ] ev_iszero_zero D => 
  let [ ] Mzero = big_to_small ([ ] D) in 
    % Mzero : multi_step M zero
  let [ ] MS    = mstep_iszero ([ ] Mzero) in 
    % MS    : multi_step (iszero M) (iszero z)
    [ ] ms_tr MS (ms_step e_iszero_zero)


| [ ] ev_iszero_succ D => 
  let [ ] Msucc = big_to_small ([ ] D) in 
    % Msucc : multi_step M (succ V)
  let [ ] MS    = mstep_iszero ([ ] Msucc) in 
    % MS    : multi_step (iszero M) (iszero (succ V))
    [ ] ms_tr MS (ms_step e_iszero_succ)
;


% ---------------------------------------------------------- %
%{
   Theorem 2) : If mstep M V and value V then eval M V


This theorem doesn't hold; for example 
mstep (iszero (succ N)) false    but
if N isn't a number, but (switch zero zero zero) then 
the big-step semantics could get stuck while the
small step semantics simply returns false, since it
may never inspect N. 

There are two solutions to this problem:
1) restrict small step semantics such that
  congruence rules are only applied when we don't have
  a value
2) make big-step evaluation more liberal. 

1) is preferred, since in 2) we succeed evaluating 
expressions which aren't even well-typed.

}%

