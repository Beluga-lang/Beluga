(**
Replay is the test harness for the Beluga interactive mode.
Replay processes _interaction transcripts_, which are files defined by
the following informal grammar:

  * A valid Beluga program, (followed by a line break,) hereafter
    referred to as the _input program_.
  * One or more _interactions_.

where each _interaction_ consists of:

  * A _request_, which is an interactive mode command, of the form
    `%:FOO ...`.
  * A _response_, which is an arbitrary block of text, beginning on
    its own line, up to the next request.

What Replay does with _interaction transcripts_ is the following:

  * The _input program_ is written to a file called `input.bel`.
  * A Beluga interactive subprocess is spawned under the control of
    Replay, with the command `beluga -I -emacs`.
  * For each _interaction_ present in the _interaction transcript_:
      * The _request_ is sent to the Beluga subprocess.
      * The output generated by the subprocess is compared with the
        _response_ associated with the _request_.
      * Additionally, the output generated by the subprocess is
        written to the file `last-output.bel`.
      * Should they differ, Replay exits with a nonzero status.
 *)

(** Converts a list of characters into an equivalent string. *)
let pack (cs : char list) : string =
  String.concat "" (List.map (String.make 1) cs)

module Either = struct
  type ('e, 'a) t =
    | Left of 'e
    | Right of 'a

  let eliminate (left : 'e -> 'c) (right : 'a -> 'c) : ('e, 'a) t -> 'c =
    function
    | Left e -> left e
    | Right x -> right x

  let pure (x : 'a) : ('e, 'a) t = Right x

  let rmap (f : 'a -> 'b) (e : ('e, 'a) t) : ('e, 'b) t =
    match e with
    | Left e -> Left e
    | Right x -> Right (f x)

  let lmap (f : 'e1 -> 'e2) (e : ('e1, 'a) t) : ('e2, 'a) t =
    match e with
    | Left e -> Left (f e)
    | Right x -> Right x

  let bind (e : ('e, 'a) t) (k : 'a -> ('e, 'b) t) : ('e, 'b) t =
    match e with
    | Left e -> Left e
    | Right x -> k x

  let forget (e : ('e, 'a) t) : 'a option =
    match e with
    | Left e -> None
    | Right x -> Some x

  let either_of_option (opt : 'a option) : (unit, 'a) t =
    match opt with
    | None -> Left ()
    | Some x -> Right x

  let ( $ ) (e : ('e, 'a) t) (k : 'a -> ('e, 'b) t) : ('e, 'b) t =
    match e with
    | Left err -> Left err
    | Right x -> k x
end

module Pair = struct
  let rmap (f : 'a -> 'b) (p : 'x * 'a) : 'x * 'b =
    let (x, a) = p in (x, f a)

  let lmap (f : 'a -> 'b) (p : 'a * 'y) : 'b * 'y =
    let (a, y) = p in (f a, y)
end

module Option = struct
  let map (f : 'a -> 'b) : 'a option -> 'b option =
    function
    | None -> None
    | Some x -> Some (f x)

  let ( $ ) (o : 'a option) (k : 'a -> 'b option) : 'b option =
    match o with
    | None -> None
    | Some x -> k x

  let pure (x : 'a) : 'a option =
    Some x

  let ( $> ) (o : 'a option) (f : 'a -> 'b) : 'b option =
    o $ fun x -> pure (f x)
end

module ParserCombinator = struct
  (**
  The physical location inside the input file at which the parser is
  situated.
  *)
  type loc =
    { line : int;
      offset : int;
      bol : int;
    }

  let string_of_loc (loc : loc) : string =
    Printf.sprintf "line %d, column %d" (loc.line + 1) (loc.offset - loc.bol + 1)

  (**
  A semantic location, provided by the user of the parser, used to
  generate nice error messages, specifically of the form
  "Parse error at (line, col) in FOO in BAR in XYZ in ..."
  *)
  type semantic_loc = string list

  let string_of_semantic_loc (locs : semantic_loc) : string =
    String.concat ", " (List.map (fun l -> "in " ^ l) locs)
    
  type state =
    { loc : loc;
      semantic_loc : semantic_loc;
      input : string;
      backtrack_enabled : bool;
    }

  type parse_error =
    { error_loc : loc;
      error_semantic_loc : semantic_loc;
      error_message : string;
      error_is_recoverable : bool;
    }

  let string_of_parse_error (e : parse_error) : string =
    Printf.sprintf "%s: %s %s"
      (string_of_loc e.error_loc)
      e.error_message
      (string_of_semantic_loc e.error_semantic_loc)

  let error_of_state (msg : string) (s : state) : parse_error =
    { error_loc = s.loc;
      error_semantic_loc = s.semantic_loc;
      error_message = msg;
      error_is_recoverable = s.backtrack_enabled;
    }

  let push_semantic_loc (l : string) (s : state) : state =
    { s with semantic_loc = l :: s.semantic_loc }

  let pop_semantic_loc (s : state) : state =
    { s with semantic_loc = List.tl s.semantic_loc }

  let map_loc (f : loc -> loc) (s : state) : state =
    { s with loc = f s.loc }

  let map_input (f : string -> string) (s : state) : state =
    { s with input = f s.input }

  let inc_loc_with (c : char) (loc : loc) =
    { line = if c = '\n' then loc.line + 1 else loc.line;
      offset = loc.offset + 1;
      bol = if c = '\n' then loc.offset + 1 else loc.bol;
    }
    
  (** Pops a character from the input string, if any.
  Returns `None` if the input is empty. *)
  let car (s : state) : (char * state) option =
    try
      let c = s.input.[0] in
      Some
        ( c,
          { s with
            input = String.sub s.input 1 (String.length s.input - 1);
            loc = inc_loc_with c s.loc;
          }
        )
    with
    | Invalid_argument _ -> None

  (** The type of a parser. *)
  type 'a t = state -> state * (parse_error, 'a) Either.t

  (** Runs a parser with backtracking enabled.
  This will allow alternation to succeed if this parser fails even
  while consuming input.
  Note that even in case of failure, the returned parser state will
  have its value of `backtrack_enabled` reset to its original
  value. *)
  let trying (p : 'a t) : 'a t =
    fun s ->
    let (s', e) = p { s with backtrack_enabled = true } in
    ({ s' with backtrack_enabled = s.backtrack_enabled }, e )

  (** Constructs a parser that tries the left parser, and if it fails
  *without consuming input*, tries the right parser.
  In other words, this is an alternation operator on parsers.
  In order to perform alternation *even while consuming input*, the
  parser must fail with `backtrack_enabled = true`. This can be
  achieved by using the `trying` combinator. *)
  let alt (p1 : 'a t) (p2 : 'a t) : 'a t =
    fun s ->
    let (s', e) = p1 s in
    let open Either in
    match e with
    | Left e ->
       (* If the error is recoverable (i.e. the parser failed with
       backtrack_enabled = true) or if the parser failed without
       consuming any input, then we try the next parser. *)
       if e.error_is_recoverable || s'.input = s.input then
         p2 s
       else
         (s', Left e)
    | Right x -> (s', Right x)

  let throw (msg : string) : 'a t =
    fun s -> (s, Either.Left (error_of_state msg s))

  (** A variant of `car` that pops a character from the input, if any,
  but otherwise throws a `parse_error` with the message "unexpected
  end of input". *)
  let carp : char t =
    fun s ->
    match car s with
    | None -> (s, Either.Left (error_of_state "unexpected end of input" s))
    | Some (c, s') -> (s', Either.pure c)

  let map (f : 'a -> 'b) (p : 'a t) : 'b t =
    fun s -> Pair.rmap (Either.rmap f) (p s)

  (** Transforms the input state of a parser and runs it. *)
  let state (f : state -> state) (p : 'a t) : 'a t =
    fun s -> p (f s)

  (** Pushes the given semantic location onto the stack, runs the
  given parser, and pops the semantic location. *)
  let label (l : string) (p : 'a t) : 'a t =
    fun s -> Pair.lmap pop_semantic_loc (p (push_semantic_loc l s))

  (** Constructs a parser that doesn't affect its state and simply
  yields the given value. *)
  let pure (x : 'a) : 'a t = fun s -> (s, Either.pure x)

  (** A sequencing operator for parsers.
  This operator takes a parser on the left and a continuation on the
  right.
  The continuation uses the result of the left parser to construct a
  new parser.
  This operator passes the output state of the left parser to run the
  new parser. *)
  let ( $ ) (p : 'a t) (k : 'a -> 'b t) : 'b t =
    fun s ->
    let (s', e) = p s in
    let open Either in
    match e with
    | Left err -> (s', Left err)
    | Right x -> k x s'

  (** A flipped, operator version of `map`. *)
  let ( $> ) (p : 'a t) (f : 'a -> 'b) : 'b t =
    p $ fun x -> pure (f x)

  (** Tries all the parsers from left to right.
  The same caveats regarding input consumption apply as in `alt`. *)
  let rec choice : 'a t list -> 'a t =
    function
    | [] -> throw "all choices failed"
    | (p :: ps) -> alt p (choice ps)

  (** `many` repeatedly applies a parser until it fails, collecting
  all results.  The parser could succeed zero times, consuming no
  input, producing an empty list.
  `some` repeatedly applies a parser until it fails, but must succeed
  at least once. *)
  let rec many (p : 'a t) : 'a list t = alt (some p) (pure [])
  and some (p : 'a t) : 'a list t =
    p $ fun x -> many p $ fun xs -> pure (x :: xs)
    
  (** Constructs a parser that consumes a single character of input,
  returning it, if that character satisfies the given predicate. *)
  let satisfy (f : char -> bool) : char t =
    map (fun c -> (c, f c)) carp $
      function
      | (c, true) -> pure c
      | (c, false) ->
         let msg =
           "unexpected character " ^ String.make 1 c ^ " failed predicate"
         in
         throw msg

  (** Matches a character from a given list. *)
  let one_of (cs : char list) : char t =
    choice (List.map (fun c -> satisfy (fun c' -> c = c')) cs)

  (** Constructs a parser that matches exactly the given string. *)
  let rec string (str : string) : string t =
    if str = "" then
      pure ""
    else
      let (c, str') =
        (str.[0], String.sub str 1 (String.length str - 1))
      in
      satisfy (fun c' -> c = c') $
        fun _ -> string str'

  (** `many_till` repeatedly applies the given parser, testing whether
  `pend` succeeds between applications. Once `pend` succeeds, this
  parser stops.
  `some_till` does the same, but `p` must succeed at least once. *)
  let rec many_till (p : 'a t) (pend : unit t) : 'a list t =
    alt (pend $ fun _ -> pure []) (some_till p pend)
  and some_till (p : 'a t) (pend : unit t) : 'a list t =
    p $ fun x -> many_till p pend $ fun xs -> pure (x :: xs)

  (** Forgets the result of a parser, preserving only its effects. *)
  let void : 'a t -> unit t = map (fun _ -> ())

  (** A parser that succeeds only if the parser is at the beginning of
  a line. *)
  let bol : unit t =
    fun s ->
    if s.loc.bol = s.loc.offset then
      (s, Either.pure ())
    else
      ( s,
        Either.Left
          (error_of_state "expected to be at beginning of line" s)
      )

  (** A parser that succeeds only if the parser is at the end of the
  input. *)
  let eof : unit t =
    fun s ->
    if s.input = "" then
      (s, Either.pure ())
    else
      ( s,
        Either.Left
          (error_of_state "expected to be at end of file" s)
      )

  (** `lookahead p` runs parser `p`, but resets the parser input state
  to its original value. `lookahead` fails if the underlying parser
  fails.
  This is useful when used in conjunction with combinators such as
  `many_till q end`, since the result of parsing `end` is unavailable.
  For example, one may want to parse arbitrary text up to the
  beginning of a new command, beginning with "%:", but actually want
  to parse the command after. In that case, the `end` parser can be
  `trying (lookahead (string "%:"))`. *)
  let lookahead (p : 'a t) : 'a t =
    fun s -> Pair.lmap (fun _ -> s) (p s)

  (** A parser that simply yields the internal parser state. *)
  let get : state t =
    fun s -> (s, Either.pure s)

  (** Gets the current location of the parser inside the input. *)
  let get_loc : loc t =
    get $> fun s -> s.loc

  (** Gets the current line the parser is on inside the input. *)
  let get_line : int t =
    get_loc $> fun l -> l.line

  let initial_loc : loc =
    { bol = 0;
      offset = 0;
      line = 0;
    }

  let initialize (input : string) : state =
    { input = input;
      loc = initial_loc;
      semantic_loc = [];
      backtrack_enabled = false;
    }

  let parse (p : 'a t) (s : state) : state * (parse_error, 'a) Either.t = p s
end

module Replay = struct
  (**
  An interaction consists of a _request_, which is sent to the
  subprocess, and a response, which is compared with the output
  generated by the subprocess in response to the request.
   *)
  type interaction =
    { request : string;
      response : string;
      line_num : int option;
    }
  
  (**
  A transcript consists of an input file, which is valid Beluga code, followed by a number of interactions.
   *)
  type transcript =
    { input_file : string;
      interactions : interaction list;
    }
end

module TranscriptParser = struct
  open ParserCombinator
  open Replay

  type 'a parser = 'a t
     
  (** A parser for the interactive mode command sigil `%:` *)
  let sigil : string parser = label "command sigil" (string "%:")

  let bol_sigil : string parser = bol $ fun _ -> sigil
  
  (** A parser for an interactive mode command, which is a line
  beginning with a sigil. *)
  let command : string parser =
    label "command"
      ( trying bol_sigil $
          fun _ ->
          many_till carp (void (trying (string "\n"))) $> pack $>
            fun s -> "%:" ^ s ^ "\n" )

  (** A parser for an interaction: a command followed by an expected
  response. *)
  let interaction : interaction parser =
    label "interaction"
      ( get_line $
          fun line_num ->
          command $
            fun cmd ->
            many_till carp (lookahead (alt (void bol_sigil) eof)) $> pack $>
              fun resp ->
                { request = cmd;
                  response = resp;
                  line_num = Some line_num;
                } )
  
  (** A parser for a transcript: an input file followed by a number of
  interactions. *)
  let transcript : transcript parser =
    label "beluga test transcript"
      ( label "input beluga code"
          (many_till carp (void (lookahead bol_sigil))) $> pack $
          fun bel ->
          let f ints =
            { input_file = bel;
              interactions = ints;
            }
          in
          map f (label "interactions block" (some interaction)) $
            fun trans -> eof $> fun _ -> trans )

  let parse_transcript (input : string) :
        state * (parse_error, transcript) Either.t =
    parse transcript (initialize input)

  let parse_transcript' (input : string) :
        (parse_error, transcript) Either.t =
    snd (parse_transcript input)
end

module Istream = struct
  type 'a t =
    { next : unit -> ('a * 'a t) option }

  type 'a istream = 'a t

  (** Put a given element on the front of a stream. *)
  let cons (x : 'a) (s : 'a t) =
    { next = fun () -> Some (x, s) }

  let rec of_channel'
            (buf : Bytes.t) (pos : int)
            (len : int) (chan : in_channel) :
            char t =
    let next () =
      (* if we've yielded all the chars in our buffer, we need to read
      more chars from the channel *)
      if pos = len then
        let len' = input chan buf 0 (Bytes.length buf) in
        (* if input returns 0 bytes, we've reached EOF *)
        if len' = 0 then
          None
        else
          Some (Bytes.get buf 0, of_channel' buf 1 len' chan)
      (* otherwise just yield the next char and bump up our pointer *)
      else
        Some (Bytes.get buf pos, of_channel' buf (pos + 1) len chan)
    in
    { next = next }

  let of_channel (chan : in_channel) : char t =
    of_channel' (Bytes.create 1024) 0 0 chan

  (** Read from a stream so long as items satisfy a given predicate.
  The returned list contains all the leading elements of the stream
  that satisfy the predicate.
  If the second component of the pair is non-empty then it contains
  the rest of the stream as well as the first item that failed to
  satisfy the predicate. *)
  let take_while (p : 'a -> bool) (s : 'a t) :
        'a list * ('a * 'a t) option =
    let rec go (acc : 'a list) (s : 'a t) :
          'a list * ('a * 'a t) option =
      (* try to pull the next item from the stream *)
      match s.next () with
      (* if the stream is empty, we're done *)
      | None -> (acc, None)
      | Some (c, s') ->
         (* otherwise, check the predicate and prepend the item to the
         list if it passes *)
         if p c then
           go (c :: acc) s'
         (* otherwise, we need to put the character back onto the
         stream and finish *)
         else
           (acc, Some (c, s'))
    in
    go [] s |> Pair.lmap List.rev

  let take_while_str (p : char -> bool) (s : char t) :
        string * (char * char t) option =
    take_while p s |> Pair.lmap pack
end

module TranscriptRunner = struct
  open Replay
  open Unix

  type 'a istream = 'a Istream.t
     
  (** The environment in which the transcript runner executes. *)
  type env =
    { beluga_out : char istream option;
      beluga_in : out_channel;
    }

  let beluga_command = "bin/beluga -I -emacs"

  let create_env (_ : unit) : env =
    let (in_chan, out_chan) = open_process beluga_command in
    { beluga_out = Some (Istream.of_channel in_chan);
      beluga_in = out_chan;
    }

  let beluga_send (s : string) (env : env) : unit =
    output_string env.beluga_in s;
    flush env.beluga_in

  (* Read from the beluga output stream until a semicolon followed by
  a line break is encountered.
  The result is None if the stream ends unexpectedly. *)
  let beluga_read_response (s : char istream) :
        (string * char istream) option =
    let (resp, o) = Istream.take_while_str (fun c -> c != ';') s in
    let open Option in
    (* we put the semicolon back on the end of the response *)
    o $> Pair.lmap (fun c -> resp ^ String.make 1 c) $
      fun (str, s) ->
      let open Istream in
      (* read one more character, which is the line terminator right
      after the semicolon *)
      s.next () $>
        fun (c, s) -> (str ^ String.make 1 c, s)

  (** Send an interactive mode command to the Beluga subprocess
  managed by `env` and read the whole response.
  Beluga terminates responses with the semicolon, so `rpc` will block
  until it reads a semicolon from Beluga.
  The result is None if the `beluga_out` stream is already closed.
  *)
  let rpc (request : string) (env : env) : (string * env) option =
    beluga_send request env;
    let open Option in
    env.beluga_out $ beluga_read_response $>
      fun (str, so) ->
        (str, { env with beluga_out = Some so } )

  let write_file (path : string) (contents : string) : unit =
    let h = open_out_bin path in
    output_string h contents;
    flush h;
    close_out h

  let run_interaction (i : interaction) (e : env) :
        (string, env) Either.t =
    let string_of_line : int option -> string =
      function
      | None -> "<unknown>"
      | Some n -> string_of_int n
    in
    match rpc i.request e with
    | None ->
       Either.Left
         ( "interaction on line "
         ^ string_of_line i.line_num
         ^ " failed: Beluga subprocess unexpectedly closed "
         ^ "its output channel" )
    | Some (res, e') ->
       if res = i.response then
         begin
           write_file "last-output.bel" res;
           Either.pure e'
         end
       else
         Either.Left
           ( "interaction on line "
             ^ string_of_line i.line_num
             ^ " failed: output mismatch\n"
             ^ "expected ouptut:\n"
             ^ i.response
             ^ "actual output:\n"
             ^ res )

    let rec run_interactions (ints : interaction list) (e : env) :
          (string, env) Either.t =
    match ints with
    | [] -> Either.pure e
    | (i :: ints) ->
       let open Either in
       run_interaction i e $
         fun e' ->
         run_interactions ints e'

  let run_transcript (transcript : transcript) (e : env) : (string, env) Either.t =
    write_file "input.bel" transcript.input_file;
    run_interactions transcript.interactions e
end

type error =
  | ParseError of string
  | InteractionError of string

let main () =
  let real_main () : (error, TranscriptRunner.env) Either.t =
    let path = Array.get Sys.argv 1 in
    let input = Std.input_file path in
    let open Either in
    TranscriptParser.parse_transcript' input |>
      lmap
        (fun e ->
          ParserCombinator.string_of_parse_error e |>
            fun x -> ParseError x) $
      fun transcript ->
      let open TranscriptRunner in
      let env = create_env () in
      run_transcript transcript env |>
        lmap (fun e -> InteractionError e)
  in
  real_main () |>
    Either.eliminate
      ( function
        | ParseError err ->
           print_string "parse error: ";
           print_string err;
           exit 1
        | InteractionError err ->
           print_string err;
           exit 1 )
      ( fun _ -> exit 0 )

let _ = main ()
