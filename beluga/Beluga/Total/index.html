<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Total (beluga.Beluga.Total)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Beluga</a> &#x00BB; Total</nav><header class="odoc-preamble"><h1>Module <code><span>Beluga.Total</span></code></h1><p>Checking termination of a function</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Unify"><a href="#module-Unify" class="anchor"></a><code><span><span class="keyword">module</span> Unify</span><span> = <a href="../Unify/StdTrail/index.html">Unify.StdTrail</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-P"><a href="#module-P" class="anchor"></a><code><span><span class="keyword">module</span> P</span><span> = <a href="../Prettyint/DefaultPrinter/index.html">Prettyint.DefaultPrinter</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-R"><a href="#module-R" class="anchor"></a><code><span><span class="keyword">module</span> R</span><span> = <a href="../Store/Cid/DefaultRenderer/index.html">Store.Cid.DefaultRenderer</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dprintf"><a href="#val-dprintf" class="anchor"></a><code><span><span class="keyword">val</span> dprintf : <span><span><a href="../../Support/Debug/Fmt/index.html#type-fmt">Support.Debug.Fmt.fmt</a> <a href="../../Support/Debug/index.html#type-io">Support.Debug.io</a></span> <a href="../../Support/Debug/index.html#type-io">Support.Debug.io</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dprint"><a href="#val-dprint" class="anchor"></a><code><span><span class="keyword">val</span> dprint : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> string)</span> <a href="../../Support/Debug/index.html#type-io">Support.Debug.io</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dprnt"><a href="#val-dprnt" class="anchor"></a><code><span><span class="keyword">val</span> dprnt : <span>string <a href="../../Support/Debug/index.html#type-io">Support.Debug.io</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span></code><ol><li id="type-error.NoPositiveCheck" class="def variant constructor anchored"><a href="#type-error.NoPositiveCheck" class="anchor"></a><code><span>| </span><span><span class="constructor">NoPositiveCheck</span> <span class="keyword">of</span> string</span></code></li><li id="type-error.NoStratifyCheck" class="def variant constructor anchored"><a href="#type-error.NoStratifyCheck" class="anchor"></a><code><span>| </span><span><span class="constructor">NoStratifyCheck</span> <span class="keyword">of</span> string</span></code></li><li id="type-error.NoStratifyOrPositiveCheck" class="def variant constructor anchored"><a href="#type-error.NoStratifyOrPositiveCheck" class="anchor"></a><code><span>| </span><span><span class="constructor">NoStratifyOrPositiveCheck</span> <span class="keyword">of</span> string</span></code></li><li id="type-error.WrongArgNum" class="def variant constructor anchored"><a href="#type-error.WrongArgNum" class="anchor"></a><code><span>| </span><span><span class="constructor">WrongArgNum</span> <span class="keyword">of</span> <a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> * int</span></code></li><li id="type-error.RecCallIncompatible" class="def variant constructor anchored"><a href="#type-error.RecCallIncompatible" class="anchor"></a><code><span>| </span><span><span class="constructor">RecCallIncompatible</span> <span class="keyword">of</span> <a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a>
  * <a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a>
  * <a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a></span></code></li><li id="type-error.NotImplemented" class="def variant constructor anchored"><a href="#type-error.NotImplemented" class="anchor"></a><code><span>| </span><span><span class="constructor">NotImplemented</span> <span class="keyword">of</span> string</span></code></li><li id="type-error.TooManyArg" class="def variant constructor anchored"><a href="#type-error.TooManyArg" class="anchor"></a><code><span>| </span><span><span class="constructor">TooManyArg</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-E"><a href="#exception-E" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">E</span> <span class="keyword">of</span> <a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="#type-error">error</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-throw"><a href="#val-throw" class="anchor"></a><code><span><span class="keyword">val</span> throw : <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-error">error</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-error_printer"><a href="#val-error_printer" class="anchor"></a><code><span><span class="keyword">val</span> error_printer : <span><a href="#type-error">error</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Support/Format/index.html#type-formatter">Support.Format.formatter</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_str"><a href="#val-print_str" class="anchor"></a><code><span><span class="keyword">val</span> print_str : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> string)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Not_compatible"><a href="#exception-Not_compatible" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Not_compatible</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-CtxNot_compatible"><a href="#exception-CtxNot_compatible" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">CtxNot_compatible</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-enabled"><a href="#val-enabled" class="anchor"></a><code><span><span class="keyword">val</span> enabled : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-rec_arg"><a href="#type-rec_arg" class="anchor"></a><code><span><span class="keyword">type</span> rec_arg</span><span> = </span></code><ol><li id="type-rec_arg.M" class="def variant constructor anchored"><a href="#type-rec_arg.M" class="anchor"></a><code><span>| </span><span><span class="constructor">M</span> <span class="keyword">of</span> <a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Int.Comp.meta_obj</a></span></code></li><li id="type-rec_arg.V" class="def variant constructor anchored"><a href="#type-rec_arg.V" class="anchor"></a><code><span>| </span><span><span class="constructor">V</span> <span class="keyword">of</span> <a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shiftArg"><a href="#val-shiftArg" class="anchor"></a><code><span><span class="keyword">val</span> shiftArg : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shiftIH"><a href="#val-shiftIH" class="anchor"></a><code><span><span class="keyword">val</span> shiftIH : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift"><a href="#val-shift" class="anchor"></a><code><span><span class="keyword">val</span> shift : 
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub_smaller"><a href="#val-sub_smaller" class="anchor"></a><code><span><span class="keyword">val</span> sub_smaller : <span><span>(<span class="type-var">'a</span> * int)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Int.LF.sub</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-smaller_meta_obj"><a href="#val-smaller_meta_obj" class="anchor"></a><code><span><span class="keyword">val</span> smaller_meta_obj : <span><a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mark_gctx"><a href="#val-mark_gctx" class="anchor"></a><code><span><span class="keyword">val</span> mark_gctx : 
  <span><span><a href="../../Synint/Comp/index.html#type-ctyp_decl">Beluga_syntax.Int.Comp.ctyp_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ctyp_decl">Beluga_syntax.Int.Comp.ctyp_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-struct_smaller"><a href="#val-struct_smaller" class="anchor"></a><code><span><span class="keyword">val</span> struct_smaller : <span><a href="../../Synint/Comp/index.html#type-pattern">Beluga_syntax.Int.Comp.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-order_to_string"><a href="#val-order_to_string" class="anchor"></a><code><span><span class="keyword">val</span> order_to_string : <span><span><span>int <a href="../../Synint/Comp/index.html#type-generic_order">Beluga_syntax.Int.Comp.generic_order</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_valid_args"><a href="#val-is_valid_args" class="anchor"></a><code><span><span class="keyword">val</span> is_valid_args : <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Determine whether the arguments given in a totality declaration are valid. n: number of args tau: type of the recursive function</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_order"><a href="#val-get_order" class="anchor"></a><code><span><span class="keyword">val</span> get_order : 
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Name/index.html#type-t">Syncom.Name.t</a>
   * <span><span>int list</span> option</span>
   * <span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a>)</span>)</span>
    list</span></span></code></div><div class="spec-doc"><p>Converts the list of totality declarations into an induction ordering list</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lookup_dec"><a href="#val-lookup_dec" class="anchor"></a><code><span><span class="keyword">val</span> lookup_dec : 
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> option</span></span></code></div><div class="spec-doc"><p>Looks up a declaration based on a function name</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_order_for"><a href="#val-get_order_for" class="anchor"></a><code><span><span class="keyword">val</span> get_order_for : 
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>int list</span> option</span></span></code></div><div class="spec-doc"><p>Gets the induction order for the function with name `f` Returns None if the</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_var'"><a href="#val-gen_var'" class="anchor"></a><code><span><span class="keyword">val</span> gen_var' : 
  <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> * <a href="../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Int.LF.ctyp</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>(<a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a>)</span>
  * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_var"><a href="#val-gen_var" class="anchor"></a><code><span><span class="keyword">val</span> gen_var : 
  <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-ctyp_decl">Beluga_syntax.Int.LF.ctyp_decl</a> <span class="arrow">&#45;&gt;</span></span>
  <span>(<span>(<a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a>)</span>
   * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a>)</span>
  * <a href="../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Int.LF.ctyp</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_meta_obj"><a href="#val-gen_meta_obj" class="anchor"></a><code><span><span class="keyword">val</span> gen_meta_obj : 
  <span><span>(<a href="../../Syncom/Id/index.html#type-offset">Syncom.Id.offset</a> * <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Int.LF.sub</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Int.LF.ctyp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uninstantiated_arg"><a href="#val-uninstantiated_arg" class="anchor"></a><code><span><span class="keyword">val</span> uninstantiated_arg : <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-generalize"><a href="#val-generalize" class="anchor"></a><code><span><span class="keyword">val</span> generalize : 
  <span><span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-valid_args"><a href="#val-valid_args" class="anchor"></a><code><span><span class="keyword">val</span> valid_args : <span><span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genTypeAgainstSchema"><a href="#val-genTypeAgainstSchema" class="anchor"></a><code><span><span class="keyword">val</span> genTypeAgainstSchema : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-typ">Beluga_syntax.Synint.LF.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-schema">Beluga_syntax.Int.LF.schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'b</span> * <a href="../../Synint/LF/index.html#type-typ">Beluga_syntax.Synint.LF.typ</a>)</span> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_ctx"><a href="#val-gen_ctx" class="anchor"></a><code><span><span class="keyword">val</span> gen_ctx : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Id/index.html#type-cid_schema">Beluga_syntax.Id.cid_schema</a> * <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'d</span> * <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_arg"><a href="#val-gen_arg" class="anchor"></a><code><span><span class="keyword">val</span> gen_arg : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Id/index.html#type-offset">Syncom.Id.offset</a> * <a href="../../Synint/Comp/index.html#type-meta_typ">Beluga_syntax.Synint.Comp.meta_typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Int.LF.ctyp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rec_spine"><a href="#val-rec_spine" class="anchor"></a><code><span><span class="keyword">val</span> rec_spine : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Id/index.html#type-offset">Syncom.Id.offset</a> * <a href="../../Synint/Comp/index.html#type-meta_typ">Beluga_syntax.Synint.Comp.meta_typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * <span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span> * <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rec_spine'"><a href="#val-rec_spine'" class="anchor"></a><code><span><span class="keyword">val</span> rec_spine' : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Id/index.html#type-offset">Syncom.Id.offset</a>
   * <span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * <span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span> * <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_rec_calls"><a href="#val-gen_rec_calls" class="anchor"></a><code><span><span class="keyword">val</span> gen_rec_calls : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../Synint/LF/index.html#type-ctyp_decl">Beluga_syntax.Int.LF.ctyp_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_return_type"><a href="#val-get_return_type" class="anchor"></a><code><span><span class="keyword">val</span> get_return_type : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span> * <span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a>)</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-gen_rec_calls'"><a href="#val-gen_rec_calls'" class="anchor"></a><code><span><span class="keyword">val</span> gen_rec_calls' : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../Synint/Comp/index.html#type-ctyp_decl">Beluga_syntax.Int.Comp.ctyp_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> * <a href="../../Syncom/Id/index.html#type-offset">Syncom.Id.offset</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wf_rec_calls"><a href="#val-wf_rec_calls" class="anchor"></a><code><span><span class="keyword">val</span> wf_rec_calls : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> <a href="../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div><div class="spec-doc"><p>Computes the well-founded recursive calls for the given group of mutual functions on the given contexts. If the list of functions is empty, then an empty context is computed.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-WkViolation"><a href="#exception-WkViolation" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">WkViolation</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wkSub"><a href="#val-wkSub" class="anchor"></a><code><span><span class="keyword">val</span> wkSub : 
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pos"><a href="#val-pos" class="anchor"></a><code><span><span class="keyword">val</span> pos : 
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-typ">Beluga_syntax.Synint.LF.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-weakSub"><a href="#val-weakSub" class="anchor"></a><code><span><span class="keyword">val</span> weakSub : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-convDCtxMod"><a href="#val-convDCtxMod" class="anchor"></a><code><span><span class="keyword">val</span> convDCtxMod : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-convDCtxGen'"><a href="#val-convDCtxGen'" class="anchor"></a><code><span><span class="keyword">val</span> convDCtxGen' : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Int.LF.sub</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-convDCtxGen"><a href="#val-convDCtxGen" class="anchor"></a><code><span><span class="keyword">val</span> convDCtxGen : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Int.LF.sub</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefixDCtx'"><a href="#val-prefixDCtx'" class="anchor"></a><code><span><span class="keyword">val</span> prefixDCtx' : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefixDCtx"><a href="#val-prefixDCtx" class="anchor"></a><code><span><span class="keyword">val</span> prefixDCtx : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefix_hat"><a href="#val-prefix_hat" class="anchor"></a><code><span><span class="keyword">val</span> prefix_hat : 
  <span><span>(<span><a href="../../Synint/LF/index.html#type-ctx_var">Beluga_syntax.Int.LF.ctx_var</a> option</span> * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../Synint/LF/index.html#type-ctx_var">Beluga_syntax.Int.LF.ctx_var</a> option</span> * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-dot_k"><a href="#val-dot_k" class="anchor"></a><code><span><span class="keyword">val</span> dot_k : <span><a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shiftMetaObj"><a href="#val-shiftMetaObj" class="anchor"></a><code><span><span class="keyword">val</span> shiftMetaObj : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>(<a href="../../Syncom/Location/index.html#type-t">Syncom.Location.t</a> * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a>)</span>
   * <a href="../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Int.LF.ctyp</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a>
   * <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a>
   * <a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>(<a href="../../Syncom/Location/index.html#type-t">Syncom.Location.t</a> * <a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a>)</span> * <a href="../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Int.LF.ctyp</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shiftArgs"><a href="#val-shiftArgs" class="anchor"></a><code><span><span class="keyword">val</span> shiftArgs : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a>
   * <a href="../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a>
   * <a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <a href="../../Synint/Comp/index.html#type-ih_arg">Beluga_syntax.Int.Comp.ih_arg</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-annotate'"><a href="#val-annotate'" class="anchor"></a><code><span><span class="keyword">val</span> annotate' : 
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> option</span></span></code></div><div class="spec-doc"><p>Adjusts the given type signature with annotations for the induction arguments according to the given order. Returns <code>Option.None</code> if the order does not match the type, i.e. goes out of bounds.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-strip"><a href="#val-strip" class="anchor"></a><code><span><span class="keyword">val</span> strip : <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></div><div class="spec-doc"><p>Removes all TypInd marks in a computational type.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unimplemented"><a href="#exception-Unimplemented" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unimplemented</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_occurs"><a href="#val-no_occurs" class="anchor"></a><code><span><span class="keyword">val</span> no_occurs : 
  <span><a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_positive"><a href="#val-check_positive" class="anchor"></a><code><span><span class="keyword">val</span> check_positive : 
  <span><a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-positive"><a href="#val-positive" class="anchor"></a><code><span><span class="keyword">val</span> positive : 
  <span><a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-less_dctx"><a href="#val-less_dctx" class="anchor"></a><code><span><span class="keyword">val</span> less_dctx : <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/LF/index.html#type-dctx">Beluga_syntax.Int.LF.dctx</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal_meta_obj"><a href="#val-equal_meta_obj" class="anchor"></a><code><span><span class="keyword">val</span> equal_meta_obj : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-less_meta_obj"><a href="#val-less_meta_obj" class="anchor"></a><code><span><span class="keyword">val</span> less_meta_obj : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-leq_meta_obj"><a href="#val-leq_meta_obj" class="anchor"></a><code><span><span class="keyword">val</span> leq_meta_obj : 
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_meta_obj"><a href="#val-find_meta_obj" class="anchor"></a><code><span><span class="keyword">val</span> find_meta_obj : 
  <span><a href="../../Synint/Comp/index.html#type-meta_spine">Beluga_syntax.Int.Comp.meta_spine</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Int.Comp.meta_obj</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_target"><a href="#val-get_target" class="anchor"></a><code><span><span class="keyword">val</span> get_target : 
  <span><span><a href="../../Synint/LF/index.html#type-ctyp_decl">Synint.LF.ctyp_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-ctyp_decl">Synint.LF.ctyp_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span>
  * <a href="../../Synint/Comp/index.html#type-meta_spine">Beluga_syntax.Int.Comp.meta_spine</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mS_size"><a href="#val-mS_size" class="anchor"></a><code><span><span class="keyword">val</span> mS_size : <span><a href="../../Synint/Comp/index.html#type-meta_spine">Beluga_syntax.Int.Comp.meta_spine</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : 
  <span><a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Synint.Comp.meta_obj</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stratify"><a href="#val-stratify" class="anchor"></a><code><span><span class="keyword">val</span> stratify : 
  <span><a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stratifyAll"><a href="#val-stratifyAll" class="anchor"></a><code><span><span class="keyword">val</span> stratifyAll : 
  <span><a href="../../Syncom/Id/index.html#type-cid_comp_typ">Beluga_syntax.Id.cid_comp_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_comp_inductive"><a href="#val-is_comp_inductive" class="anchor"></a><code><span><span class="keyword">val</span> is_comp_inductive : 
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Decides whether a data object is something we're doing induction on, i.e. it's a computational variable whose type is TypInd or with a WF flag</p><p>This is similar to the logic used in check.ml to determine the kind of a branch: <code>Ind</code>DataObj or <code>Ind</code>IndexObj.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_meta_inductive"><a href="#val-is_meta_inductive" class="anchor"></a><code><span><span class="keyword">val</span> is_meta_inductive : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mfront">Beluga_syntax.Int.LF.mfront</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Decides whether an index object is something we're doing induction on, i.e. it's a metavariable with the Inductive flag set when we look it up in the meta-context.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_inductive_split"><a href="#val-is_inductive_split" class="anchor"></a><code><span><span class="keyword">val</span> is_inductive_split : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Checks if the scrutinee of a case is on an inductive computational variable or an inductive meta-variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-requires_checking"><a href="#val-requires_checking" class="anchor"></a><code><span><span class="keyword">val</span> requires_checking : 
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Int.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Decides, in the context of a given list of totality declarations, whether the given function (name) requires totality checking. A function requires totality checking only if its totality declaration in the given list, if any, is an `inductive declaraction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-annotate"><a href="#val-annotate" class="anchor"></a><code><span><span class="keyword">val</span> annotate : 
  <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[&gt; <span>`inductive of <a href="../../Synint/Comp/index.html#type-order">Beluga.Order.I.order</a></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></div><div class="spec-doc"><p>Applies the given induction order to produce an annotated type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-select_ihs"><a href="#val-select_ihs" class="anchor"></a><code><span><span class="keyword">val</span> select_ihs : 
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Int.LF.ctx</a></span></span></code></div><div class="spec-doc"><p>Filters an ihctx to contain only those IHs for the given function name.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drop_args"><a href="#val-drop_args" class="anchor"></a><code><span><span class="keyword">val</span> drop_args : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Synint.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Synint.LF.ctx</a></span></span></code></div><div class="spec-doc"><p>Drops n leading arguments from all recursive calls in a given ihctx.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-drop_arg"><a href="#val-drop_arg" class="anchor"></a><code><span><span class="keyword">val</span> drop_arg : 
  <span><span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Synint.LF.ctx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-ih_decl">Beluga_syntax.Int.Comp.ih_decl</a> <a href="../../Synint/LF/index.html#type-ctx">Beluga_syntax.Synint.LF.ctx</a></span></span></code></div><div class="spec-doc"><p>Drops one argument from all recursive calls in a given ihctx.</p></div></div></div></body></html>
