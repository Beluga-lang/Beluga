% general congruence: if E <-> E' then M[E/x] <-> M[E'/x]

schema ctx = some [a:obj] term a;

rec cong : {g:(ctx)*} {M::(term B)[g, x:term A]} (conv (E ..) (E' ..))[g] -> (conv (M .. (E ..)) (M .. (E' ..)))[g] =
   FN g => mlam M => fn c => case ([g,x:term _] M .. x) of

    | [g, x:term A] x => 
      c
      
      % | {#p:: (term B)[g]} [g, x:term A] #p .. => [g] c_refl
    | [g, x:term A] #p .. => 
      [g] c_refl
      
    | [g, x:term A] lunit => 
      [g] c_refl

    | [g, x:term A] (lpair (E1 .. x) (E2 .. x)) =>
      let [g] (CP1 ..) = cong [g] <g, x . E1 .. x> c in
      let [g] (CP2 ..) = cong [g] <g, x . E2 .. x> c in
          [g] (c_pair (CP1 ..) (CP2 ..))
 
    | [g, x:term A] (lfst (E .. x)) => 
      let [g] (CP ..) = cong [g] <g, x . E .. x> c in
          [g] (c_fst (CP ..))

    | [g, x:term A] (lsnd (E .. x)) => 
      let [g] (CP ..) = cong [g] <g, x . E .. x> c in
          [g] (c_snd (CP ..))

% cong_lam : cong (\x . (llam (\y . E x y))) (\c . (c_lam (\y . (CP c y))))
%             <- ({y: term _} cong (\x . y) (\c . c_refl) -> cong (\x . E x y) (\c . CP c y)).

    | [g, x:term A] (llam (\y . E .. x y)) =>
      let [g, y:term _] (CP .. y) = cong [g, y:term _] <g, y, x . E .. x y> c in
          [g] (c_lam (\y . CP .. y))

 
    | [g, x:term A] (lapp (E1 .. x) (E2 .. x)) =>
      let [g] (CP1 ..) = cong [g] <g, x . E1 .. x> in
      let [g] (CP2 ..) = cong [g] <g, x . E2 .. x> in
          [g] (c_app (CP1 ..) (CP2 ..))
;
