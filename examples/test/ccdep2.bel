% coverage example:
%  context matching with dependent arguments

bool: type.
tt: bool.
ff: bool.

dep : bool -> bool -> type.
deptt-tt : dep tt tt.
depff-ff : dep ff ff.
depff-tt : dep ff tt.
deptt-ff : dep tt ff.

letter : type.
aa : letter.
bb : letter.
trip : bool -> bool -> letter -> type.
triptt-tt-aa : trip tt tt aa.
triptt-ff-aa : trip tt ff aa.
tripff-tt-aa : trip ff tt aa.
tripff-ff-aa : trip ff ff aa.
triptt-tt-bb : trip tt tt bb.
triptt-ff-bb : trip tt ff bb.
tripff-tt-bb : trip ff tt bb.
tripff-ff-bb : trip ff ff bb.

schema dep-ctx = some [b1:bool, b2:bool] dep b1 b2;
schema letter-ctx = some [b1:bool, b2:bool, m:letter] trip b1 b2 m;
schema bool-ctx = bool;


rec depsplitWrong1 : {g:(dep-ctx)*} (bool)[g, x : dep T1 T2]  ->  bool[ ] =
FN g => fn d => case d of %not
 | [g, xx:dep ff ff] UU .. xx => [] ff
;

rec depsplitWrong2 : {g:(dep-ctx)*} (bool)[g, x : dep T1 T2]  ->  bool[ ] =
FN g => fn d => case d of %not
 | [g, xx:dep ff ff] UU1 .. xx => [] ff
 | [g, xx:dep ff tt] UU2 .. xx => [] ff
;


rec depsplitOK3 : {g:(dep-ctx)*} (bool)[g, x : dep T1 T2]  ->  bool[ ] =
FN g => fn d => case d of
 | [g, xx:dep tt ff] UU1 .. xx => [] ff
 | [g, xx:dep ff tt] UU2 .. xx => [] ff
 | [g, xx:dep tt tt] UU3 .. xx => [] ff
 | [g, xx:dep ff ff] UU4 .. xx => [] ff
% | [g, xx:dep WW ff] UU4 .. xx => [] ff
% | [g, xx:dep ff ZZ] UU4 .. xx => [] ff
;

rec depsplitWrong3 : {g:(dep-ctx)*} (bool)[g, x : dep T1 T2]  ->  bool[ ] =
FN g => fn d => case d of %not
 | [g, xx:dep tt ff] UU1 .. xx => [] ff
 | [g, xx:dep ff tt] UU2 .. xx => [] ff
% | [g, xx:dep tt tt] UU3 .. xx => [] ff
 | [g, xx:dep ff ff] UU4 .. xx => [] ff
;



rec depsplitOKConstrained : {g:(dep-ctx)*} (bool)[g, x : dep tt ff]  ->  bool[ ] =
FN g => fn d => case d of
 | [g, xx:dep tt ff] UU1 .. xx => [] ff
;

rec depsplitWrongConstrained2 : {g:(dep-ctx)*} (bool)[g, x : dep tt T2]  ->  bool[ ] =
FN g => fn d => case d of %not
 | [g, xx:dep tt ff] UU1 .. xx => [] ff
;



rec letterFn : {g:(letter-ctx)*} (bool)[g, x : trip tt BBB aa]  ->  bool[ ] =
FN g => fn d => case d of
 | [g, xx:trip tt ff aa] UU1 .. xx => [] ff
 | [g, xx:trip tt tt aa] UU1 .. xx => [] ff
;



rec depsplitOKConstrained2 : {g:(dep-ctx)*} (bool)[g, x : dep tt T2]  ->  bool[ ] =
FN g => fn d => case d of
 | [g, xx:dep tt ff] UU1 .. xx => [] ff
 | [g, xx:dep tt tt] VV1 .. xx => [] ff
;


rec depsplitOK2 : {g:(dep-ctx)*} (bool)[g, x : dep T1 T2]  ->  bool[ ] =
FN g => fn d => case d of
 | [g, xx:dep W1 W2] U .. xx => [] tt
;



% let ok_call = depsplitWrong [] ([x:dep tt] deptt);
%  
% let bad_call = depsplitWrong [] ([x:dep ff] tt);
