term : type.
z    : term.
tt   : term.
ff   : term.
suc  : term -> term.
eq   : term -> term -> term.
if   : term -> term -> term -> term.
letv : term -> (term -> term) -> term.

tp   : type.
nat  : tp.
bool : tp.

oft  : term -> tp -> type.
o_tt : oft tt bool.
o_ff : oft ff bool.
o_z  : oft z nat.
o_s  : {E: term} oft E nat -> oft (suc E) nat.
o_if : {E: term} {E1: term} {E2: term} {T: tp}
       oft E bool -> oft E1 T -> oft E2 T
       -> oft (if E E1 E2) T.
o_let: {E1: term} {T1: tp} {E2: term -> term} {T2: tp}
       oft E1 T1 -> ({x:term} oft x T1 -> oft (E2 x) T2)
       -> oft (letv E1 E2) T2.

% schema W = some [T:tp] block {x:term} oft x T;

% rec infer : {g:(W)*} {U::term[g]} sigma(T::tp[]) (oft U[id(g)] T[.])[g] =
%     FN g => mlam U =>
%         case (box(g . U[id(g)]) : term[g]) of
%             box(g . z)  : term[g]           => pack <. nat , box(g . o_z)>
%           | box(g . tt) : term[g]           => pack <. bool , box(g . o_tt)>            
% %           | {T::tp[]} {p :: (sigma(x:term) oft x T[.])[g]}
% %             box(g. fst p[id(g)]) : term[g] => pack <. T[.] , box(g. snd p[id(g)])>
% %           | {E1::exp[g]} {E2::exp[g, x:exp]}
% %             box(g. letv E1[id(g)] \x.E2[id(g), x]) : term[g] =>
% %                 let
% %                     val pack < . S1[.], box(g. D1[id(g)]) > = infer [g] <g . E1[id(g)]>
% %                     val pack < . S2[.], box(g. D2[id(g)]) > = infer [g, d:Sigma x:exp. oft x S1[.]]
% %                     <g, d:Sigma x:exp. oft x S1[.] . E2[id(g), fst d] >
% %                 in
% %                     pack < . S2[.] , box(g. o_l D1[id(g)] \x.\u.D2[id(g); (x, u)]) > % TODO confirm change from <x, u> to (x, u)
% %                 end
% ;
