% Proof that a big step evaluation relation for lambda terms is deterministic
% Author: Andrew Cave

notLam : exp -> type.
notLam : notLam (app M N).

eval : exp -> exp -> type. %name eval E.
eval_lam : ({x:exp} eval x x -> notLam x -> eval (M x) (N x))
           -> eval (lam M) (lam N).
eval_app1 : eval M (lam M') -> eval (M' N) R -> eval (app M N) R.
eval_app2 : eval M M' -> notLam M' -> eval N N' -> eval (app M N) (app M' N').

schema evctx = block x:exp, u:eval x x, t:notLam x, _v:eq x x;

rec eval_respects_eq : 
(g:evctx) [g |- eq (M[..]) (N[..])] -> [g |- eval (M[..]) (R[..])]
-> [g |- eval (N[..]) (R[..])] =
% / total f (eval_respects_eq g m n r e f ) /
fn d => fn f => case f of
 | [g |- eval_app2 (D1[..]) (NL[..]) (D2[..])] =>
   let [g |- eq_app (F1[..]) (F2[..])] = d in
   let [g |- E1[..]] = eval_respects_eq [g |- F1[..]] [g |- D1[..]] in
   let [g |- E2[..]] = eval_respects_eq [g |- F2[..]] [g |- D2[..]] in
   [g |- eval_app2 (E1[..]) (NL[..]) (E2[..])]

 | [g |- eval_lam (\x.\u.\v. M')] =>
   let [g |- eq_lam (\x.\u. F1)] = d in
   % [g, x:exp, u:eq x x |- eq (M) (N)]
   let
     [g,b:block x:exp, v:eval x x, _t:notLam x,u:eq x x |-  D1[..,b.1,b.2 b.3]] =
     eval_respects_eq [g,b:block (x:exp, v:eval x x, _t:notLam x, u:eq x x) |-  F1[.. b.1 b.4]]
                      [g,b |- M'[..,b.1,b.2 b.3]] in
   [g |- eval_lam (\x.\u.\v. D1)]

 | {D1 : [g |- eval (X3[..]) (lam (\y1. Y2[.. y1]))]}
   {D2 : [g |- eval Y2[.., Y3] X2]}
   [g |- eval_app1 (D1[..]) (D2[..])] =>
   let [g |- eq_app (F1[..]) (F2[..])] = d in
   let [g |- E1[..]] = eval_respects_eq [g |- F1[..]] [g |- D1[..]] in
   let [g |- E2[..]] = subst_respects_eq [g] [ g,x  |-  Y2 ] [g |- F2[..]] in
   let [g |- E3[..]] = eval_respects_eq [g |- E2[..]] [g |- D2[..]] in
   [g |- eval_app1 (E1[..]) (E3[..])]

 | [g |- #p.2[..]] =>
   let [g |- #q.4[..]] = d in f

;

rec deterministic : (g:evctx) [g |- eval (M[..]) (R[..])] -> [g |- eval (M[..]) (R'[..])]
-> [g |- eq (R[..]) (R'[..])] =  
% / total d (deterministic g m r r' d)/
fn d => fn f =>
case d of
| [g |- eval_app2 (D1[..]) (NL[..]) (D2[..])] =>
  (case f of
    | [g |- eval_app2 (F1[..]) (NL'[..]) (F2[..])] =>
      let [g |- E1[..]] = deterministic [g |- D1[..]] [g |- F1[..]] in
      let [g |- E2[..]] = deterministic [g |- D2[..]] [g |- F2[..]] in
      [g |- eq_app (E1[..]) (E2[..])]

    | [g |- eval_app1 (F1[..]) (F2[..])] =>
      let [g |- eq_lam (\x.\u. E1)] =
         deterministic [g |- D1[..]] [g |- F1[..]] in
       impossible [g |- NL[..]] in [g])

| [g |- eval_lam (\x.\u.\v. D1)] =>
  let [g |- eval_lam (\x.\u.\v. F1)] = f in
  let [g,b:block x:exp, v:eval x x, _t:notLam x, u:eq x x |-  E1[.. b.1 b.4]] =
    deterministic
     [g,b:block x:exp, v:eval x x, _t:notLam x, u:eq x x |-  D1[..,b.1,b.2 b.3]]
     [g,b |- F1[..,b.1,b.2 b.3]] in
  [g |- eq_lam (\x.\u. E1)]

| [g |- eval_app1 (D1[..]) (D2[..])] : [g |- (eval (app (M[..]) (N[..])) (R[..]))] =>
  (case f of
    | [g |- eval_app1 (F1[..]) (F2[..])] =>
      let [g |- eq_lam (\x.\u. E1)] = deterministic [g |- D1[..]] [g |- F1[..]] in
      let [g |- E2[..]] = eq_refl [g] [g |- N[..] ] in
      let [g |- E3[..]] = eq_sym [g |- E1[.. N E2]] in
      let [g |- F3[..]] = eval_respects_eq [g |- E3[..]] [g |- F2[..]] in
      deterministic [g |- D2[..]] [g |- F3[..]]

    | [g |- eval_app2 (F1[..]) (NL[..]) (F2[..])] =>
      let [g |- eq_lam (\x.\u. E1)] =
         deterministic [g |- D1[..]] [g |- F1[..]] in
      impossible [g |- NL[..]] in [g])

| [g |- #p.2[..]] => let [g |- #q.2[..]] = f in eq_refl [g] [g |- _ ]

;


