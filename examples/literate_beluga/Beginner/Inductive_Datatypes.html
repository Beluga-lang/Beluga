<html>
<head>
	<style type="te../../css">
		body {
			padding: 2em 1em 2em 1em;
			margin: 0;
			font-family: sans-serif;
			color: black;
			background: white;}
		a{text-decoration:none;}
		a:link { color: #00C; background: transparent }
		a:visited { color: #00C; background: transparent }
		a:active { color: #C00; background: transparent }
		keyword { color: #3333cc ; background: transparent }
		p {display: inline;}
		pre {
			border: 1px dashed maroon;  display:block; 
			padding:8px; background-color: #dddddd;}
		code {
			background-color: #dddddd;
			color: black; font-family: "courier";margin:0; 
			white-space: pre-wrap; }
		.typ {color: #660000; font-weight:bold}
		.constructor {color: #335C85; font-weight:bold}
		.function {color: #660033; font-weight:bold}
		.schema {color: #6600CC; font-weight:bold}
	</style>	</head>
<body>

<p><h2>Algorithmic Equality for the Untyped Lambda-calculus (R-version)</h2>This case-study is a mechanization of <a href="https://github.com/pientka/ORBI/blob/master/benchmarks/EqualUntyped.orbi" target="_blank">EqualUntyped.orbi</a>. We examine Theorems 7, 10, & 22 from <a href="orbi-jar.pdf" target="_blank">(Felty et al, 2014)</a>, proving each by the <i>context relation</i> (R) approach.</p>
<p><ul>
<li><b>Theorem 7 (Admissibility of Reflexivity):</b> If  <code>g &#8866; is_tm M</code> then <code>g &#8866; aeq M M</code>.</li><br>
<li><b>Theorem 10 (Admissibility of Symmetry and Transitivity):</b>
<ol> <br>
<li>If <code>g:xaG</code> and <code>g &#8866; aeq M L</code> and <code>g &#8866; aeq L N</code> then <code>g &#8866; aeq M N</code>.</li><br>
<li>If <code>g:xaG</code> and <code>g &#8866; aeq M N</code> then <code>g &#8866; aeq N M</code>.</li><br>
</ol></li>
<li><b>Theorem 22 (Completeness):</b> If <code>g:daG</code> and <code>g &#8866; deq M N</code> then <code>g &#8866; aeq M N</code>.</li><br>
</ul>

We have seen that Beluga elegantly supports proofs using generalized contexts. Here we exploit the ability to define context relations in Beluga to implement proofs using context relations (R Version). To illustrate the idea, we go back to the reflexivity proof for algorithmic equality.</p>
<p><h3>Syntax</h3>
Untyped lambda-terms are introduced with LF-level declarations. The context schemas translate directly from the ORBI file. </p><br><pre><code>
<span class="typ" id="tm">tm</span> : <keyword>type</keyword>.<br>
<span class="constructor" id="app">app</span> : <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a>.<br>
<span class="constructor" id="lam">lam</span> : (<a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a>) &#x2192 <a href="#tm">tm</a>.<br>
<span class="typ" id="aeq">aeq</span> : <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a> &#x2192 <keyword>type</keyword>.<br>
<span class="constructor" id="ae_l">ae_l</span> : {x : <a href="#tm">tm</a>} (<a href="#aeq">aeq</a> x x &#x2192 <a href="#aeq">aeq</a> (M x) (N x)) &#x2192 <a href="#aeq">aeq</a> (<a href="#lam">lam</a> (\x. M x)) (<a href="#lam">lam</a> (\x. N x)).<br>
<span class="constructor" id="ae_a">ae_a</span> : <a href="#aeq">aeq</a> M1 N1 &#x2192 <a href="#aeq">aeq</a> M2 N2 &#x2192 <a href="#aeq">aeq</a> (<a href="#app">app</a> M1 M2) (<a href="#app">app</a> N1 N2).</code></pre>
<p></p><br><pre><code>
<keyword>schema</keyword> <span class="schema" id="xG">xG</span> = <a href="#tm">tm</a>;<br>
<keyword>schema</keyword> <span class="schema" id="xaG">xaG</span> = <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x);</code></pre>
<p>
<h2> Context Relationships via Inductive Datatypes</h2>

The key to express context weakening and strengthening is the ability to relate two contexts via a substitution. In Beluga, we can describe context relations using <i>inductive datatypes</i> as a relation between context <code>phi</code>, context <code>psi</code>, and a substitution <code>#S</code> that maps variables from <code>phi</code> to the context <code>psi</code>, formally <code>#S:psi &#8866; phi</code> as follows:</p><br><pre><code><br>
<span class="typ" id="Ctx_xaR">Ctx_xaR</span> : {phi : <a href="#xG">xG</a>}
({psi : <a href="#xaG">xaG</a>} ([psi &#x22A2 phi]
<keyword>ctype</keyword>)).<br>
<span class="constructor" id="Nil_xa">Nil_xa</span> : Ctx_xaR [] [] [ &#x22A2  ].<br>
<span class="constructor" id="Cons_xa">Cons_xa</span> : (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 Ctx_xaR [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [b, psi &#x22A2  #S[..] b.1].</code></pre>
<p>We again use first-class substitution variables <code>#S</code> of type <code>[psi &#8866; phi]</code> to move from the context <code>phi</code> to the context <code>psi</code>. If <code>#S</code> relates <code>phi</code> and <code>psi</code>, then the substitution <code>#S b.1</code> relates context <code>phi, x:tm</code> to <code>psi, b:block (x:tm,u:aeq x x)</code> via constructor <code>Cons_xaR</code>.</p><br><pre><code><br>
<span class="typ" id="EqV">EqV</span> : {phi : <a href="#xG">xG</a>}
({psi : <a href="#xaG">xaG</a>} ([psi &#x22A2 phi]
({x : [phi &#x22A2 <a href="#tm">tm</a>]}
({y : [psi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>)))).<br>
<span class="constructor" id="EqV_v">EqV_v</span> : EqV [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2  #S[..] b.1] ([phi, x : <a href="#tm">tm</a> &#x22A2 x]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.1]).<br>
<span class="constructor" id="EqV_p">EqV_p</span> : (EqV [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) &#x2192 EqV [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [b, psi &#x22A2  #S[..] b.1] ([phi, x : <a href="#tm">tm</a> &#x22A2 (#p ..)]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 #q.1 ..]).<br><br>
<span class="typ" id="Eq">Eq</span> : {phi : <a href="#xG">xG</a>}
({psi : <a href="#xaG">xaG</a>} ([psi &#x22A2 phi]
({y1 : [phi &#x22A2 <a href="#tm">tm</a>]}
({z : [psi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>)))).<br>
<span class="constructor" id="Eq_v">Eq_v</span> : (EqV [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) &#x2192 Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..]).<br>
<span class="constructor" id="Eq_a">Eq_a</span> : (Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 M ..]) ([psi &#x22A2 M' ..])) &#x2192 (Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 N ..]) ([psi &#x22A2 N' ..])) &#x2192 Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 <a href="#app">app</a> (M ..) (N ..)]) ([psi &#x22A2 <a href="#app">app</a> (M' ..) (N' ..)]).<br>
<span class="constructor" id="Eq_l">Eq_l</span> : (Eq [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2  #S[..] b.1] ([phi, x : <a href="#tm">tm</a> &#x22A2 M .. x]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 M' .. b.1])) &#x2192 Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 <a href="#lam">lam</a> (\x. M .. x)]) ([psi &#x22A2 <a href="#lam">lam</a> (\x. M' .. x)]).</code></pre>
<p>
<h3>Proof of Reflexivity, Compact version</h3>
The recursive function <code>refl</code> of type <code>{phi:xG}{M: [phi &#8866;  tm]} Ctx_xaR [phi] [psi] [ psi &#8866; #S[..] ] -> [psi &#8866;  aeq (M #S[..]) (M #S[..])]</code>:  for all contexts <code>phi</code> and <code>psi</code> that have schema <code>xG</code> and <code>xaG</code>, respectively, if we have a substitution <code>#S</code> s.t. <code>#S:psi &#8866; phi</code> then for all terms <code>M</code> depending on <code>phi</code>, we have a proof that <code>[ psi &#8866; aeq (#p #S[..]) (#p #S[..])]</code>." Since the term <code>M</code> depends only on the context <code>phi</code>, it is explicitly weakened through applying <code>#S</code> to move it to the context <code>psi</code>.</p><br><pre><code>
<keyword>rec</keyword> <span class="function" id="ctx_membership">ctx_membership</span> : {#p : [phi &#x22A2 <a href="#tm">tm</a>]} (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> ((#p #S[..])) ((#p #S[..]))] = <keyword>mlam</keyword> # p &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>let</keyword>  (cr : Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) = cr <keyword>in</keyword>
<keyword>case</keyword> [phi &#x22A2 (#p ..)] <keyword>of</keyword>
| [phi, x : <a href="#tm">tm</a> &#x22A2 x]   &#x21D2 
   <keyword>let</keyword>  Cons_xa cr'  = cr <keyword>in</keyword>
    <keyword>let</keyword>  (cr' : Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) = cr' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.2]

| [phi, x : <a href="#tm">tm</a> &#x22A2 (#p ..)]   &#x21D2 
   <keyword>let</keyword>  Cons_xa cr'  = cr <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E ..] = <a href="#ctx_membership">ctx_membership</a> [phi &#x22A2 (#p ..)] cr' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E ..]
 <br>
<keyword>rec</keyword> <span class="function" id="refl">refl</span> : {phi : <a href="#xG">xG</a>} {M : [phi &#x22A2 <a href="#tm">tm</a>]} (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M #S[..]) (M #S[..])] = <keyword>FN</keyword> phi &#x21D2 <keyword>mlam</keyword> M &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>case</keyword> [phi &#x22A2 M ..] <keyword>of</keyword>
| [phi &#x22A2 (#p ..)]   &#x21D2 
   <a href="#ctx_membership">ctx_membership</a> [phi &#x22A2 (#p ..)] cr 
| [phi &#x22A2 <a href="#app">app</a> (M ..) (N ..)]   &#x21D2 
   <keyword>let</keyword>  [psi &#x22A2 D1 ..] = <a href="#refl">refl</a> [phi] [phi &#x22A2 M ..] cr <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 D2 ..] = <a href="#refl">refl</a> [phi] [phi &#x22A2 N ..] cr <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (D1 ..) (D2 ..)] 
| [phi &#x22A2 <a href="#lam">lam</a> (\x. M .. x)]   &#x21D2 
   <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D .. b.1 b.2] = <a href="#refl">refl</a> [phi, x : <a href="#tm">tm</a>] [phi, x : <a href="#tm">tm</a> &#x22A2 M .. x] (Cons_xa cr) <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (\x. (\u. D .. x u))]
 </code></pre>
<p>The proof is implemented as a recursive function over the term M. We again consider three possible cases: If we have an application <code>[ phi &#8866; app (M1 ::)(M2 ::)]</code>, we appeal to the induction hypothesis on <code>[phi &#8866; M1 ..]</code> and <code>[ &#8866; M2 ::]</code> by making a recursive call. Since the context <code>phi</code> and the context <code>psi</code> do not change, we can simply make the recursive all on <code>[phi &#8866; M1 ::]</code> and <code>[phi &#8866; M2 ::]</code> respectively using the relation <code>cr</code>.
<br><br>
When we have <code>[phi &#8866; lam \x.M :: x]</code>, we want to appeal to the induction hypothesis on <code>[phi &#8866; x:tm. M ::x]</code>. To make the recursive call, we also need a witness relating the context <code>[phi &#8866; x:tm. M ::x]</code> to the context <code>[psi, b:block (x:tm,u:aeq x x)]</code>. Recall that <code>cr</code> stands for <code>Ctx_xaR [phi] [psi] [psi &#8866; #S]</code>. Therefore, by <code>Cons_xa</code>, we know there exists <code>Ctx_xaR [phi ,x:tm] [psi ,b:block (x:tm,u:aeq x x)] [psi, b &#8866; #S b.1]</code> and we appeal to the induction hypothesis by <code>reflR [phi,x:tm] [phi,x:tm.M ::x] (Cons_xa cr)</code>.
<br><br>
Finally, we take a close look at the variable case. For clarity, we follow the outline of the proof from the companion paper (Felty et al, 2014) and factor out the Context Membership Lemma. We distinguish two different cases depending on the position of the variable in the context by pattern matching on the shape of <code>phi</code>. If <code>[phi,x:tm &#8866; x]</code>, then we inspect the context relation <code>cr</code>. We note that pattern matching forces the original context <code>phi</code> to be <code>phi,x:tm</code>. By pattern matching on <code>cr'</code>, we observe that there exists a relation <code>cr'</code>, s.t. <code>Ctx_xaR [phi] [psi] [psi &#8866; #S]</code>. Moreover, <code>psi = psi,b:block (x:tm,u:aeq x x)</code> and <code>#S = #S b.1</code> where the left hand side denotes the original context and substitution, while the right hand side shows the context and substitution refinement after pattern matching. We must show that there exists a proof for <code>aeq x x</code> in the context <code>psi, b:block (x:tm,u:aeq x x)</code>. This is simply <code>b.2</code>.</p>
<p><br><br>
Following we generalize reasoning about terms which contain substitution variables, reasoning explicitly about equality between terms <code>M</code> and <code>M #S[..]</code>. Since we cannot pattern match directly on <code>M #S[..]</code> (because <code>#S</code> is a general substitution and we do not enforce on the type-level that it is a variable-variable substitution) we cannot use unification to solve equations; If <code>#S</code> would be known to be a pattern substitution, then we could solve equations such as <code>M #S[..] = app (M1 ..) (M2 ..)</code>; we hence encode such equalities explicitly.

<h3>Proof of Reflexivity, Expanded</h3></p><br><pre><code>
<keyword>rec</keyword> <span class="function" id="ctx_member">ctx_member</span> : {#p : [phi &#x22A2 <a href="#tm">tm</a>]} (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 (EqV [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 M ..])) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M ..) (M ..)] = <keyword>mlam</keyword> # p &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>let</keyword>  (cr : Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) = cr <keyword>in</keyword>
<keyword>case</keyword> [phi &#x22A2 (#p ..)] <keyword>of</keyword>
| [phi, x : <a href="#tm">tm</a> &#x22A2 x]   &#x21D2 
   <keyword>let</keyword>  Cons_xa cr'  = cr <keyword>in</keyword>
    <keyword>let</keyword>  EqV_v  = m <keyword>in</keyword>
    <keyword>let</keyword>  (cr' : Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) = cr' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.2]

| [phi, x : <a href="#tm">tm</a> &#x22A2 (#p ..)]   &#x21D2 
   <keyword>let</keyword>  Cons_xa cr'  = cr <keyword>in</keyword>
    <keyword>let</keyword>  EqV_p m'  = m <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E ..] = <a href="#ctx_member">ctx_member</a> [phi &#x22A2 (#p ..)] cr' m' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E ..]
 <br>
<keyword>rec</keyword> <span class="function" id="reflR">reflR</span> : {phi : <a href="#xG">xG</a>} {M : [phi &#x22A2 <a href="#tm">tm</a>]} (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 (Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 M ..]) ([psi &#x22A2 M' ..])) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M' ..) (M' ..)] = <keyword>FN</keyword> phi &#x21D2 <keyword>mlam</keyword> M &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>case</keyword> [phi &#x22A2 M ..] <keyword>of</keyword>
| [phi &#x22A2 (#p ..)]   &#x21D2 
   <keyword>let</keyword>  Eq_v m'  = m <keyword>in</keyword>
    <a href="#ctx_member">ctx_member</a> [phi &#x22A2 (#p ..)] cr m' 
| [phi &#x22A2 <a href="#app">app</a> (M ..) (N ..)]   &#x21D2 
   <keyword>let</keyword>  Eq_a m1 m2  = m <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 D1 ..] = <a href="#reflR">reflR</a> [phi] [phi &#x22A2 M ..] cr m1 <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 D2 ..] = <a href="#reflR">reflR</a> [phi] [phi &#x22A2 N ..] cr m2 <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (D1 ..) (D2 ..)] 
| [phi &#x22A2 <a href="#lam">lam</a> (\x. M .. x)]   &#x21D2 
   <keyword>let</keyword>  Eq_l m'  = m <keyword>in</keyword>
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D .. b.1 b.2] = <a href="#reflR">reflR</a> [phi, x : <a href="#tm">tm</a>] [phi, x : <a href="#tm">tm</a> &#x22A2 M .. x] (Cons_xa cr) m' <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (\x. (\u. D .. x u))]
 <br>
<keyword>rec</keyword> <span class="function" id="transV">transV</span> : (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 (EqV [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 M ..]) ([psi &#x22A2 #p.1 ..])) &#x2192 (EqV [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 N ..]) ([psi &#x22A2 #p.1 ..])) &#x2192 (EqV [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 L ..]) ([psi &#x22A2 #p.1 ..])) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (#p.1 ..) (#p.1 ..)] = <keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> n &#x21D2 <keyword>fn</keyword> l &#x21D2 <keyword>case</keyword> m <keyword>of</keyword>
|  ;  . EqV_v    &#x21D2 
   <keyword>let</keyword>  EqV_v  = n <keyword>in</keyword>
    <keyword>let</keyword>  EqV_v  = l <keyword>in</keyword>
    <keyword>let</keyword>  Cons_xa cr'  = cr <keyword>in</keyword>
    <keyword>let</keyword>  (cr' : Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) = cr' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.2]

|  ;  . EqV_p m'    &#x21D2 
   <keyword>let</keyword>  EqV_p n'  = n <keyword>in</keyword>
    <keyword>let</keyword>  EqV_p l'  = l <keyword>in</keyword>
    <keyword>let</keyword>  Cons_xa cr'  = cr <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E ..] = <a href="#transV">transV</a> cr' m' n' l' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E ..]
 <br>
<keyword>rec</keyword> <span class="function" id="transR">transR</span> : (Ctx_xaR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 (Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 M ..]) ([psi &#x22A2 M' ..])) &#x2192 (Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 N ..]) ([psi &#x22A2 N' ..])) &#x2192 (Eq [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 L ..]) ([psi &#x22A2 L' ..])) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M' ..) (N' ..)] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (N' ..) (L' ..)] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M' ..) (L' ..)] = <keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> n &#x21D2 <keyword>fn</keyword> l &#x21D2 <keyword>fn</keyword> d1 &#x21D2 <keyword>fn</keyword> d2 &#x21D2 <keyword>case</keyword> d1 <keyword>of</keyword>
| [psi &#x22A2 #p.2 ..]   &#x21D2 
   <keyword>let</keyword>  [psi &#x22A2 #q.2 ..] = d2 <keyword>in</keyword>
    <keyword>let</keyword>  Eq_v m'  = m <keyword>in</keyword>
    <keyword>let</keyword>  (m' : EqV [phi] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2  #S[..]] ([phi &#x22A2 (#r ..)]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 #q.1 ..])) = m' <keyword>in</keyword>
    <a href="#ctx_member">ctx_member</a> [phi &#x22A2 (#r ..)] cr m' 
| [psi &#x22A2 <a href="#ae_a">ae_a</a> (D1 ..) (D2 ..)]   &#x21D2 
   <keyword>let</keyword>  [psi &#x22A2 <a href="#ae_a">ae_a</a> (F1 ..) (F2 ..)] = d2 <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a m1 m2  = m <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a n1 n2  = n <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a l1 l2  = l <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E1 ..] = <a href="#transR">transR</a> cr m1 n1 l1 [psi &#x22A2 D1 ..] [psi &#x22A2 F1 ..] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E2 ..] = <a href="#transR">transR</a> cr m2 n2 l2 [psi &#x22A2 D2 ..] [psi &#x22A2 F2 ..] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (E1 ..) (E2 ..)] 
| [psi &#x22A2 <a href="#ae_l">ae_l</a> (\x. (\u. D1 .. x u))]   &#x21D2 
   <keyword>let</keyword>  [psi &#x22A2 <a href="#ae_l">ae_l</a> (\x. (\u. D2 .. x u))] = d2 <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l m'  = m <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l n'  = n <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l l'  = l <keyword>in</keyword>
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 F .. b.1 b.2] = <a href="#transR">transR</a> (Cons_xa cr) m' n' l' [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D1 .. b.1 b.2] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D2 .. b.1 b.2] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (\x. (\u. F .. x u))]
 <br>
<span class="typ" id="deq">deq</span> : <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a> &#x2192 <keyword>type</keyword>.<br>
<span class="constructor" id="de_l">de_l</span> : {x : <a href="#tm">tm</a>} (<a href="#deq">deq</a> x x &#x2192 <a href="#deq">deq</a> (M x) (M' x)) &#x2192 <a href="#deq">deq</a> (<a href="#lam">lam</a> (\x. M x)) (<a href="#lam">lam</a> (\x. M' x)).<br>
<span class="constructor" id="de_a">de_a</span> : <a href="#deq">deq</a> M1 N1 &#x2192 <a href="#deq">deq</a> M2 N2 &#x2192 <a href="#deq">deq</a> (<a href="#app">app</a> M1 M2) (<a href="#app">app</a> N1 N2).<br>
<span class="constructor" id="de_r">de_r</span> : <a href="#deq">deq</a> M M.<br>
<span class="constructor" id="de_t">de_t</span> : <a href="#deq">deq</a> M L &#x2192 <a href="#deq">deq</a> L N &#x2192 <a href="#deq">deq</a> M N.<br>
<keyword>schema</keyword> <span class="schema" id="xdG">xdG</span> = <keyword>block</keyword> (x:<a href="#tm">tm</a>, de_v:<a href="#deq">deq</a> x x);<br>
<keyword>schema</keyword> <span class="schema" id="daG">daG</span> = <keyword>block</keyword> (x:<a href="#tm">tm</a>, ae_v:<a href="#aeq">aeq</a> x x, de_v:<a href="#deq">deq</a> x x);<br><br>
<span class="typ" id="Ctx_xdR">Ctx_xdR</span> : {phi : <a href="#xG">xG</a>}
({psi : <a href="#xdG">xdG</a>} ([psi &#x22A2 phi]
<keyword>ctype</keyword>)).<br>
<span class="constructor" id="Nil_xd">Nil_xd</span> : Ctx_xdR [] [] [ &#x22A2  ].<br>
<span class="constructor" id="Cons_xd">Cons_xd</span> : (Ctx_xdR [phi] [psi] [psi &#x22A2  #S[..]]) &#x2192 Ctx_xdR [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [b, psi &#x22A2  #S[..] b.1].<br><br>
<span class="typ" id="Ctx_adR">Ctx_adR</span> : {phi : <a href="#xaG">xaG</a>}
({psi : <a href="#xdG">xdG</a>}
<keyword>ctype</keyword>).<br>
<span class="constructor" id="Nil_ad">Nil_ad</span> : Ctx_adR [] [].<br>
<span class="constructor" id="Cons_ad">Cons_ad</span> : (Ctx_adR [phi] [psi]) &#x2192 Ctx_adR [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)].</code></pre>
<p> Equality in addition to properties about equality, such as deterministic and existence. These properties are all encoded relationally, because we do not support functions in computation-level types. If we were to support functions in computation-level types, these proofs and some of these relations would go away.</p><br><pre><code><br>
<span class="typ" id="EqV'">EqV'</span> : {phi : <a href="#xG">xG</a>}
({psi : <a href="#xdG">xdG</a>} ([psi &#x22A2 phi]
({z1 : [phi &#x22A2 <a href="#tm">tm</a>]}
({x1 : [psi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>)))).<br>
<span class="constructor" id="EqV'_v">EqV'_v</span> : EqV' [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2  #S[..] b.1] ([phi, x : <a href="#tm">tm</a> &#x22A2 x]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 b.1]).<br>
<span class="constructor" id="EqV'_p">EqV'_p</span> : (EqV' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) &#x2192 EqV' [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [b, psi &#x22A2  #S[..] b.1] ([phi, x : <a href="#tm">tm</a> &#x22A2 (#p ..)]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 #q.1 ..]).<br><br>
<span class="typ" id="Eq'">Eq'</span> : {phi : <a href="#xG">xG</a>}
({psi : <a href="#xdG">xdG</a>} ([psi &#x22A2 phi]
({x2 : [phi &#x22A2 <a href="#tm">tm</a>]}
({y2 : [psi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>)))).<br>
<span class="constructor" id="Eq'_v">Eq'_v</span> : (EqV' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) &#x2192 Eq' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..]).<br>
<span class="constructor" id="Eq'_a">Eq'_a</span> : (Eq' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 M ..]) ([psi &#x22A2 M' ..])) &#x2192 (Eq' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 N ..]) ([psi &#x22A2 N' ..])) &#x2192 Eq' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 <a href="#app">app</a> (M ..) (N ..)]) ([psi &#x22A2 <a href="#app">app</a> (M' ..) (N' ..)]).<br>
<span class="constructor" id="Eq'_l">Eq'_l</span> : (Eq' [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2  #S[..] b.1] ([phi, x : <a href="#tm">tm</a> &#x22A2 M .. x]) ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 M' .. b.1])) &#x2192 Eq' [phi] [psi] [psi &#x22A2  #S[..]] ([phi &#x22A2 <a href="#lam">lam</a> (\x. M .. x)]) ([psi &#x22A2 <a href="#lam">lam</a> (\x. M' .. x)]).<br><br>
<span class="typ" id="Equal_xaG">Equal_xaG</span> : {psi : <a href="#xaG">xaG</a>}
({y3 : [psi &#x22A2 <a href="#tm">tm</a>]}
({z2 : [psi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>)).<br>
<span class="constructor" id="Refl_xaG">Refl_xaG</span> : Equal_xaG ([psi &#x22A2 M ..]) ([psi &#x22A2 M ..]).<br><br>
<span class="typ" id="Equal_xG">Equal_xG</span> : {psi : <a href="#xG">xG</a>}
({z3 : [psi &#x22A2 <a href="#tm">tm</a>]}
({x3 : [psi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>)).<br>
<span class="constructor" id="Refl_xG">Refl_xG</span> : Equal_xG ([psi &#x22A2 M ..]) ([psi &#x22A2 M ..]).<br><br>
<span class="typ" id="ExistsEq'">ExistsEq'</span> : {gamma : <a href="#xG">xG</a>}
({phi : <a href="#xdG">xdG</a>} ([phi &#x22A2 gamma]
({L : [phi &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>))).<br>
<span class="constructor" id="ExistsEq'">ExistsEq'</span> : {L : [gamma &#x22A2 <a href="#tm">tm</a>]} (Eq' [gamma] [phi] [phi &#x22A2  #T[..]] ([gamma &#x22A2 L ..]) ([phi &#x22A2 Ld ..])) &#x2192 ExistsEq' [gamma] [phi] [phi &#x22A2  #T[..]] ([phi &#x22A2 Ld ..]).<br>
<span class="constructor" id="ExistsEqV'">ExistsEqV'</span> : {#p : [gamma &#x22A2 <a href="#tm">tm</a>]} (EqV' [gamma] [phi] [phi &#x22A2  #T[..]] ([gamma &#x22A2 (#p ..)]) ([phi &#x22A2 #q.1 ..])) &#x2192 ExistsEq' [gamma] [phi] [phi &#x22A2  #T[..]] ([phi &#x22A2 #q.1 ..]).<br>
<keyword>rec</keyword> <span class="function" id="existsEqV'">existsEqV'</span> : (Ctx_xdR [gamma] [phi] [phi &#x22A2  #T[..]]) &#x2192 {#p : [phi &#x22A2 <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)]} ExistsEq' [gamma] [phi] [phi &#x22A2  #T[..]] ([phi &#x22A2 #p.1 ..]) = <keyword>fn</keyword> cr_xd &#x21D2 <keyword>mlam</keyword> # p &#x21D2 <keyword>let</keyword>  (cr_xd : Ctx_xdR [gamma] [phi] [phi &#x22A2  #T[..]]) = cr_xd <keyword>in</keyword>
<keyword>case</keyword> [phi &#x22A2 #p.1 ..] <keyword>of</keyword>
| [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 b.1] 
   &#x21D2 
   <keyword>let</keyword>  Cons_xd cr'_xd  = cr_xd <keyword>in</keyword>
    <keyword>let</keyword>  (cr'_xd : Ctx_xdR [gamma] [phi] [phi &#x22A2  #T[..]]) = cr'_xd <keyword>in</keyword>
    ExistsEqV' [gamma, x : <a href="#tm">tm</a> &#x22A2 x] EqV'_v 
| [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 #p.1 ..] 
   &#x21D2 
   <keyword>let</keyword>  Cons_xd cr'_xd  = cr_xd <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEqV' ([gamma &#x22A2 (#r ..)]) eq  = <a href="#existsEqV'">existsEqV'</a> cr'_xd [phi &#x22A2 (#p ..)] <keyword>in</keyword>
    ExistsEqV' [gamma, x : <a href="#tm">tm</a> &#x22A2 (#r ..)] (EqV'_p eq)
 <br>
<keyword>rec</keyword> <span class="function" id="existsEq'">existsEq'</span> : (Ctx_xdR [gamma] [phi] [phi &#x22A2  #T[..]]) &#x2192 {Ld : [phi &#x22A2 <a href="#tm">tm</a>]} ExistsEq' [gamma] [phi] [phi &#x22A2  #T[..]] ([phi &#x22A2 Ld ..]) = <keyword>fn</keyword> cr_xd &#x21D2 <keyword>mlam</keyword> Ld &#x21D2 <keyword>let</keyword>  (cr_xd : Ctx_xdR [gamma] [phi] [phi &#x22A2  #T[..]]) = cr_xd <keyword>in</keyword>
<keyword>case</keyword> [phi &#x22A2 Ld ..] <keyword>of</keyword>
| [phi &#x22A2 #p.1 ..]   &#x21D2 
   <a href="#existsEqV'">existsEqV'</a> cr_xd [phi &#x22A2 (#p ..)] 
| [phi &#x22A2 <a href="#app">app</a> (M ..) (N ..)]   &#x21D2 
   <keyword>let</keyword>  ExistsEq' ([gamma &#x22A2 L1 ..]) eq1  = <a href="#existsEq'">existsEq'</a> cr_xd [phi &#x22A2 M ..] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq' ([gamma &#x22A2 L2 ..]) eq2  = <a href="#existsEq'">existsEq'</a> cr_xd [phi &#x22A2 N ..] <keyword>in</keyword>
    ExistsEq' [gamma &#x22A2 <a href="#app">app</a> (L1 ..) (L2 ..)] (Eq'_a eq1 eq2)

| [phi &#x22A2 <a href="#lam">lam</a> (\x. M .. x)]   &#x21D2 
   <keyword>let</keyword>  ExistsEq' ([gamma, x : <a href="#tm">tm</a> &#x22A2 L .. x]) eq  = <a href="#existsEq'">existsEq'</a> (Cons_xd cr_xd) [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 M .. b.1] <keyword>in</keyword>
    ExistsEq' [gamma &#x22A2 <a href="#lam">lam</a> (\x. L .. x)] (Eq'_l eq)
 <br><br>
<span class="typ" id="ExistsEq">ExistsEq</span> : {gamma : <a href="#xG">xG</a>}
({psi : <a href="#xaG">xaG</a>} ([psi &#x22A2 gamma]
({L : [gamma &#x22A2 <a href="#tm">tm</a>]}
<keyword>ctype</keyword>))).<br>
<span class="constructor" id="ExistsEqV">ExistsEqV</span> : {La : [psi &#x22A2 <a href="#tm">tm</a>]} (EqV [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) &#x2192 ExistsEq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#p ..)]).<br>
<span class="constructor" id="ExistsEq">ExistsEq</span> : {La : [psi &#x22A2 <a href="#tm">tm</a>]} (Eq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 L ..]) ([psi &#x22A2 La ..])) &#x2192 ExistsEq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 L ..]).<br>
<keyword>rec</keyword> <span class="function" id="existsEqV">existsEqV</span> : (Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) &#x2192 {#p : [gamma &#x22A2 <a href="#tm">tm</a>]} ExistsEq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#p ..)]) = <keyword>fn</keyword> cr_xa &#x21D2 <keyword>mlam</keyword> # p &#x21D2 <keyword>let</keyword>  (cr_xa : Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) = cr_xa <keyword>in</keyword>
<keyword>case</keyword> [gamma &#x22A2 (#p ..)] <keyword>of</keyword>
| [gamma, x : <a href="#tm">tm</a> &#x22A2 x]   &#x21D2 
   <keyword>let</keyword>  Cons_xa cr'_xa  = cr_xa <keyword>in</keyword>
    <keyword>let</keyword>  (cr'_xa : Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) = cr'_xa <keyword>in</keyword>
    ExistsEqV [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.1] EqV_v

| [gamma, x : <a href="#tm">tm</a> &#x22A2 (#p ..)]   &#x21D2 
   <keyword>let</keyword>  Cons_xa cr'_xa  = cr_xa <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEqV ([psi &#x22A2 #q.1 ..]) eq  = <a href="#existsEqV">existsEqV</a> cr'_xa [gamma &#x22A2 (#p ..)] <keyword>in</keyword>
    <keyword>let</keyword>  (eq : EqV [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) = eq <keyword>in</keyword>
    ExistsEqV [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 #q.1 ..] (EqV_p eq)
 <br>
<keyword>rec</keyword> <span class="function" id="existsEq">existsEq</span> : (Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) &#x2192 {L : [gamma &#x22A2 <a href="#tm">tm</a>]} ExistsEq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 L ..]) = <keyword>fn</keyword> cr_xa &#x21D2 <keyword>mlam</keyword> L &#x21D2 <keyword>let</keyword>  (cr_xa : Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) = cr_xa <keyword>in</keyword>
<keyword>case</keyword> [gamma &#x22A2 L ..] <keyword>of</keyword>
| [gamma &#x22A2 (#p ..)]   &#x21D2 
   <a href="#existsEqV">existsEqV</a> cr_xa [gamma &#x22A2 (#p ..)] 
| [gamma &#x22A2 <a href="#app">app</a> (M ..) (N ..)]   &#x21D2 
   <keyword>let</keyword>  ExistsEq ([psi &#x22A2 La1 ..]) eq1  = <a href="#existsEq">existsEq</a> cr_xa [gamma &#x22A2 M ..] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq ([psi &#x22A2 La2 ..]) eq2  = <a href="#existsEq">existsEq</a> cr_xa [gamma &#x22A2 N ..] <keyword>in</keyword>
    ExistsEq [psi &#x22A2 <a href="#app">app</a> (La1 ..) (La2 ..)] (Eq_a eq1 eq2)

| [gamma &#x22A2 <a href="#lam">lam</a> (\x. M .. x)]   &#x21D2 
   <keyword>let</keyword>  ExistsEq ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 La .. b.1]) eq  = <a href="#existsEq">existsEq</a> (Cons_xa cr_xa) [gamma, x : <a href="#tm">tm</a> &#x22A2 M .. x] <keyword>in</keyword>
    ExistsEq [psi &#x22A2 <a href="#lam">lam</a> (\x. La .. x)] (Eq_l eq)
 <br>
<keyword>rec</keyword> <span class="function" id="det_eqV">det_eqV</span> : (EqV [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#p ..)]) ([psi &#x22A2 #q.1 ..])) &#x2192 (EqV [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#p ..)]) ([psi &#x22A2 #r.1 ..])) &#x2192 Equal_xaG ([psi &#x22A2 #q.1 ..]) ([psi &#x22A2 #r.1 ..]) = <keyword>fn</keyword> v &#x21D2 <keyword>fn</keyword> v' &#x21D2 <keyword>case</keyword> v <keyword>of</keyword>
|  ;  . EqV_v    &#x21D2 
   <keyword>let</keyword>  EqV_v  = v' <keyword>in</keyword> Refl_xaG 
|  ;  . EqV_p v    &#x21D2 
   <keyword>let</keyword>  EqV_p v'  = v' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG  = <a href="#det_eqV">det_eqV</a> v v' <keyword>in</keyword>
    Refl_xaG
 <br>
<keyword>rec</keyword> <span class="function" id="det_eq">det_eq</span> : (Eq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 M ..]) ([psi &#x22A2 N ..])) &#x2192 (Eq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 M ..]) ([psi &#x22A2 N' ..])) &#x2192 Equal_xaG ([psi &#x22A2 N ..]) ([psi &#x22A2 N' ..]) = <keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> m' &#x21D2 <keyword>case</keyword> m <keyword>of</keyword>
|  ;  . Eq_v v    &#x21D2 
   <keyword>let</keyword>  Eq_v v'  = m' <keyword>in</keyword>
    <a href="#det_eqV">det_eqV</a> v v' 
|  ;  . Eq_a m1 m2    &#x21D2 
   <keyword>let</keyword>  Eq_a n1 n2  = m' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG  = <a href="#det_eq">det_eq</a> m1 n1 <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG  = <a href="#det_eq">det_eq</a> m2 n2 <keyword>in</keyword>
    Refl_xaG 
|  ;  . Eq_l m    &#x21D2 
   <keyword>let</keyword>  Eq_l n  = m' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG  = <a href="#det_eq">det_eq</a> m n <keyword>in</keyword>
    Refl_xaG
 <br>
<keyword>rec</keyword> <span class="function" id="det_eqV'">det_eqV'</span> : (EqV' [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#q ..)]) ([psi &#x22A2 #p.1 ..])) &#x2192 (EqV' [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#r ..)]) ([psi &#x22A2 #p.1 ..])) &#x2192 Equal_xG ([gamma &#x22A2 (#q ..)]) ([gamma &#x22A2 (#r ..)]) = <keyword>fn</keyword> v &#x21D2 <keyword>fn</keyword> v' &#x21D2 <keyword>case</keyword> v <keyword>of</keyword>
|  ;  . EqV'_v    &#x21D2 
   <keyword>let</keyword>  EqV'_v  = v' <keyword>in</keyword> Refl_xG 
|  ;  . EqV'_p v    &#x21D2 
   <keyword>let</keyword>  EqV'_p v'  = v' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xG  = <a href="#det_eqV'">det_eqV'</a> v v' <keyword>in</keyword>
    Refl_xG
 <br>
<keyword>rec</keyword> <span class="function" id="det_eq'">det_eq'</span> : (Eq' [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 M ..]) ([psi &#x22A2 N ..])) &#x2192 (Eq' [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 M' ..]) ([psi &#x22A2 N ..])) &#x2192 Equal_xG ([gamma &#x22A2 M ..]) ([gamma &#x22A2 M' ..]) = <keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> m' &#x21D2 <keyword>case</keyword> m <keyword>of</keyword>
|  ;  . Eq'_v v    &#x21D2 
   <keyword>let</keyword>  Eq'_v v'  = m' <keyword>in</keyword>
    <a href="#det_eqV'">det_eqV'</a> v v' 
|  ;  . Eq'_a m1 m2    &#x21D2 
   <keyword>let</keyword>  Eq'_a n1 n2  = m' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xG  = <a href="#det_eq'">det_eq'</a> m1 n1 <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xG  = <a href="#det_eq'">det_eq'</a> m2 n2 <keyword>in</keyword>
    Refl_xG 
|  ;  . Eq'_l m    &#x21D2 
   <keyword>let</keyword>  Eq'_l n  = m' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xG  = <a href="#det_eq'">det_eq'</a> m n <keyword>in</keyword>
    Refl_xG
 <br>
<keyword>rec</keyword> <span class="function" id="ceq">ceq</span> : (Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) &#x2192 (Ctx_xdR [gamma] [phi] [phi &#x22A2  #T[..]]) &#x2192 (Ctx_adR [psi] [phi]) &#x2192 (Eq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 M ..]) ([psi &#x22A2 Ma ..])) &#x2192 (Eq [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 N ..]) ([psi &#x22A2 Na ..])) &#x2192 (Eq' [gamma] [phi] [phi &#x22A2  #T[..]] ([gamma &#x22A2 M ..]) ([phi &#x22A2 Md ..])) &#x2192 (Eq' [gamma] [phi] [phi &#x22A2  #T[..]] ([gamma &#x22A2 N ..]) ([phi &#x22A2 Nd ..])) &#x2192 [phi &#x22A2 <a href="#deq">deq</a> (Md ..) (Nd ..)] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (Ma ..) (Na ..)] = <keyword>fn</keyword> cr_a &#x21D2 <keyword>fn</keyword> cr_d &#x21D2 <keyword>fn</keyword> cr_da &#x21D2 <keyword>fn</keyword> ma &#x21D2 <keyword>fn</keyword> na &#x21D2 <keyword>fn</keyword> md &#x21D2 <keyword>fn</keyword> nd &#x21D2 <keyword>fn</keyword> d &#x21D2 <keyword>let</keyword>  (cr_da : Ctx_adR [psi] [phi]) = cr_da <keyword>in</keyword>
<keyword>let</keyword>  (cr_a : Ctx_xaR [gamma] [psi] [psi &#x22A2  #S[..]]) = cr_a <keyword>in</keyword>
<keyword>case</keyword> d <keyword>of</keyword>
| [phi &#x22A2 #p.2 ..]   &#x21D2 
   <keyword>let</keyword>  Refl_xG  = <a href="#det_eq'">det_eq'</a> md nd <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG  = <a href="#det_eq">det_eq</a> ma na <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_v v'  = md <keyword>in</keyword>
    <keyword>let</keyword>  Eq_v v  = ma <keyword>in</keyword>
    <keyword>let</keyword>  (v : EqV [gamma] [psi] [psi &#x22A2  #S[..]] ([gamma &#x22A2 (#r ..)]) ([psi &#x22A2 #q.1 ..])) = v <keyword>in</keyword>
    <a href="#ctx_member">ctx_member</a> [gamma &#x22A2 (#r ..)] cr_a v 
| [phi &#x22A2 <a href="#de_r">de_r</a>]   &#x21D2 
   <keyword>let</keyword>  Refl_xG  = <a href="#det_eq'">det_eq'</a> md nd <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG  = <a href="#det_eq">det_eq</a> ma na <keyword>in</keyword>
    <a href="#reflR">reflR</a> [gamma] [gamma &#x22A2 _] cr_a ma 
| [phi &#x22A2 <a href="#de_t">de_t</a> (D1 ..) (D2 ..)]   &#x21D2 
   <keyword>let</keyword>  ([phi &#x22A2 D1 ..] : [phi &#x22A2 <a href="#deq">deq</a> (Md ..) (Ld ..)]) = [phi &#x22A2 D1 ..] <keyword>in</keyword>
    <keyword>let</keyword>  ([phi &#x22A2 D2 ..] : [phi &#x22A2 <a href="#deq">deq</a> (Ld ..) (Nd ..)]) = [phi &#x22A2 D2 ..] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq' ([gamma &#x22A2 L ..]) ld  = <a href="#existsEq'">existsEq'</a> cr_d [phi &#x22A2 Ld ..] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq ([psi &#x22A2 La ..]) la  = <a href="#existsEq">existsEq</a> cr_a [gamma &#x22A2 L ..] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E1 ..] = <a href="#ceq">ceq</a> cr_a cr_d cr_da ma la md ld [phi &#x22A2 D1 ..] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E2 ..] = <a href="#ceq">ceq</a> cr_a cr_d cr_da la na ld nd [phi &#x22A2 D2 ..] <keyword>in</keyword>
    <a href="#transR">transR</a> cr_a ma la na [psi &#x22A2 E1 ..] [psi &#x22A2 E2 ..]

| [phi &#x22A2 <a href="#de_a">de_a</a> (D1 ..) (D2 ..)]   &#x21D2 
   <keyword>let</keyword>  Eq_a ma1 ma2  = ma <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_a md1 md2  = md <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a na1 na2  = na <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_a nd1 nd2  = nd <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E1 ..] = <a href="#ceq">ceq</a> cr_a cr_d cr_da ma1 na1 md1 nd1 [phi &#x22A2 D1 ..] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E2 ..] = <a href="#ceq">ceq</a> cr_a cr_d cr_da ma2 na2 md2 nd2 [phi &#x22A2 D2 ..] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (E1 ..) (E2 ..)] 
| [phi &#x22A2 <a href="#de_l">de_l</a> (\x. (\u. D .. x u))]   &#x21D2 
   <keyword>let</keyword>  Eq_l ma1  = ma <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_l md1  = md <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l na1  = na <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_l nd1  = nd <keyword>in</keyword>
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E .. b.1 b.2] = <a href="#ceq">ceq</a> (Cons_xa cr_a) (Cons_xd cr_d) (Cons_ad cr_da) ma1 na1 md1 nd1 [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 D .. b.1 b.2] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (\x. (\u. E .. x u))]
 </code></pre>
</body>
</html>
