%{
   Exceptions
}%
tp: type.
nat: tp.
arr: tp -> tp -> tp.

term: type.

app: term -> term -> term.
lam: tp -> (term ->  term) -> term.

value:  term -> type.
v_lam: value (lam T M).


% ---------------------------------------------------------- %
% Small-step operational semantics

step: term -> term -> type.

step_app_1    : step (app E1 E2) (app E1' E2)
                 <- step E1 E1'.
step_app_2    : step (app E1 E2) (app E1 E2')
                 <- value E1
                 <- step E2 E2'.

step_app_beta : step (app (lam T E ) E2) (E E2)
                 <- value E2.


% ---------------------------------------------------------- %
oft: term -> tp -> type.

t_lam : ({x:term} oft x T -> oft (E x) S)
	-> oft (lam T E) (arr T S).
t_app:  oft E1 (arr T S) -> oft E2 T
	-> oft (app E1 E2) S.


% ---------------------------------------------------------- %
rec tps: [ |- oft M T] -> [ |- step M N] -> [ |- oft N T] =
/ total s (tps m t n d s)/
fn d => fn s => case s of
| [ |- step_app_1 S1] =>
  let [ |- t_app D1 D2] = d in
  let [ |- F1] = tps  [ |- D1] [ |- S1] in
    [ |- t_app F1 D2 ]

| [ |- step_app_2 S2 _ ] =>
  let [ |- t_app D1 D2] = d in
  let [ |- F2] = tps  [ |- D2] [ |- S2] in
    [ |- t_app D1 F2]

| [ |- step_app_beta V] =>
  let [ |- t_app (t_lam \x.\u. D x u) D2] = d in
    [ |- D _ D2]

;
