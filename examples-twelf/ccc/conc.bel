% Translation CCC combinators -> lambda-terms (in Beluga)

rec conc : (mor A B)[] -> (term B)[u:term A] =
    fn d => case d of
        [] idc =>
           [x] x

      | [] (@ F G) =>
           let [x:term A] (M x)  = conc ([] F) in
           let [x:term A] (N x)  = conc ([] G) in
               [x] (M (N x))

      | [] drop =>
           [x] lunit

%       | [] (pair F G) : (mor A (cross B C))[ ]  =>
%            let [x:term A] (M x) : (term B)[x:term A] = conc ([] F) in
%            let [x:term A] (N x) : (term C)[x:term A] = conc ([] G) in
%                [x] lpair (M x) (N x)  % term (cross B C)[x:term A]

      | [] (pair F G)  =>
           let [x:term A] (M x) = conc ([] F) in
           let [x:term A] (N x) = conc ([] G) in
               [x] lpair (M x) (N x)

      | [] fst =>
          [x] (lfst x)

      | [] snd =>
           [x] (lsnd x)

%       | [] (cur F) : (mor A (arrow B C))[] =>
%            let [x:term (cross A B)] (M x) : (term C)[x:term (cross A B)] = conc ([] F) in
%                [a] (llam (\b . (M (lpair a b)))) % term (arrow B C)[a:term A]

      | [] (cur F) =>
           let [x:term (cross A B)] (M x) = conc ([] F) in
               [a] (llam (\b . (M (lpair a b))))

      | [] app =>
           [a] (lapp (lfst a) (lsnd a));
