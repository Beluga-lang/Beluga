<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>State (beluga.Support.State)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Support</a> &#x00BB; State</nav><header class="odoc-preamble"><h1>Module <code><span>Support.State</span></code></h1><p>State monad definition.</p><p>The state monad is used to define stateful actions, i.e. actions that can read or write to some auxiliary data structure. In general, using the state monad is slower than using side effects because of extra memory allocations and eager closure constructions. For helpers to operations defined with respect to mutable states, see <a href="../Imperative_state/index.html"><code>Imperative_state</code></a>.</p><p>In order to effectively use the state monad, you should define:</p><ol><li>An abstract module type definition for the state data structure. This acts as an interface between concrete implementations of the state data structure and modules that are defined with respect to that state. Even if only an immutable data structure is intended to be implemented for this abstract definition, its operations should be implementable using a mutable state.</li><li>A concrete implementation for that abstract state definition.</li><li>A functor taking an abstract state definition as argument, and producing operations that use that state.</li></ol><p>For instance:</p><pre class="language-ocaml"><code>module type DISAMBIGUATION_STATE = sig
  include State.STATE

  val with_bound_lf_variable : Identifier.t -&gt; 'a t -&gt; 'a t
  (* ... *)
end

module Immutable_disambiguation_state : sig
  include DISAMBIGUATION_STATE

  val initial_state : state
end = struct
  (* ... *)
end

module Mutable_disambiguation_state : sig
  include DISAMBIGUATION_STATE

  val create_initial_state : unit -&gt; state
end = struct
  (* ... *)
end

module type LF_DISAMBIGUATION = sig
  include State.STATE

  val disambiguate_lf_kind : Synprs.lf_object -&gt; Synext.lf_kind t
  (* ... *)
end

module Make_lf_disambiguation
    (Disambiguation_state : DISAMBIGUATION_STATE) :
  LF_DISAMBIGUATION with type state = Disambiguation_state.state =
struct
  (* ... *)
end</code></pre></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-STATE"><a href="#module-type-STATE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-STATE/index.html">STATE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The type of state monads.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Make/index.html">Make</a></span><span> (<a href="Make/argument-1-State/index.html">State</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <a href="module-type-STATE/index.html">STATE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-STATE/index.html#type-state">state</a> = <a href="Make/argument-1-State/index.html#type-t">State.t</a></span></span></code></div><div class="spec-doc"><p>Functor building an implementation of <a href="module-type-STATE/index.html"><code>STATE</code></a> for a given type of states.</p></div></div></div></body></html>
