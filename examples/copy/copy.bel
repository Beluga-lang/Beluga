tp: type.   %name tp T.
bool: tp.
nat: tp.
arrow: tp -> tp -> tp.

term : tp -> type.  %name term E x.

z    : term nat.
s    : term nat -> term nat.

lam  : (term T -> term T') -> term (arrow T T').
app  : term (arrow T T') -> term T -> term T'.


schema tctx = some [t:tp] term t;
% schema W = term nat;

rec copy : {g:tctx} [g. term (T ..)] -> [g. term (T ..)] =
mlam g => fn e => case e of  

| [g. z]      => [g. z] 

| [g. s (E ..)] => 
  let [g. (F ..)] = copy [g] [g. (E .. )] in 
     [g. s (F ..)] 

| [g . #p .. ]   => [g . #p ..]

| [g . lam  (\x. (U .. x))] => 
  let [g,x : term _  . V .. x] = copy [g, x:term _ ] [g,x . U .. x]  in
    [g. lam  (\x. (V .. x))]

| [g . app (E1 ..) (E2 ..)] => 
  let [g . F1 .. ] = copy [g] [g . E1 ..] in 
  let [g . F2 .. ] = copy [g] [g . E2 ..] in 
    [g . app (F1 ..) (F2 ..)]

;


let t = copy [ ] [ . z] ;
let t = copy [x:term nat ] [x:term nat . x];
let t = copy [x:term _ ] [x : term nat. s x];
%{ let t : (term (arrow nat nat))[ ] = 
     copy [ ] ([ ] lam \x. x);
 let t : (term (arrow (arrow bool nat) (arrow bool nat)))[ ] 
     = copy [ ] ([ ] lam \x. (lam \y. app x y));
 let t = copy [y:term (arrow (arrow (arrow bool nat) (arrow bool nat)) nat)] ([y] app y (lam \x. (lam \y. app x y)));
 let t = copy [y:term nat,x:term bool] ([x,y] s x);
}%
}%
