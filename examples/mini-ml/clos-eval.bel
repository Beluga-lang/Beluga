% Closure based interpreter with computation-level data-types.
% Author: Brigitte Pientka

datatype tm : type =
| z    : tm
| suc  : (tm) -> tm
| app  : tm -> tm -> tm
| lam  : (tm -> tm) -> tm
;

schema tctx = tm ;

datatype nat: type =
| zero   : nat
| succ : nat -> nat
;

datatype NList : [ |- nat] -> ctype #stratified  =
| NNil : NList [ |- zero]
| NCons : {g:tctx} {N:[ |- nat]} [g |- tm] -> NList [ |- N] -> NList [ |- succ N]
;

datatype List : ctype #positive =
| Nil : List
| Cons : {g:tctx} [g |- tm] -> List -> List
;

datatype Clos : ctype #positive=
Cl : (g:tctx)  [g,x:tm  |-  tm] -> ([g |- tm] -> Clos) -> Clos
;

datatype CtxRel : {g:tctx} {h:tctx} ctype #stratified =
| Rnil : CtxRel [ ] [ ]
| Rsnoc : (g:tctx) (h:tctx) CtxRel [g] [h] -> CtxRel [g, x:tm] [h, x:tm]
;

% type Env : {g:tctx} ctype = [g |- tm] -> Clos ;


rec test : Clos -> Clos =
/ total x (test x)/
fn x => case x of Cl y f  => x
;



rec test_bool : Bool -> Bool =
% / total e (test_bool e) /
fn e => case e of
| ttrue => ffalse
;


rec ev_bool : (g:tctx) [g |- tm] -> Bool =
%/ total e (ev_bool g e)/
fn e => case e of
| [g |- z ] => ttrue
;


rec eval : (g:tctx) [g |- tm] -> ([g |- tm] -> Clos) -> Clos =
% / total e (eval g e)/
fn e => fn env => case e of
| [g |- #p[..] ] => env [g |- #p[..]]
| [g |- lam \x. E] => Cl [g, x:tm  |-  E] env
| [g |- app (E1[..]) (E2[..])] =>
  case eval [g |- E1[..]] env of
  | Cl [h, x:tm  |-  E] env' =>
    let v = eval [g |- E2[..]] env in
    eval [h,x:tm  |-  E]
         (fn var => case var of
               | [h, x:tm  |-  x] => v
               | [h, x:tm  |-  #p[..] ] => env' [h |- #p[..]]
         )

;

%{
rec eval : (g:ctx) [g |- tm] -> Env [g] -> Clos =
fn e => fn env => case e of
| [g |- #p[..] ] => env [g |- #p[..]]
| [g |- lam \x. E] => Cl [g, x:exp  |-  E] env
| [g |- app (E1[..]) (E2[..])] =>
  case eval [g |- E1[..]] env of
  | Cl [h, x:tm  |-  E] env' =>
    let v = eval [g |- E2[..]] env in
    eval [h,x:tm  |-  E]
         (fn var => case var of
               | [h, x:tm  |-  x] => v
               | [h, x:tm  |-  #p[..] ] => env' [h |- #p[..]]
         )
;

}%
