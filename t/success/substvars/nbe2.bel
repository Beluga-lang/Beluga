#opts +strengthen;

atomic_tp : type.
tp : type.                %name tp T.
atomic : atomic_tp -> tp.
arr: tp -> tp -> tp.

tm : tp -> type.          %name tm E.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).

schema tctx = tm T;

neut : tp -> type.       %name neut R.
norm : tp -> type.       %name norm M.
nlam : (neut T -> norm S) -> norm (arr T S).
rapp : neut (arr T S) -> norm T -> neut S.
embed : neut (atomic P) -> norm (atomic P).

schema ctx = neut T;

datatype Sem : {g:ctx} [ |- tp] -> ctype =
| Syn :  [g |- neut (atomic P)] -> Sem [g] [ |- atomic P]
| Slam : {g:ctx}{A:[ |- tp]}{B:[ |- tp]}({h:ctx} {#W: h |- g} Sem [h] [ |- A] -> Sem [h] [ |- B])
           -> Sem [g] [ |- arr A B]
;

rec sem_wkn : {g:ctx} {h:ctx}{#W: h |- g} Sem [g] [ |- A] -> Sem [h] [ |- A] =
mlam g => mlam h => mlam #W => fn e =>
case e of
| Syn [g |- R ..] => Syn ([h |- R #W[..]])
| Slam [g] [ |- A] [ |- B] f =>
    Slam [h] [ |- A] [ |- B] (mlam h' => mlam #W2 => fn e => f [h'] [h' |- #W[#W2[..]]] e
    )
;

rec extend : {g:tctx} ({T:[ |- tp]}{#p:[g |- tm T]} Sem [h] [ |- T]) -> Sem [h] [ |- S]
-> ({T:[ |- tp]}{#p:[g,x:tm S |-  tm T]} Sem [h] [ |- T]) =
mlam g => fn s => fn e => mlam T => mlam #p => case [g,x:tm _ |-  #p ..] of
| [g,x:tm S |-  x] => e
| [g,x:tm S |-  #q .. ] => s [ |- T ] [g |- #q ..]
;

rec eval : {g:tctx}{h:ctx} ({T:[ |- tp]}{#p:[g |- tm T]} Sem [h] [ |- T])
           -> [g |- tm S] -> Sem [h] [ |- S]  =
mlam g => mlam h =>  fn s => fn t =>
case t of
| [g |- #p .. ]           : [g |- tm S] =>  s [ |- S] [g |- #p .. ]
| [g |- lam (\x. E .. x) ] : [g |- tm (arr A B)] =>
  Slam [h] [ |- A] [ |- B] (mlam h' => mlam #W => fn e =>
         eval [g,x:tm A] [h'] (extend [g] (mlam T => mlam #p => sem_wkn [h] [h'] [h' |- #W[..]] (s [ |- T] [g |- #p ..]))  e)
              [g,x:tm A |-  E .. x]
         )

| [g |- app (E1 ..) (E2 ..) ] =>
  let (Slam [h] [ |- A] [ |- B] f ) : Sem [h] [ |- arr A B] =  eval [g] [h] s [g |- E1 ..] in
    f [h] [h |- ..] (eval [g] [h] s [g |- E2 ..])
;


rec reflect : [g |- neut A] ->  Sem [g] [ |- A] =
fn r => let [g |- R .. ] : [g |- neut A] = r in
case [ |- A] of
| [ |- atomic P ] => Syn [g |- R ..]
| [ |- arr T S ] =>  Slam [g] [ |- T] [ |- S] (mlam h => mlam #W => fn e =>
   let [h |- N ..] = reify e in
   reflect [h |- rapp (R #W[..]) (N ..)]
  )

and reify : Sem [g] [ |- A] -> [g |- norm A] =
fn e => let (e : Sem [g] [ |- A]) = e in
case e of
| Syn [g |- R ..] => [g |- embed (R ..)]
| Slam [g] [ |- A] [ |- B] f =>
     let s = (f [g,x:neut _] [g,x |- ..] (reflect [g,x:neut _ |-  x])) in
     let [g,x:neut _ |-  E .. x] = reify s
     in [g |- nlam (\x. E .. x)]
;

rec initialMap :  {T:[ |- tp]}{#p:[ |- tm T]} Sem [ ] [ |- T] =
mlam T => mlam #p => impossible [ |- #p] in [ ];

rec nbe : [ |- tm A] -> [ |- norm A] =
fn t => reify  (eval [] [] initialMap t)
;


