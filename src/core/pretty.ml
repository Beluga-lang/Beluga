(** Pretty printing for external and internal syntax.

    @see http://caml.inria.fr/resources/doc/guides/format.html
*)

include Format

(* Explanation of formatting markup:

   "@[" opens a box (open_box 0).  You may specify more information
          with an argument, e.g., "@[<hov n>" is equivalent to open_hovbox n.

   "@]" closes a box (close_box ()).

   "@ " outputs a breakable space (print_space ()).

   "@," outputs a break hint (print_cut ()).

   "@." ends the pretty-printing, closing all boxes still opened (print_newline ()).

   "@;<n m>" emits a "full" break hint (print_break n m).

   "@?" outputs pending material in the pretty-printer queue (print_flush ()).

  Important tips:
    - Use "@ " for a break.  Don't use " @ " unless you want more than one space.
    - If you want a newline (for example, before the branch of a case expression),
      you need to do something like this:

           "@[<v>@[%a@]@ @[%a@]@]"

      The "@[<v>" begins a "vertical-only box", in which all breaks are newlines.
      (With a normal box, a break will only write a newline if the right margin is reached.)
      The @[ @] around the two %a's are "horizontal-or-vertical boxes", to ensure that
      breaks generated by the formatting functions called via %a aren't all vertical.
      Otherwise, you'll get output like

           case blah
                ([g]
                 T
                 ..) of

  Notes:
     - Function whose names start with "frugal" try to produce output similar to human input.
*)

type lvl    = int

let std_lvl = 0

let l_paren_if cond =
  if cond
  then "("
  else ""

let r_paren_if cond =
  if cond
  then ")"
  else ""

module Control = struct
  type substitution_style = Natural | DeBruijn

  let substitutionStyle = ref Natural
  let printImplicit = ref false
  let printNormal = ref false
  let db() = !substitutionStyle = DeBruijn
end (* Control *)

module Int = struct

  open Syntax.Int

  (* Internal Syntax Printer Signature *)
  module type PRINTER = sig

    (* Contextual Format Based Pretty Printers *)
    val fmt_ppr_sgn_decl      : lvl -> formatter -> Sgn.decl  -> unit
    val fmt_ppr_lf_kind       : LF.dctx -> lvl -> formatter -> LF.kind      -> unit
    val fmt_ppr_lf_ctyp_decl  : ?printing_holes:bool -> LF.mctx -> lvl -> formatter -> LF.ctyp_decl -> unit
    val fmt_ppr_lf_typ_rec    : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.typ_rec    -> unit

    val fmt_ppr_lf_typ        : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.typ    -> unit
    val fmt_ppr_lf_mtyp       : LF.mctx                    -> formatter -> LF.ctyp  -> unit
    val fmt_ppr_lf_tuple      : LF.mctx -> LF.dctx -> lvl  -> formatter -> LF.tuple  -> unit
    val fmt_ppr_lf_normal     : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.normal -> unit
    val fmt_ppr_lf_head       : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.head   -> unit
    val fmt_ppr_lf_spine      : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.spine  -> unit
    val fmt_ppr_lf_sub        : LF.mctx -> LF.dctx -> lvl -> formatter -> LF.sub    -> unit

    val fmt_ppr_lf_schema     : ?useName:bool -> lvl -> formatter -> LF.schema     -> unit
    val fmt_ppr_lf_sch_elem   : lvl -> formatter -> LF.sch_elem   -> unit

    val fmt_ppr_lf_psi_hat    : LF.mctx -> lvl -> formatter -> LF.dctx  -> unit
    val fmt_ppr_lf_dctx       : LF.mctx -> lvl -> formatter -> LF.dctx  -> unit

    val fmt_ppr_lf_mctx       : lvl -> formatter -> LF.mctx     -> unit
    val fmt_ppr_cmp_kind      : LF.mctx -> lvl -> formatter -> Comp.kind -> unit
    val fmt_ppr_cmp_typ       : LF.mctx -> lvl -> formatter -> Comp.typ -> unit
    val fmt_ppr_cmp_arg       : LF.mctx -> lvl -> formatter -> Comp.arg -> unit
    val fmt_ppr_cmp_ctyp_decl : LF.mctx -> lvl -> formatter -> Comp.ctyp_decl -> unit
    val fmt_ppr_cmp_gctx      : LF.mctx -> lvl -> formatter -> Comp.gctx -> unit
    val fmt_ppr_cmp_exp_chk   : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.exp_chk  -> unit
    val fmt_ppr_cmp_exp_syn   : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.exp_syn  -> unit
    val fmt_ppr_cmp_value     : lvl -> formatter -> Comp.value -> unit
    val fmt_ppr_cmp_branches  : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.branch list -> unit
    val fmt_ppr_cmp_branch    : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.branch      -> unit
    val fmt_ppr_cmp_proof_state : formatter -> unit Comp.proof_state -> unit
    val fmt_ppr_cmp_proof     : LF.mctx -> Comp.gctx -> formatter -> Comp.incomplete_proof -> unit
    val fmt_ppr_cmp_command   : LF.mctx -> Comp.gctx -> formatter -> Comp.command -> unit
    val fmt_ppr_cmp_directive : LF.mctx -> Comp.gctx -> formatter -> unit Comp.directive -> unit
    val fmt_ppr_cmp_hypothetical : formatter -> unit Comp.hypothetical -> unit
    val fmt_ppr_pat_obj       : LF.mctx -> Comp.gctx -> lvl -> formatter -> Comp.pattern     -> unit

    val fmt_ppr_lf_ctx_var    : LF.mctx -> formatter -> LF.ctx_var -> unit
    val fmt_ppr_meta_typ      : LF.mctx -> lvl -> formatter -> Comp.meta_typ -> unit
    val fmt_ppr_meta_obj      : LF.mctx -> lvl -> formatter -> Comp.meta_obj -> unit
    val fmt_ppr_lf_mfront        : LF.mctx -> lvl -> formatter -> LF.mfront -> unit
    val fmt_ppr_meta_spine    : LF.mctx -> lvl -> formatter -> Comp.meta_spine -> unit

    (* Regular Pretty Printers *)
    val ppr_sgn_decl      : Sgn.decl         -> unit
    val ppr_lf_kind       : LF.dctx -> LF.kind -> unit
    val ppr_lf_ctyp_decl  : LF.mctx -> LF.ctyp_decl  -> unit
    val ppr_lf_typ_rec    : LF.mctx -> LF.dctx -> LF.typ_rec -> unit
    val ppr_lf_typ        : LF.mctx -> LF.dctx -> LF.typ     -> unit
    val ppr_lf_normal     : LF.mctx -> LF.dctx -> LF.normal  -> unit
    val ppr_lf_tuple      : LF.mctx -> LF.dctx -> LF.tuple   -> unit
    val ppr_lf_head       : LF.mctx -> LF.dctx -> LF.head    -> unit
    val ppr_lf_spine      : LF.mctx -> LF.dctx -> LF.spine   -> unit
    val ppr_lf_sub        : LF.mctx -> LF.dctx -> LF.sub     -> unit

    val ppr_lf_schema     : LF.schema        -> unit
    val ppr_lf_sch_elem   : LF.sch_elem      -> unit

    val ppr_lf_dctx       : LF.mctx -> LF.dctx  -> unit
    val ppr_lf_mctx       : LF.mctx -> unit
    val ppr_cmp_kind      : LF.mctx -> Comp.kind -> unit
    val ppr_cmp_typ       : LF.mctx -> Comp.typ -> unit
    val ppr_cmp_exp_chk   : LF.mctx -> Comp.gctx -> Comp.exp_chk -> unit
    val ppr_cmp_exp_syn   : LF.mctx -> Comp.gctx -> Comp.exp_syn -> unit
    val ppr_cmp_branches  : LF.mctx -> Comp.gctx -> Comp.branch list -> unit
    val ppr_cmp_branch    : LF.mctx -> Comp.gctx -> Comp.branch      -> unit

    (* Conversion to string *)
    val sgnDeclToString   : Sgn.decl -> string

    val subToString       : LF.mctx -> LF.dctx -> LF.sub      -> string
    val spineToString     : LF.mctx -> LF.dctx -> LF.sclo     -> string
    val typToString       : LF.mctx -> LF.dctx -> LF.tclo     -> string
    val mtypToString      : LF.mctx -> LF.ctyp -> string
    val typRecToString    : LF.mctx -> LF.dctx -> LF.trec_clo -> string
    val kindToString      : LF.dctx -> (LF.kind * LF.sub) -> string
    val normalToString    : LF.mctx -> LF.dctx -> LF.nclo     -> string
    val headToString      : LF.mctx -> LF.dctx -> LF.head     -> string
    val itermToString     : LF.mctx -> LF.dctx -> LF.iterm    -> string
    val mmvarToString     : LF.mm_var -> string
    val tupleToString     : LF.mctx -> LF.dctx -> LF.tuple    -> string
    val dctxToString      : LF.mctx -> LF.dctx -> string
    val mctxToString      : LF.mctx -> string
    val metaTypToString   : LF.mctx -> Comp.meta_typ -> string
    val metaObjToString   : LF.mctx -> Comp.meta_obj -> string

    val schemaToString    : LF.schema     -> string
    val schElemToString   : LF.sch_elem   -> string
    val cdeclToString     : LF.mctx -> LF.ctyp_decl  -> string

    val gctxToString      : LF.mctx -> Comp.gctx -> string
    val patternToString   : LF.mctx -> Comp.gctx -> Comp.pattern -> string
    val expChkToString    : LF.mctx -> Comp.gctx -> Comp.exp_chk -> string
    val expSynToString    : LF.mctx -> Comp.gctx -> Comp.exp_syn -> string
    val valueToString     :                         Comp.value   -> string
    val branchToString    : LF.mctx -> Comp.gctx -> Comp.branch  -> string
    val compKindToString  : LF.mctx              -> Comp.kind -> string
    val compTypToString   : LF.mctx              -> Comp.typ  -> string
    val subCompTypToString : LF.mctx              -> Comp.tclo  -> string
    val msubToString      : LF.mctx              -> LF.msub   -> string

  end (* Int.PRINTER *)

  (* Internal Syntax Pretty Printer Functor *)
  module Make : functor (R : Store.Cid.RENDERER) -> PRINTER = functor (R : Store.Cid.RENDERER) -> struct

    module InstHashedType = struct
      type t    = LF.iterm option ref
      let equal = (==)
      let hash  = Hashtbl.hash
    end

    module InstHashtbl = Hashtbl.Make (InstHashedType)

    let inst_hashtbl : string InstHashtbl.t = InstHashtbl.create 0

    module MInstHashedType = struct
      type t    = LF.iterm option ref
      let equal = (==)
      let hash  = Hashtbl.hash
    end

    module MInstHashtbl = Hashtbl.Make (MInstHashedType)

    let minst_hashtbl : string MInstHashtbl.t = MInstHashtbl.create 0

    module SInstHashedType = struct
      type t    = LF.iterm option ref
      let equal = (==)
      let hash  = Hashtbl.hash
    end

    module SInstHashtbl = Hashtbl.Make (SInstHashedType)

    let sinst_hashtbl : string SInstHashtbl.t = SInstHashtbl.create 0

    module PInstHashedType = struct
      type t    = LF.iterm option ref
      let equal = (==)
      let hash  = Hashtbl.hash
    end

    module PInstHashtbl = Hashtbl.Make (PInstHashedType)

    let pinst_hashtbl : string PInstHashtbl.t = PInstHashtbl.create 0

    (* Fresh name generation *)

    let rec get_names_dctx : LF.dctx -> Id.name list = function
      | LF.Null -> []
      | LF.CtxVar psi -> []
      | LF.DDec (cPsi', LF.TypDecl (n, _))
      | LF.DDec (cPsi', LF.TypDeclOpt n) -> n :: get_names_dctx cPsi'

    let rec get_names_mctx : LF.mctx -> Id.name list = function
      | LF.Empty -> []
      | LF.Dec (cD', LF.Decl (n, _, _))
      | LF.Dec (cD', LF.DeclOpt n) -> n :: get_names_mctx cD'

    let rec get_names_gctx : Comp.gctx -> Id.name list = function
      | LF.Empty -> []
      | LF.Dec (cG', Comp.WfRec (n, _, _))
      | LF.Dec (cG', Comp.CTypDecl (n, _, _ ))
      | LF.Dec (cG', Comp.CTypDeclOpt n) -> n :: get_names_gctx cG'

    let fresh_name_dctx (cPsi : LF.dctx) : Id.name -> Id.name =
      Id.gen_fresh_name (get_names_dctx cPsi)
    let fresh_name_mctx (cD : LF.mctx) : Id.name -> Id.name =
      Id.gen_fresh_name (get_names_mctx cD)
    let fresh_name_gctx (cG : Comp.gctx) : Id.name -> Id.name  =
      Id.gen_fresh_name (get_names_gctx cG)

    let fresh_name_ctyp_decl (cD: LF.mctx) : LF.ctyp_decl -> LF.ctyp_decl = function
      | LF.Decl (n, ct, dep) ->
         let n' = fresh_name_mctx cD n in LF.Decl (n', ct, dep)
      | LF.DeclOpt n ->
         let n' = fresh_name_mctx cD n in LF.DeclOpt n'

    (* Contextual Format Based Pretty Printers
     *
     * We assume types, terms, etc are all in normal form.
     *)

    let rec fmt_ppr_lf_typ cD cPsi lvl ppf = function
      | LF.Atom (_, a, LF.Nil) ->
          fprintf ppf "%s"
            (R.render_cid_typ a)

      | LF.Atom (_, a, ms) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%s %a%s"
              (l_paren_if cond)
              (R.render_cid_typ a)
              (fmt_ppr_lf_spine cD cPsi 2) ms
              (r_paren_if cond)

      | LF.PiTyp ((LF.TypDecl (x, a), LF.Maybe), b) ->
          let x = fresh_name_dctx cPsi x in
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s{%s : %a} @ %a%s@]"
              (l_paren_if cond)
              (Id.render_name x)
              (fmt_ppr_lf_typ cD cPsi 0) a
              (fmt_ppr_lf_typ cD (LF.DDec(cPsi, LF.TypDecl(x, a))) 0) b
              (r_paren_if cond)

      | LF.PiTyp ((LF.TypDecl (x, a), LF.No), b) ->
          let x = fresh_name_dctx cPsi x in
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s%a -> %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_lf_typ cD cPsi 1) a
              (fmt_ppr_lf_typ cD (LF.DDec(cPsi, LF.TypDecl(x, a))) 0) b
              (r_paren_if cond)

      | LF.Sigma typRec ->
          fprintf ppf "block (%a)"
            (fmt_ppr_lf_typ_rec cD cPsi lvl) typRec

      | LF.TClo (typ, s) ->
          fprintf ppf "TClo(%a,@ %a)"
            (fmt_ppr_lf_typ cD cPsi lvl) typ
            (fmt_ppr_lf_sub cD cPsi lvl) s

    and fmt_ppr_lf_tuple cD cPsi lvl ppf = function
      | LF.Last tM ->
           fmt_ppr_lf_normal cD cPsi lvl ppf tM

      | LF.Cons(tM, rest) ->
           fprintf ppf "%a, %a"
             (fmt_ppr_lf_normal cD cPsi lvl) tM
             (fmt_ppr_lf_tuple cD cPsi lvl) rest

    and fmt_ppr_lf_normal cD cPsi lvl ppf =
      let rec dropSpineLeft ms n = match (ms, n) with
          (_, 0) -> ms
        | (LF.Nil, _) -> ms
        | (LF.App (_m, rest), n) -> dropSpineLeft rest (n - 1)

      in let deimplicitize_spine h ms = match h with
        | LF.Const c ->
            let implicit_arguments = if !Control.printImplicit
                                     then 0
                                     else Store.Cid.Term.get_implicit_arguments c
            in
              dropSpineLeft ms implicit_arguments

        | LF.MVar _
        | LF.BVar _
        | LF.PVar _
        | LF.FMVar _
        | LF.FPVar _
        | LF.Proj _
        | LF.FVar _
        | LF.AnnH _ ->
            ms

      in function
        | LF.Lam (_, x, m) ->
            let x = fresh_name_dctx cPsi x in
            let cond = lvl > 0 in
              fprintf ppf "%s\\%s. %a%s"
                (l_paren_if cond)
                (Id.render_name x)
                (fmt_ppr_lf_normal cD (LF.DDec(cPsi, LF.TypDeclOpt x)) 0) m
                (r_paren_if cond)
        | LF.LFHole (_, Some name) ->
           fprintf ppf "?%s" name
        | LF.LFHole (_, None) ->
          fprintf ppf "?"
        | LF.Tuple (_, tuple) ->
           fprintf ppf "<%a>"
             (fmt_ppr_lf_tuple cD cPsi lvl) tuple

        | LF.Root (_, h, LF.Nil) ->
            fprintf ppf "%a"
              (fmt_ppr_lf_head cD cPsi lvl) h

        | LF.Root (_, h, ms)  ->
            let cond = lvl > 1 in
            let ms = deimplicitize_spine h ms in
              fprintf ppf "%s%a %a%s"
                (l_paren_if cond)
                (fmt_ppr_lf_head cD cPsi lvl) h
                (fmt_ppr_lf_spine cD cPsi 2)  ms
                (r_paren_if cond)

        | LF.Clo(tM, s) -> fmt_ppr_lf_normal cD cPsi lvl ppf (Whnf.norm (tM, s))

    and fmt_ppr_lf_head cD cPsi lvl ppf head =
      let paren s = not (Control.db()) && lvl > 0 && (match s with
        | LF.EmptySub
        | LF.Undefs -> false
        | LF.Shift _ when not (Context.hasCtxVar cPsi) -> false
        | _ -> true)
      in
      let rec fmt_head_with proj = function
      | LF.HClo (h, s, sigma) ->
          fprintf ppf "%s[#%a[%a]]"
            (R.render_bvar cPsi h)
            (fmt_ppr_lf_offset cD lvl) s
            (fmt_ppr_lf_sub cD cPsi lvl) sigma
      | LF.HMClo (h, ((s, theta),sigma)) ->
          fprintf ppf "%s[#%a[%a ; %a]]"
            (R.render_bvar cPsi h)
            (fmt_ppr_lf_mmvar lvl) s
            (fmt_ppr_lf_msub  cD lvl) theta
            (fmt_ppr_lf_sub cD cPsi lvl) sigma
      | LF.BVar x  ->
          fprintf ppf "%s%s"
            (R.render_bvar cPsi x)
            proj

      | LF.Const c ->
          fprintf ppf "%s%s"
            (R.render_cid_term c)
            proj

      | LF.MMVar ((c, ms), s) ->
          fprintf ppf "%s%a%s[%a][%a]%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_mmvar lvl) c
            proj
            (fmt_ppr_lf_msub cD lvl) ms
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.MPVar ((c, ms), s) ->
          fprintf ppf "%s%a%s[%a]%a%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_mmvar lvl) c
            proj
            (fmt_ppr_lf_msub cD lvl) ms
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.MVar(c, LF.Undefs)
      | LF.MVar(c, LF.EmptySub) ->
     (match !Control.substitutionStyle with
        | Control.Natural ->
                fprintf ppf "%a%s"
                          (fmt_ppr_lf_cvar cD lvl) c
                              proj
        | Control.DeBruijn ->
                fprintf ppf "%a%s[e]"
                          (fmt_ppr_lf_cvar cD lvl) c
                              proj)

      | LF.MVar (c, s) ->
      if Substitution.LF.isId s then
          fprintf ppf "%a%s"
            (fmt_ppr_lf_cvar cD lvl) c
            proj
      else
           fprintf ppf "%s%a%s[%a]%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_cvar cD lvl) c
            proj
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.PVar (c, s) ->
        if Substitution.LF.isId s then
          fprintf ppf "#%a%s"
            (fmt_ppr_lf_offset cD lvl) c
            proj
      else
          fprintf ppf "%s#%a%s[%a]%s"
            (l_paren_if (paren s))
            (fmt_ppr_lf_offset cD lvl) c
            proj
            (fmt_ppr_lf_sub  cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.FVar x ->
          fprintf ppf "%s%s"
            (Id.render_name x)
            proj

      | LF.FMVar (u, s) ->
          fprintf ppf "FMV %s%s%s[%a]%s"
            (l_paren_if (paren s))
            (Id.render_name u)
            proj
            (fmt_ppr_lf_sub cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.FPVar (p, s) ->
          fprintf ppf "%sFPV #%s%s[%a]%s"
            (l_paren_if (paren s))
            (Id.render_name p)
            proj
            (fmt_ppr_lf_sub cD cPsi lvl) s
            (r_paren_if (paren s))

      | LF.Proj (head, k) ->
          fmt_head_with ("." ^ string_of_int k) head

      in
        fmt_head_with "" head


    and fmt_ppr_lf_spine cD cPsi lvl ppf = function
      | LF.Nil -> ()
      | LF.App(m, LF.Nil) ->
        fprintf ppf "%a"
          (fmt_ppr_lf_normal  cD cPsi (lvl + 1)) m
      | LF.App (m, ms) ->
          fprintf ppf "%a %a"
            (fmt_ppr_lf_normal  cD cPsi (lvl + 1)) m
            (fmt_ppr_lf_spine   cD cPsi lvl) ms

    and fmt_ppr_lf_sub cD cPsi lvl ppf s =
      match !Control.substitutionStyle with
        | Control.Natural -> fmt_ppr_lf_sub_natural cD cPsi lvl ppf s
        | Control.DeBruijn -> fmt_ppr_lf_sub_deBruijn cD cPsi lvl ppf s

    and fmt_ppr_lf_sub_natural cD cPsi lvl ppf s =
      let s = Whnf.normSub s in
      let cPsi = Whnf.normDCtx cPsi in
      let print_front = fmt_ppr_lf_front cD cPsi 1 in
      let rec fmt_ppr_lf_sub_id ppf cPsi =
        match cPsi with
        | LF.Null -> ()
        | LF.DDec (cPsi', LF.TypDecl (x, _))
          | LF.DDec (cPsi', LF.TypDeclOpt x) ->
           fprintf ppf "%a, %s"
             fmt_ppr_lf_sub_id cPsi'
             (Id.render_name x)
        | LF.CtxVar _ -> fprintf ppf ".."
      in
      let rec fmt_ppr_lf_sub_shift ppf (cPsi,n) = match cPsi, n with
      | _, 0 -> fmt_ppr_lf_sub_id ppf cPsi
      | LF.DDec (cPsi', _), n when n > 0 -> fmt_ppr_lf_sub_shift ppf (cPsi', n-1)
      in
      let rec self lvl ppf =
        function
        | LF.EmptySub -> ()
        | LF.Undefs -> ()
        | LF.Shift n -> fmt_ppr_lf_sub_shift ppf (cPsi, n)
        | LF.FSVar (_, (s_name, s)) ->
          fprintf ppf "|- FSV %s[%a]"

            (Id.render_name s_name )
            (fmt_ppr_lf_sub cD cPsi lvl) s

        | LF.SVar (c, _, s) ->
            fprintf ppf "#%a[%a]"
               (fmt_ppr_lf_offset cD lvl) c
               (self lvl) s
        | LF.MSVar (_, ((_sigma, t),s)) ->
            fprintf ppf "#?S[%a ; %a]"
              (fmt_ppr_lf_msub cD lvl) t
              (self lvl) s
        | LF.Dot (f, s) ->
            fprintf ppf "%a, %a"
              (self lvl) s
              print_front f
      in
        match s with
          | LF.Shift _ when not (Context.hasCtxVar cPsi) ->  (* Print nothing at all, because the user would have written nothing at all *)
              ()
          | _ ->  (* For anything else, print a space first *)
              fprintf ppf " %a"
                (self lvl) s

    and fmt_ppr_lf_sub_deBruijn cD cPsi lvl ppf s =
      let rec self lvl ppf = function
        | LF.EmptySub -> fprintf ppf "EmptySub"
        | LF.Undefs -> fprintf ppf "Undefs"
        | LF.Shift n ->
            fprintf ppf "^%s"
              (R.render_offset n)

        | LF.FSVar (n, (s_name, s)) ->
                fprintf ppf
                  "#^%s FSV %s[%a]"
                  (R.render_offset n)
                  (Id.render_name s_name)
                  (self lvl) s

        | LF.SVar (c, n, s) ->
        fprintf ppf
                  "#^%s %a[%a]"
                  (R.render_offset n)
                  (fmt_ppr_lf_offset cD lvl) c
                  (self lvl) s

        | LF.MSVar (n , ((_sigma, t),s)) ->
                fprintf ppf
                  "#^%s #?S [%a][|%a|]"
                  (R.render_offset n)
                  (self lvl) s
                  (fmt_ppr_lf_msub cD 0) t

        | LF.Dot (f, s) ->
            fprintf ppf "%a,  %a"
              (fmt_ppr_lf_front cD cPsi 1) f
              (self lvl) s
      in
        fprintf ppf " %a"
          (self lvl) s


    and fmt_ppr_lf_front cD cPsi lvl ppf = function
      | LF.Head h ->
          fprintf ppf "%a"
            (fmt_ppr_lf_head cD cPsi lvl) h

      | LF.Obj m ->
          fprintf ppf "%a"
            (fmt_ppr_lf_normal cD cPsi lvl) m

      | LF.Undef ->
          fprintf ppf "undef"

    and fmt_ppr_lf_msub cD lvl ppf = function
      | LF.MShift k ->
          fprintf ppf "^%s" (string_of_int k)

      | LF.MDot (f, s) ->
          fprintf ppf "%a@ ,@ %a"
            (fmt_ppr_lf_mfront cD 1) f
            (fmt_ppr_lf_msub cD lvl) s

    and fmt_ppr_lf_clobj cD lvl cPsi ppf = function
      | LF.MObj m -> fmt_ppr_lf_normal cD cPsi lvl ppf m
      | LF.SObj s -> fmt_ppr_lf_sub cD cPsi lvl ppf s
      | LF.PObj h -> fprintf ppf "#%a" (fmt_ppr_lf_head cD cPsi lvl) h


   and fmt_ppr_mfront' cD _lvl ppf mO = match mO with
      | LF.CObj cPsi ->
            fprintf ppf "%a"
              (fmt_ppr_lf_dctx cD 0) cPsi
      | LF.ClObj (phat, tM) ->
          let cPsi = Context.hatToDCtx phat in
            fprintf ppf "%a |- %a"
               (fmt_ppr_lf_psi_hat cD 0) cPsi
              (fmt_ppr_lf_clobj cD 0 cPsi) tM
      | LF.MV k ->
          fprintf ppf "%s"
            (R.render_cvar cD k)
      | LF.MUndef ->
          fprintf ppf "UNDEF"

    and fmt_ppr_lf_mfront cD lvl ppf mO =
      fprintf ppf "[%a]" (fmt_ppr_mfront' cD 0) mO

    and fmt_ppr_meta_obj cD lvl ppf (loc,mO) =
      fmt_ppr_lf_mfront cD lvl ppf mO

    and fmt_ppr_lf_mmvar lvl ppf = function
      | (_, ({ contents = None } as u), _, LF.ClTyp (LF.PTyp tA,_), _, mDep) ->
          begin
            try
              fprintf ppf "?#%s"
                (PInstHashtbl.find pinst_hashtbl u)
            with
              | Not_found ->
                  let sym = match Store.Cid.Typ.gen_mvar_name tA with
                              | Some vGen -> vGen ()
                              | None -> Gensym.MVarData.gensym ()
                  in
                      PInstHashtbl.replace pinst_hashtbl u sym
                    ; fprintf ppf "?#%s" sym
          end

      | (_, {contents = Some (LF.IHead h)}, cD, LF.ClTyp (LF.PTyp _,cPsi), _, mDep) ->
          (* fprintf ppf "MMV SOME %a" *)
          fprintf ppf " %a"
            (fmt_ppr_lf_head cD cPsi lvl) h

      | (_n, ({ contents = None } as u), _, LF.ClTyp (LF.MTyp tA,_), _,       mDep) ->
         (* Note, pretty-printing does not use the name provided n which may not be unique but generates a new one *)
         let s = dependent_string mDep in
         begin
           try
             fprintf ppf "?%s%s"
               (MInstHashtbl.find minst_hashtbl u) s
           with
           | Not_found ->
              (* (* Should probably create a sep. generator for this -dwm *)
                 let sym = String.uppercase (Gensym.VarData.gensym ()) in
               *)
              (* Not working -bp *)
              let sym =
                match Store.Cid.Typ.gen_mvar_name tA with
                | Some vGen -> vGen ()
                | None -> Gensym.MVarData.gensym ()
              in
              MInstHashtbl.replace minst_hashtbl u sym;
              fprintf ppf "?%s" sym
         end

      | (_, {contents = Some (LF.INorm m)}, cD, LF.ClTyp (LF.MTyp _,cPsi), _, _) ->
          (* fprintf ppf "MMV SOME %a" *)
          fprintf ppf " %a"
            (fmt_ppr_lf_normal cD cPsi lvl) m

      | (_, ({ contents = None } as u), _, LF.ClTyp (LF.STyp (_, cPsi),_), _, mDep) ->
          begin
            try
              fprintf ppf "?%s"
                (SInstHashtbl.find sinst_hashtbl u)
            with
              | Not_found ->
                  (* (* Should probably create a sep. generator for this -dwm *)
                  let sym = String.uppercase (Gensym.VarData.gensym ()) in
                  *)
                  (* Not working -bp *)
                  let sym = Gensym.MVarData.gensym ()
                  in
                      SInstHashtbl.replace sinst_hashtbl u sym
                    ; fprintf ppf "#?%s" sym
          end

      | (_, {contents = Some (LF.ISub s)}, cD, LF.ClTyp (LF.STyp _,cPsi), _, mDep) ->
          (* fprintf ppf "MMV SOME %a" *)
          fprintf ppf " #%a"
            (fmt_ppr_lf_sub cD cPsi lvl) s

    and fmt_ppr_lf_offset cD _lvl ppf n =
          fprintf ppf "%s" (R.render_cvar cD n)

    and fmt_ppr_lf_cvar cD _lvl ppf = function
      | LF.Offset n -> fmt_ppr_lf_offset cD _lvl ppf n

      | LF.Inst (_, ({ contents = None } as u), _, LF.ClTyp (LF.MTyp tA,_), _, _) ->
          begin
            try
              fprintf ppf "?%s"
                (InstHashtbl.find inst_hashtbl u)
            with
              | Not_found ->
                  let sym = match Store.Cid.Typ.gen_mvar_name tA with
                              | Some vGen -> vGen ()
                              | None -> Gensym.MVarData.gensym ()
                  in
                      InstHashtbl.replace inst_hashtbl u sym
                    ; fprintf ppf "?%s" sym
          end
      | LF.Inst _ ->               fprintf ppf "?INST _ "

    and fmt_ppr_lf_ctx_var cD ppf = function
      | LF.CInst ((n, {contents = None}, _cD, _schema, _cnstr,_dep), theta) ->
          fprintf ppf "?%s[%a]"
            (Id.render_name n)
            (fmt_ppr_lf_msub cD 0) theta

      | LF.CInst ((_n, {contents = Some (LF.ICtx cPsi)}, cD', _schema, _cnstr, _dep), theta) ->
          fprintf ppf "%a"
          (fmt_ppr_lf_dctx cD' 0) (Whnf.cnormDCtx (cPsi, theta))

      | LF.CtxOffset psi ->
          fprintf ppf "%s"
            (R.render_ctx_var cD psi)
      | LF.CtxName psi ->
          fprintf ppf "%s"
            (Id.render_name psi)


    and fmt_ppr_lf_typ_rec cD cPsi _lvl ppf typrec =
       let ppr_element cD cPsi ppf suffix = function
       | (x, tA) ->
              fprintf ppf "%s:%a%s"
                (Id.render_name x)
                (fmt_ppr_lf_typ cD cPsi 0) tA
               suffix
       in
       let rec ppr_elements cD cPsi ppf = function
         | LF.SigmaLast (None, tA) -> fmt_ppr_lf_typ cD cPsi 0 ppf tA
         | LF.SigmaLast (Some x, tA) ->  ppr_element cD cPsi ppf "" (x, tA)
(*          | LF.SigmaElem (x, tA1, LF.SigmaLast tA2) ->
             begin
               ppr_element cD cPsi  ppf ". " (x, tA1);
               fprintf ppf "%a" (fmt_ppr_lf_typ cD (LF.DDec(cPsi, LF.TypDecl(x, tA1))) 0) tA2
             end *)
         | LF.SigmaElem (x, tA, tAs)  ->
             let x = fresh_name_dctx cPsi x in
             begin
               ppr_element cD cPsi ppf ", " (x, tA);
               ppr_elements cD (LF.DDec(cPsi, LF.TypDecl (x, tA))) ppf  tAs
             end
(*             | tA :: tAs -> *)
(*                   fprintf ppf "%a,@ %a" *)
(*                     (fmt_ppr_lf_typ cD cPsi 0) tA *)
(*                     ppr_typ_rec        tAs *)
(*                fprintf ppf "Sigma %a. %a" *)
       in
         ppr_elements cD cPsi ppf typrec

    and projectCtxIntoDctx = function
         |  LF.Empty -> LF.Null
         |  LF.Dec (rest, last) -> LF.DDec (projectCtxIntoDctx rest, last)

    and fmt_ppr_lf_schema ?(useName=true) lvl ppf s =
      let print_without_name = function
        | LF.Schema [] -> ()

        | LF.Schema (f :: []) ->
              fprintf ppf "%a"
                (fmt_ppr_lf_sch_elem lvl) f

        | LF.Schema (f :: fs) ->
              fprintf ppf "@[%a@]@ +@ @[%a@]"
                (fmt_ppr_lf_sch_elem lvl) f
                (fmt_ppr_lf_schema lvl) (LF.Schema fs)
      in
      if useName then
        try
          fprintf ppf "%s" (Id.render_name (Store.Cid.Schema.get_name_from_schema s))
        with | _ -> print_without_name s
      else print_without_name s

    and frugal_block cD cPsi lvl ppf = function
      | LF.SigmaLast(_,  tA) -> fmt_ppr_lf_typ cD cPsi 0 ppf tA
      | other -> fprintf ppf "block (%a)" (fmt_ppr_lf_typ_rec cD cPsi lvl) other

    and fmt_ppr_lf_sch_elem lvl ppf = function
      | LF.SchElem (LF.Empty, sgmDecl) ->
            fprintf ppf "%a"
              (frugal_block LF.Empty LF.Null lvl) sgmDecl

      | LF.SchElem (typDecls, sgmDecl) ->
          let cPsi = projectCtxIntoDctx typDecls in
            fprintf ppf "@[some [%a] %a@]"
              (ppr_typ_decl_dctx  LF.Empty)  cPsi
              (frugal_block LF.Empty cPsi lvl) sgmDecl


    and ppr_typ_decl_dctx cD ppf = function
      | LF.Null ->
          fprintf ppf ""

      | LF.DDec (LF.Null, LF.TypDecl (x, tA)) ->
          fprintf ppf "%s : %a"    (* formerly "., %s : %a"    -jd 2010-06-03 *)
            (Id.render_name x)
            (fmt_ppr_lf_typ cD LF.Null 0) tA

      | LF.DDec (cPsi, LF.TypDecl (x, tA)) ->
          fprintf ppf "%a, %s : %a"
            (ppr_typ_decl_dctx cD) cPsi
            (Id.render_name x)
            (fmt_ppr_lf_typ cD cPsi 0) tA


    and fmt_ppr_lf_psi_hat cD _lvl ppf = function
      | LF.Null   -> fprintf ppf ""

      | LF.CtxVar ctx_var ->
          fmt_ppr_lf_ctx_var cD ppf ctx_var

      | LF.DDec (LF.Null, LF.TypDeclOpt x) ->
          fprintf ppf "%s"
            (Id.render_name x)

      | LF.DDec (cPsi, LF.TypDeclOpt x) ->
          fprintf ppf "%a, %s"
            (fmt_ppr_lf_psi_hat cD 0) cPsi
            (Id.render_name x)

      | LF.DDec (LF.Null, LF.TypDecl(x, _ )) ->
          fprintf ppf "%s"
            (Id.render_name x)

      | LF.DDec (cPsi, LF.TypDecl(x, _ )) ->
          fprintf ppf "%a, %s"
            (fmt_ppr_lf_psi_hat cD 0) cPsi
            (Id.render_name x)

    and fmt_ppr_lf_dctx cD _lvl ppf = function
      | LF.Null ->
          fprintf ppf ""

      | LF.CtxVar ctx_var ->
          fmt_ppr_lf_ctx_var cD ppf ctx_var

      | LF.DDec (LF.Null, LF.TypDecl (x, tA)) ->
          fprintf ppf "%s : %a"
            (Id.render_name x)
            (fmt_ppr_lf_typ cD LF.Null 0) tA

      | LF.DDec (LF.Null, LF.TypDeclOpt x) ->
          fprintf ppf "%s : _"
            (Id.render_name x)

      | LF.DDec (cPsi, LF.TypDecl (x, tA)) ->
          fprintf ppf "%a, %s : %a"
            (fmt_ppr_lf_dctx cD 0) cPsi
            (Id.render_name x)
            (fmt_ppr_lf_typ cD cPsi 0) tA

      | LF.DDec (cPsi, LF.TypDeclOpt x) ->
          fprintf ppf "%a, %s : _"
            (fmt_ppr_lf_dctx cD 0) cPsi
            (Id.render_name x)

    and fmt_ppr_lf_mctx lvl ppf cD =
      (* Compute the list of declarations to print *)
      let ds =
        let should_print = function
          | (_, LF.Decl (_, _, dep)) ->
             not !Control.printNormal && (!Control.printImplicit || not (isImplicit dep))
          | _ -> true
        in
        Context.to_sublist_rev cD
        |> Misc.List.filter_rev should_print
      in
      match ds with
      | [] ->
          fprintf ppf "."
      | _ ->
         let comma ppf () = fprintf ppf ",@ " in
         fprintf ppf "@[";
         pp_print_list ~pp_sep: comma
           (fun ppf (cD, d) -> fmt_ppr_lf_ctyp_decl cD lvl ppf d)
           ppf
           ds;
         fprintf ppf "@]"
(*    and frugal_lf_octx lvl ppf = function
      | LF.Empty -> ()
      | other -> fprintf ppf "@[%a@]@ " (fmt_ppr_lf_octx lvl) other

    and fmt_ppr_lf_octx lvl ppf = function
      | LF.Empty ->
          fprintf ppf "."

      | LF.Dec (LF.Empty, ctyp_decl) ->
          fprintf ppf "%a"
            (fmt_ppr_lf_ctyp_decl LF.Empty LF.Empty lvl) ctyp_decl

      | LF.Dec (cO, ctyp_decl) ->
          fprintf ppf "%a, %a"
            (fmt_ppr_lf_octx 0) cO
            (fmt_ppr_lf_ctyp_decl LF.Empty LF.Empty lvl) ctyp_decl

*)

    and fmt_ppr_lf_kind cPsi lvl ppf = function
      | LF.Typ ->
          fprintf ppf "type"

      | LF.PiKind ((LF.TypDecl (x, a), LF.Maybe), k) ->
          let x = fresh_name_dctx cPsi x in
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s{%s : %a}@ %a%s@]"
              (l_paren_if cond)
              (Id.render_name   x)
              (fmt_ppr_lf_typ LF.Empty cPsi  0) a
              (fmt_ppr_lf_kind (LF.DDec(cPsi, LF.TypDeclOpt  x)) 0) k
              (r_paren_if cond)

      | LF.PiKind ((LF.TypDecl (x, a), LF.No), k) ->
          let x = fresh_name_dctx cPsi x in
          let cond = lvl > 0 in
            fprintf ppf "@[<1>%s%a -> %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_lf_typ LF.Empty cPsi  1) a
              (fmt_ppr_lf_kind (LF.DDec(cPsi, LF.TypDeclOpt  x)) 0) k
              (r_paren_if cond)

    and fmt_ppr_lf_mtyp' cD lvl ppf = function
      | LF.ClTyp (LF.MTyp tA, cPsi) ->
          fprintf ppf "[%a |- %a]"
            (fmt_ppr_lf_dctx cD lvl) cPsi
            (fmt_ppr_lf_typ cD cPsi lvl) tA

      | LF.ClTyp (LF.PTyp tA, cPsi) ->
          fprintf ppf "#[%a |- %a]"
            (fmt_ppr_lf_dctx cD lvl) cPsi
            (fmt_ppr_lf_typ cD cPsi lvl) tA

      | LF.ClTyp (LF.STyp (cl, cPhi), cPsi) ->
          fprintf ppf "[%a |- %s  %a]"
            (fmt_ppr_lf_dctx cD lvl) cPsi
          (match cl with LF.Ren -> "#" | LF.Subst -> "")
            (fmt_ppr_lf_dctx cD lvl) cPhi
      | LF.CTyp (Some schemaName) ->
          fprintf ppf "%a"
            (fmt_ppr_lf_schema lvl) (Store.Cid.Schema.get_schema schemaName)
      | LF.CTyp None -> fprintf ppf "CTX"

    and fmt_ppr_lf_mtyp cD ppf = fmt_ppr_lf_mtyp' cD 0 ppf

    and fmt_ppr_lf_ctyp_decl ?(printing_holes=false) cD _lvl ppf = function
      | LF.Decl (u, mtyp,dep) ->

      (* Note: I'm not sure, in meta-context printing, implicit arguements should always be printed or not *)
      (* This modification won't print it if Control.printImplicit is false*)

         if ((not !Control.printImplicit) && (isImplicit dep) || (!Control.printNormal))
         then ()
         else
           fprintf ppf "{%s : %a}%s"
             (if printing_holes
              then Store.Cid.NamedHoles.getName ~tA:(getTyp mtyp) u
              else Id.render_name u)
             (fmt_ppr_lf_mtyp cD) mtyp
             (if !Control.printImplicit
              then dependent_string dep
              else inductive_string dep)

      | LF.DeclOpt name ->
          fprintf ppf "{%s : _ }"
            (Id.render_name name)

    and getTyp = function
      | LF.ClTyp (LF.MTyp tA, _)
      | LF.ClTyp (LF.PTyp tA, _) -> Some tA
      | _ -> None

    and isImplicit = function
            | LF.No -> false
            | LF.Maybe -> true
            | LF.Inductive -> false
    and dependent_string =
      function
      | LF.No -> "^e"
      | LF.Maybe -> "^i"
      | LF.Inductive -> "*"

    and inductive_string dep =
      match dep with
      | LF.No -> ""
      | LF.Maybe -> ""
      | LF.Inductive -> "*"

    (* Computation-level *)
    let rec fmt_ppr_cmp_kind cD lvl ppf = function
      | Comp.Ctype _ -> fprintf ppf "ctype"
      | Comp.PiKind (_, ctyp_decl, cK) ->
         let ctyp_decl = fresh_name_ctyp_decl cD ctyp_decl in
         let cond = lvl > 0 in
         begin
            fprintf ppf "@[<1>%s%a@ %a%s@]"
              (l_paren_if cond)
              (fmt_ppr_lf_ctyp_decl cD 1) ctyp_decl
              (fmt_ppr_cmp_kind (LF.Dec(cD, ctyp_decl)) 1) cK
              (r_paren_if cond)
          end

    let fmt_ppr_meta_typ cD lvl ppf = fmt_ppr_lf_mtyp' cD lvl ppf

    let rec fmt_ppr_meta_spine cD lvl ppf = function
      | Comp.MetaNil ->
          fprintf ppf ""
      | Comp.MetaApp (mO, mS) ->
          fprintf ppf " %a%a"
            (fmt_ppr_meta_obj  cD (lvl + 1)) mO
            (fmt_ppr_meta_spine   cD lvl) mS

    and fmt_ppr_iterm cD cPsi _lvl ppf = function
      | LF.INorm tM -> fmt_ppr_lf_normal cD cPsi 0 ppf tM
      | LF.IHead h -> fmt_ppr_lf_head cD cPsi 0 ppf h
      | LF.ISub s -> fmt_ppr_lf_sub cD cPsi 0 ppf s

    let rec fmt_ppr_cmp_typ cD lvl ppf = function
      | Comp.TypBase (_, c, mS)->
          let cond = lvl > 1 in
            fprintf ppf "%s%s%a%s"
              (l_paren_if cond)
              (R.render_cid_comp_typ c)
              (fmt_ppr_meta_spine cD lvl) mS
              (r_paren_if cond)
      | Comp.TypCobase (_, c, mS)->
          let cond = lvl > 1 in
            fprintf ppf "%s%s%a%s"
              (l_paren_if cond)
              (R.render_cid_comp_cotyp c)
              (fmt_ppr_meta_spine cD lvl) mS
              (r_paren_if cond)
      | Comp.TypBox (_, mT) ->
          fprintf ppf "%a"
              (fmt_ppr_meta_typ cD 0) mT

      | Comp.TypArr (tau1, tau2) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a -> %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_typ cD 0) tau1
              (fmt_ppr_cmp_typ cD 0) tau2
              (r_paren_if cond)

      | Comp.TypCross (tau1, tau2) ->
          let cond = lvl > 0 in
            fprintf ppf "%s%a * %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_typ cD 1) tau1
              (fmt_ppr_cmp_typ cD 0) tau2
              (r_paren_if cond)

      | Comp.TypPiBox (ctyp_decl, tau) ->
        let ctyp_decl = fresh_name_ctyp_decl cD ctyp_decl in
        let cond = lvl > 1 in
        fprintf ppf "%s%a %a%s"
          (l_paren_if cond)
          (fmt_ppr_lf_ctyp_decl cD 1) ctyp_decl
          (fmt_ppr_cmp_typ (LF.Dec(cD, ctyp_decl)) 1) tau
          (r_paren_if cond)

      | Comp.TypClo (_, _ ) ->             fprintf ppf " TypClo! "

      | Comp.TypInd tau ->
            fprintf ppf "(%a)*"
              (fmt_ppr_cmp_typ cD 1) tau

    let rec fmt_ppr_pat_spine cD cG lvl ppf = (function
      | Comp.PatNil -> fprintf ppf ""
      | Comp.PatApp (_, pat, pat_spine) ->
          fprintf ppf "%a %a"
            (fmt_ppr_pat_obj cD cG (lvl+1)) pat
            (fmt_ppr_pat_spine cD cG lvl) pat_spine)

    and fmt_ppr_pat_obj cD cG lvl ppf =
      let rec dropSpineLeft ms n = match (ms, n) with
      | (_, 0) -> ms
      | (Comp.PatNil, _) -> ms
      | (Comp.PatApp (_l,_p,rest), n) -> dropSpineLeft rest (n-1)
      in let deimplicitize_spine c ms =
          let ia = if !Control.printImplicit
                 then 0
                else Store.Cid.CompConst.get_implicit_arguments c in
       dropSpineLeft ms ia in
      function
      | Comp.PatEmpty (_, cPsi) ->
            fprintf ppf "[%a |- {}]"
              (fmt_ppr_lf_dctx cD 0) cPsi
      | Comp.PatMetaObj (_, mO) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a%s"
              (l_paren_if cond)
              (fmt_ppr_meta_obj cD 0) mO
              (r_paren_if cond)
      | Comp.PatConst (_, c, pat_spine) ->
          let pat_spine = deimplicitize_spine c pat_spine in
          let cond = lvl > 1 in
            fprintf ppf "%s%s %a%s"
              (l_paren_if cond)
              (R.render_cid_comp_const c)
              (fmt_ppr_pat_spine cD cG 2) pat_spine
              (r_paren_if cond)

      | Comp.PatPair (_, pat1, pat2) ->
          fprintf ppf "(%a , %a)"
            (fmt_ppr_pat_obj cD cG 0) pat1
            (fmt_ppr_pat_obj cD cG 0) pat2
      | Comp.PatAnn (_, pat, tau) ->
          fprintf ppf "(%a : %a)"
            (fmt_ppr_pat_obj cD cG 0) pat
            (fmt_ppr_cmp_typ cD 0) tau

      | Comp.PatVar (_, offset ) ->
          fprintf ppf "%s"
            (R.render_var cG offset)

      | Comp.PatFVar (_, name ) ->
          fprintf ppf "%s"
            (Id.render_name name)


    let rec fmt_ppr_cmp_exp_chk cD cG lvl ppf = function
      | Comp.Syn (_, i) ->
          fmt_ppr_cmp_exp_syn cD cG lvl ppf (strip_mapp_args cD cG i )

      | Comp.Fn (_, x, e) ->
          let x = fresh_name_gctx cG x in
          let cond = lvl > 0 in
 (*            fprintf ppf "@[<2>%sfn %s =>@ %a%s@]" *)
            fprintf ppf "%sfn %s =>@ "
              (l_paren_if cond)
              (Id.render_name x);

             fprintf ppf "%a%s"
               (fmt_ppr_cmp_exp_chk cD (LF.Dec(cG, Comp.CTypDeclOpt x))  0) e
               (r_paren_if cond);

       | Comp.Fun (_, fbr) -> fprintf ppf "Some fun"
        (* let cD1 = Context.append cD cD' in *)
        (* let cG1 = Context.append cG cG' in *)
(*           let cond = lvl > 0 in *)
(* (\*            fprintf ppf "@[<2>%sfun %s =>@ %a%s@]" *\) *)
(*             fprintf ppf "%sfun %a =>@ " *)
(*               (l_paren_if cond) *)
(*               (fmt_ppr_pat_spine cD' cG' lvl) ps; *)

(*             fprintf ppf "%a%s" *)
(*               (fmt_ppr_cmp_exp_chk cD' cG' 0) e *)
(*               (r_paren_if cond); *)


      | Comp.MLam (_, x, e) ->
          let x = fresh_name_mctx cD x in
          let cond = lvl > 0 in
            fprintf ppf "%smlam %s =>@ "
              (l_paren_if cond)
              (Id.render_name x);
            fprintf ppf "%a%s"
              (fmt_ppr_cmp_exp_chk (LF.Dec(cD, LF.DeclOpt x)) (Whnf.cnormCtx (cG, LF.MShift 1)) 0) e
              (r_paren_if cond);

      | Comp.Pair (_, e1, e2) ->
            fprintf ppf "(%a , %a)"
              (fmt_ppr_cmp_exp_chk cD cG 0) e1
              (fmt_ppr_cmp_exp_chk cD cG 0) e2


      | Comp.LetPair(_, i, (x, y, e)) ->
          let x = fresh_name_gctx cG x in
          let y = fresh_name_gctx cG y in
          let cond = lvl > 1 in
            fprintf ppf "@[<2>%slet <%s,%s> = %a@ in %a%s@]"
              (l_paren_if cond)
              (Id.render_name x)
              (Id.render_name y)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (fmt_ppr_cmp_exp_chk cD (LF.Dec(LF.Dec(cG, Comp.CTypDeclOpt x), Comp.CTypDeclOpt y)) 0) e
              (r_paren_if cond)


      | Comp.Let(_, i, (x, e)) ->
          let x = fresh_name_gctx cG x in
          let cond = lvl > 1 in
            fprintf ppf "@[<2>%slet %s = %a@ in %a%s@]"
              (l_paren_if cond)
              (Id.render_name x)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (fmt_ppr_cmp_exp_chk cD (LF.Dec(cG, Comp.CTypDeclOpt x)) 0) e
              (r_paren_if cond)

      | Comp.Box (_ , cM) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a%s"
              (l_paren_if cond)
              (fmt_ppr_meta_obj cD 0) cM
              (r_paren_if cond)

      | Comp.Case (_, prag, i, ([] as bs)) ->
          let cond = lvl > 0 in
          if !Control.printNormal then
            fprintf ppf "impossible %a"
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
          else
            fprintf ppf "@ %s@[<v>case @[%a@] of%s%a@]@,%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (match prag with Pragma.RegularCase -> "" | Pragma.PragmaNotCase -> " --not")
              (fmt_ppr_cmp_branches cD cG 0) bs
              (r_paren_if cond)



      | Comp.Case (_, prag, i, bs) ->
          let cond = lvl > 0 in
            fprintf ppf "@ %s@[<v>case @[%a@] of%s%a@]@,%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 0) (strip_mapp_args cD cG i)
              (match prag with Pragma.RegularCase -> "" | Pragma.PragmaNotCase -> " --not")
              (fmt_ppr_cmp_branches cD cG 0) bs
              (r_paren_if cond)

      | Comp.Hole (loc, name_opt) ->
         let name =
           match name_opt with
           | Some n -> n
           | None -> "" in
         try
            fprintf ppf "?%s" name
          with
          | _ -> fprintf ppf "?%s" name

    and strip_mapp_args cD cG i =
      if !Control.printImplicit then
        i
      else
        let (i', _ ) = strip_mapp_args' cD cG i in i'
    and strip_mapp_args' cD cG i = match i with
      | Comp.Const (_, prog) ->
          (i,  implicitCompArg  (Store.Cid.Comp.get prog).Store.Cid.Comp.typ)
      | Comp.DataConst (_, c) ->
          (i,  implicitCompArg  (Store.Cid.CompConst.get c).Store.Cid.CompConst.typ)
      | Comp.Var (_, x) ->
          begin match Context.lookup cG x with
              None -> (i, [])
            | Some tau -> (i,  implicitCompArg tau)
          end
      | Comp.Apply (loc, i, e) ->
          let (i', _) = strip_mapp_args' cD cG i in
            (Comp.Apply (loc, i', e), [])

      | Comp.MApp (loc, i1, mC) ->
          let (i', stripArg) = strip_mapp_args' cD cG i1 in
          (match stripArg with
          | false :: sA -> (i', sA)
          | true  :: sA -> (Comp.MApp (loc , i', mC), sA)
          | []          -> (i', [])                )
      | Comp.PairVal (loc, i1, i2) ->
          let (i1', _) = strip_mapp_args' cD cG i1 in
          let (i2', _) = strip_mapp_args' cD cG i2 in
          (Comp.PairVal (loc, i1', i2') , [])
      | _ -> (i, [])
    and implicitCompArg tau = begin match tau with
      | Comp.TypPiBox ((LF.Decl (_, LF.ClTyp (LF.MTyp _,_), LF.Maybe)), tau) ->
          (false)::(implicitCompArg tau)
      | Comp.TypPiBox (_ , tau) ->
          (true)::(implicitCompArg tau)
      | _ -> []
    end
    and fmt_ppr_cmp_exp_syn cD cG lvl ppf = function
      | Comp.Var (_, x) ->
          fprintf ppf "%s"
            (R.render_var cG x)

      | Comp.Const (_ ,prog) ->
          fprintf ppf "%s"
            (R.render_cid_prog prog)

      | Comp.DataConst (_, c) ->
          fprintf ppf "%s"
            (R.render_cid_comp_const c)

      | Comp.Obs (_, e, t, obs) ->
        fprintf ppf "%a.%s"
          (fmt_ppr_cmp_exp_chk cD cG 1) e
          (R.render_cid_comp_dest obs)

      | Comp.Apply (_, i, e) ->
          let cond = lvl > 1 in
            fprintf ppf "%s@[<2>%a@ %a@]%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              (fmt_ppr_cmp_exp_chk cD cG 2) e
              (r_paren_if cond)

      | Comp.MApp (_, i, mC) ->
          let cond = lvl > 1 in
            fprintf ppf "%s%a@ %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_syn cD cG 1) i
              (fmt_ppr_meta_obj cD 0) mC
              (r_paren_if cond)

      | Comp.PairVal (loc, i1, i2) ->
            fprintf ppf "(%a , %a)"
              (fmt_ppr_cmp_exp_syn cD cG 1) i1
              (fmt_ppr_cmp_exp_syn cD cG 1) i2

      | Comp.Ann (e, _tau) ->
          let cond = lvl > 1 in
(* When we are printing refined programs through the interactive mod
   we should not print type annotations.
            fprintf ppf "%s%a : %a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_chk cD cG 1) e
              (fmt_ppr_cmp_typ cD 2) (Whnf.cnormCTyp (tau, Whnf.m_id))
              (r_paren_if cond)
*)
            fprintf ppf "%s%a%s"
              (l_paren_if cond)
              (fmt_ppr_cmp_exp_chk cD cG 1) e
              (r_paren_if cond)

    and fmt_ppr_cmp_value lvl ppf =
      function
      | Comp.FunValue _ -> fprintf ppf " fn "
      | Comp.RecValue _ -> fprintf ppf " rec "
      | Comp.MLamValue _ -> fprintf ppf " mlam "
      | Comp.CtxValue _ -> fprintf ppf " mlam "
      | Comp.BoxValue mC -> fprintf ppf "%a"  (fmt_ppr_meta_obj LF.Empty 0) mC
      | Comp.ConstValue _ -> fprintf ppf " const "
      | Comp.PairValue (v1, v2) ->
        fprintf ppf "(%a , %a)"
          (fmt_ppr_cmp_value 0) v1
          (fmt_ppr_cmp_value 0) v2
      | Comp.DataValue (c, spine) ->
       (* Note: Arguments in data spines are accumulated in reverse order, to
            allow applications of data values in constant time. *)
       let k = if !Control.printImplicit then 0
             else Store.Cid.CompConst.get_implicit_arguments c in
         (* the function drop and print_spine can probably be combined
            to avoid traversing the spine twice.
        *)
       let rec drop ms = match ms with
         | Comp.DataNil -> (Comp.DataNil, 0)
         | Comp.DataApp (v, spine) ->
            let (ms', k') = drop spine in
            if k' < k then (ms', k'+1)
            else (Comp.DataApp (v, ms'), k'+1)
       in
         let rec print_spine ppf = function
           | Comp.DataNil -> ()
           | Comp.DataApp (v, spine) ->
              print_spine ppf spine;
              fprintf ppf " %a" (fmt_ppr_cmp_value 1 ) v
         in
       let (pat_spine, k') = drop spine in (* k = length of original spine *)


       let cond = lvl > 0 &&  (k' - k) > 1 in
         fprintf ppf "%s%s%a%s"
              (l_paren_if cond)
              (R.render_cid_comp_const c) print_spine pat_spine
              (r_paren_if cond)


    and fmt_ppr_cmp_branch_prefix _lvl ppf = function
      | LF.Empty -> ()
      | other ->
          (let rec fmt_ppr_ctyp_decls' ppf = function
            | LF.Dec (LF.Empty, decl) ->
                fprintf ppf "%a"
                  (fmt_ppr_lf_ctyp_decl LF.Empty 1) decl
            | LF.Dec (cD, decl) ->
                fprintf ppf "%a %a"
                  (fmt_ppr_ctyp_decls') cD
                  (fmt_ppr_lf_ctyp_decl cD 1) decl
          in
            fprintf ppf "@[%a@]@ " (fmt_ppr_ctyp_decls') other
          )

    and fmt_ppr_cmp_branches cD cG lvl ppf = function
      | [] -> ()

      | b :: [] ->
          fprintf ppf "%a"
            (fmt_ppr_cmp_branch cD cG 0) b

      | b :: bs ->
(*          fprintf ppf "%a @ @[<0>| %a@]" *)
          fprintf ppf "%a%a"
            (fmt_ppr_cmp_branch cD cG 0) b
            (fmt_ppr_cmp_branches cD cG lvl) bs


    and fmt_ppr_cmp_branch cD cG _lvl ppf = function
      | Comp.EmptyBranch (_, cD1, pat, t) ->
          if !Control.printNormal then
            fprintf ppf "@ @[<v2>| @[%a @] @]@ "
              (fmt_ppr_pat_obj cD1 LF.Empty 0) pat
          else
            fprintf ppf "@ @[<v2>| @[<v0>%a@[ %a : %a  @]  @] @]@ "
              (fmt_ppr_cmp_branch_prefix  0) cD1
              (fmt_ppr_pat_obj cD1 LF.Empty 0) pat
              (fmt_ppr_refinement cD1 cD 2) t


      | Comp.Branch (_, cD1', _cG, Comp.PatMetaObj (_, mO), t, e) ->
         if !Control.printNormal then
           (match e with
            | Comp.Hole (loc, name) ->
               fprintf ppf "\n@[<v2>| %a => %a@]"
                 (fmt_ppr_meta_obj cD1' 0) mO
                 (fmt_ppr_cmp_exp_chk cD1' cG 1) e
            | _ ->
               fprintf ppf "@ @[<v2>| @[<v0>%a@[%a@  => @]@ @[<2>@ %a@]@] @]@ "
                 (fmt_ppr_cmp_branch_prefix 0) cD1'
                 (fmt_ppr_meta_obj cD1' 0) mO
                 (* NOTE: Technically: cD |- cG ctx and
                  *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
                  * -bp
                  *)
                 (fmt_ppr_cmp_exp_chk cD1' cG 1) e)
         else
           fprintf ppf "@ @[<v2>| @[<v0>%a@[%a : %a  @]  => @]@ @[<2>@ %a@]@]@ "
             (fmt_ppr_cmp_branch_prefix 0) cD1'
             (fmt_ppr_meta_obj cD1' 0) mO
             (* this point is where the " : " is in the string above *)
             (fmt_ppr_refinement cD1' cD 2) t
             (* NOTE: Technically: cD |- cG ctx and
              *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
              * -bp
              *)
             (fmt_ppr_cmp_exp_chk cD1' cG 1) e

      | Comp.Branch (_, cD1', cG', pat, t, e) ->
         let cG_t = cG (* Whnf.cnormCtx (cG, t) *) in
         let cG_ext = Context.append cG_t cG' in

         if !Control.printNormal then
           (* fprintf ppf "@ @[<v2>| @[<v0>%a ; %a@[ |- %a  @]  => @]@ @[<2>@ %a@]@]@ "
              (fmt_ppr_cmp_branch_prefix  0) cD1'
              (fmt_ppr_cmp_gctx cD1' 0) cG' *)
               fprintf ppf "@ @[| %a => %a@]@ "
             (fmt_ppr_pat_obj cD1' cG' 0) pat
             (* NOTE: Technically: cD |- cG ctx and
              *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
              * -bp
              *)
             (fmt_ppr_cmp_exp_chk cD1' cG_ext 1) e
         else
           fprintf ppf "@ @[<v2>| @[<v0>%a ; %a@[ |- %a  : %a  @]  => @]@ @[<2>@ %a@]@]@ "
             (fmt_ppr_cmp_branch_prefix  0) cD1'
             (fmt_ppr_cmp_gctx cD1' 0) cG'
             (fmt_ppr_pat_obj cD1' cG' 0) pat
             (* this point is where the " : " is in the string above *)
             (fmt_ppr_refinement cD1' cD 2) t
             (* NOTE: Technically: cD |- cG ctx and
              *       cD1' |- mcomp (MShift n) t    <= cD where n = |cD1|
              * -bp
              *)
             (fmt_ppr_cmp_exp_chk cD1' cG_ext 1) e

    (* cD |- t : cD'  *)

    and fmt_ppr_cmp_proof_state ppf =
      let open Comp in
      function
      | { context; goal; solution } ->
         fprintf ppf "@[<v>";
         Context.iter (Whnf.normMCtx context.cD)
           (fun cD v -> fprintf ppf "%a@," (fmt_ppr_lf_ctyp_decl cD std_lvl) v );
         Context.iter' (Whnf.normCtx context.cG)
           (fun v -> fprintf ppf "%a@," (fmt_ppr_cmp_ctyp_decl context.cD std_lvl) v );
         fprintf ppf "@]";
         for _ = 1 to 80 do fprintf ppf "-" done;
         let goal = Whnf.cnormCTyp goal in
         fprintf ppf "@,";
         fmt_ppr_cmp_typ context.cD std_lvl ppf goal

    and fmt_ppr_cmp_proof cD cG ppf =
      let open Comp in
      function
      | Incomplete ( _, s ) ->
         begin
           match s.solution with
           | None -> fprintf ppf "?"
           | Some proof -> fmt_ppr_cmp_proof cD cG ppf proof
         end
      | Command ( stmt, proof ) ->
         fprintf ppf "%a;@,%a"
           (fmt_ppr_cmp_command cD cG) stmt
           (fmt_ppr_cmp_proof cD cG) proof
      | Directive d ->
         fmt_ppr_cmp_directive cD cG ppf d

    and fmt_ppr_cmp_command cD cG ppf =
      let open Comp in
      function
      | By -> Misc.not_implemented "command By"
      | IH (t, name) ->
         fprintf ppf
           "IH: (%a) as %s"
           (fmt_ppr_cmp_exp_syn cD cG std_lvl) t
           (Id.render_name name)

    and fmt_ppr_cmp_split_branch
        : 'b. (Format.formatter -> 'b -> unit) -> Format.formatter ->
          (unit, 'b) Comp.split_branch ->
          unit =
      fun f ppf ->
      let open Comp in
      function
      | SplitBranch (c, h) ->
         fprintf ppf "@[<v>Case %a:@,%a@]@,"
           f c
           fmt_ppr_cmp_hypothetical h

    and fmt_ppr_cmp_directive cD cG ppf : unit Comp.directive -> unit =
      let open Comp in
      function
      | Intros h -> fprintf ppf "--intros@,%a" fmt_ppr_cmp_hypothetical h
      | InductionHypothesis (ts, name) -> Misc.not_implemented "ih"
      | CompSplit (t, _, bs) ->
         fprintf ppf "--comp-split (%a)@,@[<v>" (fmt_ppr_cmp_exp_syn cD cG std_lvl) t;
         List.iter
           (fmt_ppr_cmp_split_branch
              (fun ppf x ->
                fprintf ppf "%s" (Id.render_name x))
              ppf)
           bs;
         fprintf ppf "@]"
      | MetaSplit (m, _, bs) ->
         fprintf ppf "--meta-split (%a)@,@[<v>" (fmt_ppr_cmp_exp_syn cD cG std_lvl) m;
         List.iter
           (fmt_ppr_cmp_split_branch
              (fun ppf (cPsi, h) ->
                fprintf ppf "%a" (fmt_ppr_lf_head cD cPsi std_lvl) h)
              ppf)
           bs;
         fprintf ppf "@]"
      | Solve t ->
         fprintf ppf "--solve (%a)" (fmt_ppr_cmp_exp_chk cD cG std_lvl) t;

    and fmt_ppr_cmp_hypothetical ppf =
      let open Comp in
      function
      | Hypothetical ({cD; cG; cIH = _} as h, proof) ->
         fprintf ppf "@[<v>{ %a @[<v 2>%a@]@,}@]"
           fmt_ppr_cmp_hypotheses h
           (fmt_ppr_cmp_proof cD cG) proof;

    and fmt_ppr_cmp_hypotheses ppf =
      let open Comp in
      function
      | { cD; cG; cIH = _ } ->
         let cDs = Context.to_sublist cD in
         let cG' = Context.to_list cG in
         (* We don't print accumulated induction hypotheses,
            since a user wouldn't ever write them.
          *)

         let comma ppf () = fprintf ppf ",@ " in

         fprintf ppf "@[<hv>";
         pp_print_list
           ~pp_sep: comma
           (fun ppf (cD, x) -> fmt_ppr_lf_ctyp_decl cD std_lvl ppf x)
           ppf cDs;
         fprintf ppf "@]";

         fprintf ppf "@,| @[<hv>";

         pp_print_list
           ~pp_sep: comma
           (fun ppf x -> fmt_ppr_cmp_ctyp_decl cD std_lvl ppf x)
           ppf cG';
         fprintf ppf "@]@,;"

    and fmt_ppr_refinement cD cD0 lvl ppf t = begin match (t, cD0) with
      | (LF.MShift k, _ ) ->
          (match !Control.substitutionStyle with
            | Control.Natural -> fprintf ppf ""
            | Control.DeBruijn -> fprintf ppf "^%s" (string_of_int k))

      | (LF.MDot (f, LF.MShift k), LF.Dec(cD', decl)) ->
          (match !Control.substitutionStyle with
            | Control.Natural ->
                fprintf ppf "%a"
                  (fmt_ppr_refine_elem cD decl 1) f
            | Control.DeBruijn ->
                fprintf ppf "%a@ ,@ ^%s"
                  (fmt_ppr_refine_elem cD decl 1) f
                  (string_of_int k))


      | (LF.MDot (f, s), LF.Dec(cD', decl)) ->
          fprintf ppf "%a@ ,@ %a"
            (fmt_ppr_refine_elem cD decl 1) f
            (fmt_ppr_refinement cD cD' lvl) s
      | _ -> fprintf ppf "No match"
    end


    and fmt_ppr_refine_elem cD decl lvl ppf m =
      let name =
        match decl with
        | LF.Decl(name,_,_) -> name
        | LF.DeclOpt name -> name
      in
      fprintf ppf "%a = %s"
        (fmt_ppr_lf_mfront cD lvl) m
        (Id.render_name name)

    and fmt_ppr_cmp_arg cD lvl ppf = function
      | Comp.M m_obj -> fmt_ppr_meta_obj cD lvl ppf m_obj
      | Comp.V k -> Misc.not_implemented "IH offset arg printing"
      | Comp.DC -> fprintf ppf "_"
      | Comp.E -> Misc.not_implemented "IH E printing"

    and fmt_ppr_cmp_ctyp_decl cD lvl ppf = function
      | Comp.CTypDecl (x, tau, tag) ->
         let s = if tag then "*" else "" in
          fprintf ppf "%s%s: %a"
            (Id.render_name x) s
            (fmt_ppr_cmp_typ cD lvl) tau

      | Comp.WfRec (name, args, typ) ->
         fprintf ppf "%s @[<v>%a@] : %a"
           (Id.render_name name)
           (pp_print_list (fmt_ppr_cmp_arg cD lvl)) args
           (fmt_ppr_cmp_typ cD lvl) typ

      | Comp.CTypDeclOpt x ->
         fprintf ppf "%s : _" (Id.render_name x)

    and fmt_ppr_cmp_gctx cD lvl ppf cG =
      match cG with
      | LF.Empty -> fprintf ppf "."
      | _ ->
         let ds = Context.to_list cG in
         let comma ppf () = fprintf ppf ",@ " in
         pp_print_list ~pp_sep: comma (fmt_ppr_cmp_ctyp_decl cD 0) ppf ds

    let fmt_ppr_rec lvl ppf prefix (f, tau, e) =
      fprintf ppf "@\n%s %s : %a =@ @[<2>%a ;@]@\n"
            (prefix)
            (R.render_cid_prog  f)
            (fmt_ppr_cmp_typ LF.Empty lvl) tau
            (fmt_ppr_cmp_exp_chk  LF.Empty
               (LF.Dec(LF.Empty, Comp.CTypDecl ((Store.Cid.Comp.get f).Store.Cid.Comp.name ,  tau, false)))  lvl) e

    let rec fmt_ppr_sgn_decl lvl ppf = function
      | Sgn.CompTypAbbrev (_,_,_,_) -> ()
      | Sgn.Const (_, c, a) ->
          fprintf ppf "%s : %a.@\n"
            (R.render_cid_term c)
            (fmt_ppr_lf_typ LF.Empty  LF.Null lvl)  a

      | Sgn.Typ (_, a, k) ->
          fprintf ppf "%s : %a.@\n"
            (R.render_cid_typ  a)
            (fmt_ppr_lf_kind LF.Null lvl) k

      | Sgn.CompTyp (_, a, cK, _) ->
          fprintf ppf "@\ndatatype %s : @[%a@] = @\n"
             (Id.render_name a)
             (fmt_ppr_cmp_kind LF.Empty lvl) cK

      | Sgn.CompCotyp (_, a, cK) ->
          fprintf ppf "@\ncodatatype %s : @[%a@] = @\n"
             (Id.render_name a)
             (fmt_ppr_cmp_kind LF.Empty lvl) cK

      | Sgn.CompDest (_, c, cD, tau0, tau1) ->
        fprintf ppf "@ | (%s : @[%a@] :: @[%a@]@\n"
            (Id.render_name c)
            (fmt_ppr_cmp_typ cD lvl) tau0
            (fmt_ppr_cmp_typ cD lvl) tau1
      | Sgn.CompConst (_, c, tau) ->
          fprintf ppf "@ | %s : @[%a@]@\n"
            (Id.render_name c)
            (fmt_ppr_cmp_typ LF.Empty lvl) tau

      | Sgn.MRecTyp(_, l) -> List.iter (fmt_ppr_sgn_decl lvl ppf) (List.flatten l)

      | Sgn.Val (_, x, tau, i, None) ->
          fprintf ppf "@\nlet %s : %a = %a@\n"
            (Id.render_name x)
            (fmt_ppr_cmp_typ LF.Empty lvl) tau
            (fmt_ppr_cmp_exp_chk LF.Empty LF.Empty lvl) i

      | Sgn.Val (_, x, tau, i, Some v) ->
          fprintf ppf "@\nlet %s : %a = %a@\n   ===> %a@\n"
            (Id.render_name x)
            (fmt_ppr_cmp_typ LF.Empty lvl) tau
            (fmt_ppr_cmp_exp_chk LF.Empty LF.Empty lvl) i
            (fmt_ppr_cmp_value lvl) v

      | Sgn.Schema (w, schema) ->
          fprintf ppf "@\nschema %s = @[%a@];@\n"
            (R.render_cid_schema  w)
            (fmt_ppr_lf_schema ~useName:false lvl) schema

      | Sgn.Rec (((f, _, _ ) as h)::t) ->
        let total = if (Store.Cid.Comp.get f).Store.Cid.Comp.total
                        then " total" else ""
        in
          fmt_ppr_rec lvl ppf ("rec"^total) h;
          List.iter (fmt_ppr_rec lvl ppf ("and"^total)) t

      | Sgn.Pragma (LF.OpenPrag n) ->
          let n' = Store.Modules.name_of_id n in
          let _ = Store.Modules.open_module n' in
          fprintf ppf "@\n--open %s@\n" (String.concat "." n')

      | Sgn.Pragma _ -> ()

      | Sgn.Module(_, name, decls) ->
          let aux fmt t = List.iter (fun x -> (fmt_ppr_sgn_decl lvl fmt x)) t in

          (* Necessary to enforce correct printing *)
          let ((_, origName, _, _) as state) = Store.Modules.getState () in
          let newName = origName@[name] in
          let _ = Store.Modules.current := (Store.Modules.id_of_name newName) in
          let _ = Store.Modules.currentName := newName in
          let _ = fprintf ppf "@\nmodule %s = struct@\n@[<v2>%a@]@\nend;@\n"
                    (name) (aux) decls in
          Store.Modules.setState state

      |  _ -> ()

    (* Regular Pretty Printers *)
    let ppr_sgn_decl           = fmt_ppr_sgn_decl              std_lvl std_formatter
    let ppr_lf_ctyp_decl  cD   = fmt_ppr_lf_ctyp_decl cD    std_lvl std_formatter
    let ppr_lf_kind cPsi       = fmt_ppr_lf_kind cPsi          std_lvl std_formatter
    let ppr_lf_typ  cD cPsi    = fmt_ppr_lf_typ cD cPsi     std_lvl std_formatter
    let ppr_lf_normal cD cPsi  = fmt_ppr_lf_normal cD cPsi  std_lvl std_formatter
    let ppr_lf_tuple cD cPsi   = fmt_ppr_lf_tuple cD cPsi      std_lvl std_formatter
    let ppr_lf_head cD cPsi    = fmt_ppr_lf_head cD cPsi    std_lvl std_formatter
    let ppr_lf_spine cD cPsi   = fmt_ppr_lf_spine cD cPsi   std_lvl std_formatter
    let ppr_lf_sub cD cPsi     = fmt_ppr_lf_sub cD cPsi     std_lvl std_formatter

    let ppr_lf_schema          = fmt_ppr_lf_schema             std_lvl std_formatter
    let ppr_lf_sch_elem        = fmt_ppr_lf_sch_elem           std_lvl std_formatter

    let ppr_lf_typ_rec cD cPsi = fmt_ppr_lf_typ_rec cD cPsi std_lvl std_formatter

    let ppr_lf_dctx cD         = fmt_ppr_lf_dctx cD         std_lvl std_formatter
    let ppr_lf_mctx            = fmt_ppr_lf_mctx            std_lvl std_formatter
    let ppr_cmp_kind cD        = fmt_ppr_cmp_kind cD        std_lvl std_formatter
    let ppr_cmp_typ cD         = fmt_ppr_cmp_typ cD         std_lvl std_formatter
    let ppr_cmp_exp_chk cD cG  = fmt_ppr_cmp_exp_chk cD cG  std_lvl std_formatter
    let ppr_cmp_exp_syn cD cG  = fmt_ppr_cmp_exp_syn cD cG  std_lvl std_formatter
    let ppr_cmp_branches cD cG = fmt_ppr_cmp_branches cD cG std_lvl std_formatter
    let ppr_cmp_branch cD cG   = fmt_ppr_cmp_branch cD cG   std_lvl std_formatter

    let subToString cD cPsi s'  =
      let s = Whnf.normSub s' in
        fmt_ppr_lf_sub cD cPsi std_lvl str_formatter s
        ; flush_str_formatter ()

    let spineToString cD cPsi sS  =
      let tS = Whnf.normSpine sS in
        fmt_ppr_lf_spine cD cPsi std_lvl str_formatter tS
        ; flush_str_formatter ()

    let typToString cD cPsi sA    =
      let tA = Whnf.normTyp sA in
        fmt_ppr_lf_typ cD cPsi std_lvl str_formatter tA
        ; flush_str_formatter ()

    let mtypToString cD mtyp    =
      (* let tA = Whnf.normTyp sA in *)
        fmt_ppr_lf_mtyp cD str_formatter mtyp
        ; flush_str_formatter ()

    let typRecToString cD cPsi typrec_clo =
      let typrec = Whnf.normTypRec typrec_clo in
      fmt_ppr_lf_typ_rec cD cPsi std_lvl str_formatter typrec
      ; flush_str_formatter ()

    let kindToString cPsi sK   =
      let tK = Whnf.normKind sK in
      fmt_ppr_lf_kind cPsi std_lvl str_formatter tK
      ; flush_str_formatter ()

    let tupleToString cD cPsi tuple =
      fmt_ppr_lf_tuple cD cPsi std_lvl str_formatter tuple
      ; flush_str_formatter ()

    let headToString cD cPsi h =
      fmt_ppr_lf_head cD cPsi std_lvl str_formatter h
      ; flush_str_formatter ()

    let normalToString cD cPsi sM =
      let tM = Whnf.norm sM in
        fmt_ppr_lf_normal cD cPsi std_lvl str_formatter tM
        ; flush_str_formatter ()
    let itermToString cD cPsi tM =
      fmt_ppr_iterm cD cPsi std_lvl str_formatter tM
      ; flush_str_formatter ()
    let mmvarToString m =
      fmt_ppr_lf_mmvar std_lvl str_formatter m
      ; flush_str_formatter ()

    let dctxToString cD cPsi =
      fmt_ppr_lf_dctx cD std_lvl str_formatter (Whnf.normDCtx cPsi);
      flush_str_formatter ()

    let mctxToString cD =
      let cD' = Whnf.normMCtx cD in
      fmt_ppr_lf_mctx std_lvl str_formatter cD'
        ; flush_str_formatter ()

    let schemaToString schema =
      fmt_ppr_lf_schema std_lvl str_formatter schema
      ; flush_str_formatter ()

    let schElemToString sch_elem =
      fmt_ppr_lf_sch_elem std_lvl str_formatter sch_elem
      ; flush_str_formatter ()

    let cdeclToString cD cdecl =
      fmt_ppr_lf_ctyp_decl cD std_lvl str_formatter cdecl
      ; flush_str_formatter ()

    let metaTypToString  cD cT =
      let mT' = Whnf.cnormMetaTyp (cT, Whnf.m_id) in
        fmt_ppr_meta_typ cD std_lvl str_formatter mT'
        ; flush_str_formatter ()

    let metaObjToString  cD mO =
      let mO' = Whnf.cnormMetaObj (mO, Whnf.m_id) in
        fmt_ppr_meta_obj cD std_lvl str_formatter mO'
        ; flush_str_formatter ()

    let gctxToString cD cG =
      let cG' = Whnf.cnormCtx (Whnf.normCtx cG, Whnf.m_id) in
        fmt_ppr_cmp_gctx cD std_lvl str_formatter cG'
        ; flush_str_formatter ()

    let patternToString cD cG pat    =
      let pat' = Whnf.cnormPattern (pat , Whnf.m_id) in
       fmt_ppr_pat_obj cD cG std_lvl str_formatter pat'
      ; flush_str_formatter ()

    let expChkToString cD cG e    =
      let e' = Whnf.cnormExp (e , Whnf.m_id) in
       fmt_ppr_cmp_exp_chk cD cG std_lvl str_formatter e'
      ; flush_str_formatter ()

    let expSynToString cD cG i   =
      fmt_ppr_cmp_exp_syn cD cG std_lvl str_formatter i
      ; flush_str_formatter ()

    let valueToString v =
      fmt_ppr_cmp_value std_lvl str_formatter v
      ; flush_str_formatter ()

    let branchToString cD cG  b    =
      fmt_ppr_cmp_branch cD cG std_lvl str_formatter b
      ; flush_str_formatter ()

    let compTypToString cD tau  =
      let tau' = Whnf.normCTyp (Whnf.cnormCTyp (tau, Whnf.m_id)) in
        fmt_ppr_cmp_typ cD std_lvl str_formatter tau'
        ; flush_str_formatter ()

    let subCompTypToString cD sA  =
      let tA = Whnf.normCTyp (Whnf.cnormCTyp sA) in
        fmt_ppr_cmp_typ cD std_lvl str_formatter tA
        ; flush_str_formatter ()

    let compKindToString cD cK  =
(*      let cK' = Whnf.normCKind cK in  *)
        fmt_ppr_cmp_kind cD std_lvl str_formatter cK
        ; flush_str_formatter ()


    let msubToString cD   s    =
      let s' = Whnf.cnormMSub s in
      fmt_ppr_lf_msub cD std_lvl str_formatter s'
      ; flush_str_formatter ()

    let sgnDeclToString   : Sgn.decl -> string = fun d ->
      fmt_ppr_sgn_decl std_lvl str_formatter d; flush_str_formatter ()
  end (* Int.Make *)

  (* Default Error Pretty Printer Functor Instantiation *)
  module DefaultPrinter = Make (Store.Cid.NamedRenderer)

end (* Int *)

module Ext = Prettyext.Ext
