tp: type.
nat: tp.
arr: tp -> tp -> tp.

exp : tp -> type.
z : exp nat.
s  : exp nat -> exp nat.
lam : {T1:tp}{T2:tp}(exp T1 -> exp T2) -> exp (arr T1 T2).

rec identity : (exp nat)[.] -> (exp nat) [.] =
    fn x =>
      case x of
          box (. z)   : (exp nat) [.] => box (. z)
        | {U::exp nat [.]} box (. s U ![ . ]! ) : (exp nat) [.] => box (. s U ![ . ]! );


schema w = some [T:tp] block exp T;


rec identity' : {g:(w)*}{T:: tp[g]} (exp T ![ id ]! )[g] -> (exp T ![ id]! ) [g] =
FN g =>  mlam T => 
    fn x =>
      case x of
          box (g. z)   : (exp nat) [g] => box (g. z)
        | {U::exp nat [g]} box (g. s U ![ id]! ) : (exp nat) [g] => box (g. s U ![id]! )
%
	| {T::tp[g]}{#p:: (exp T![id]!)[g]}
          box(g. #p![id]!) : (exp T![id]!)[g] => 
	    box(g. #p![id]!)
;


rec copy : {g:(w)*}{T:: tp[g]} (exp T ![id]! )[g] -> (exp T ![id]! ) [g] =
FN g =>  mlam T => 
    fn x =>
      case x of

          box (g. z)   : (exp nat) [g] => box (g. z)

        | {U::exp nat [g]} 
           box (g. s U ![id]! ) : (exp nat) [g] => 
	   (case (copy [g] < g. nat > (box(g. U![id]!))) of
	      {V::exp nat [g]}box (g. V ![id]! ) : (exp nat)[g]=> box(g. s V![id]!))

        | {T1::tp[g]}{T2::tp[g]}{E::(exp T2![id]!)[g, x:(exp T1![id]!)]}

           box(g . lam T1![id]!  T2![id]!  (\ x. E![id , x]!)) : (exp (arr T1![id]! T2![id]!))[g] => 
              box(g . lam T1![id]!  T2![id]!  (\ x. E![id , x]!)) 					  

        | {T1::tp[g]}{T2::tp[g]}{E::(exp T2![id]!)[g, x:(exp T1![id]!)]}
           box(g . lam T1![id]!  T2![id]!  (\ x. E![id , x]!)) : (exp (arr T1![id]! T2![id]!))[g] => 
	   x

 	| {T::tp[g]}{#p::(exp T![id]!) [g]} 
            box(g. #p![id]!) : (exp T![id]!)[g] => box(g. #p![id]!)
;
