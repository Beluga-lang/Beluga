%{ 
  CH 3:  Untyped arithmetic expressions
  Author: Brigitte Pientka

  EVALUATION
}%

% Small-step operational semantics
step: term -> term -> type.

e_switch_true:  
   step (switch true T2 T3)    T2.

e_switch_false:
   step (switch false T2 T3)   T3.

e_switch:
   step T1 T1'
-> step (switch T1 T2 T3)      (switch T1' T2 T3).


% Example:

let t : (step (switch (switch true false false)
                      true 
                      true)
              (switch false true true)) [ ]
= [ ] e_switch e_switch_true ;

let d : (step (switch (switch (switch true false false)
                               true 
                               true)
                       false 
                       false) 
        
              (switch (switch false true true)
	              false
                      false)) [ ]
= [ ] e_switch (e_switch e_switch_true) ;


% Values
value: term -> type.

v_true : value true.
v_false: value false.


equal: term -> term -> type.
ref: equal T T.

%{
Determinacy of evaluation:

Theorem: if step T T1 and step T T2 then equal T1 T2.

}%

steps_to_terms: term -> term -> term -> type.
andalso: step T T1 -> step T T2 -> steps_to_terms T T1 T2.


rec det : (steps_to_terms T T1 T2)[ ] -> (equal T1 T2)[ ] =
fn s => case s of 
| [ ] andalso (e_switch_true)  (e_switch_true)  =>  [ ] ref
| [ ] andalso (e_switch_false) (e_switch_false) =>  [ ] ref
| [ ] andalso (e_switch D)     (e_switch E)     =>
  let [ ] ref        = det ([ ] andalso D E) in 
    [ ] ref
;



% Normal form = values
%{ Multi-step evaluation rules

  Reflexive, transitive closure of one-step evaluation.

}%
mstep: term -> term -> type.

m_step : step M N 
     -> mstep M N.   

m_ref  : mstep M M.  % Reflexive

m_tr   : mstep M N1 -> mstep N1 N 
      -> mstep M N.  % Transitive


%{
Theorem: Uniqueness of evaluation

If mstep M N  and mstep M N'  then equal N N'.

}%

msteps_to_terms: term -> term -> term -> type.
andalso': mstep M M1 -> mstep M M2 -> msteps_to_terms M M1 M2.

rec unique : (msteps_to_terms M N1 N2)[ ] -> (equal N1 N2)[ ] =
fn ms => case ms of 
| [ ] andalso' (m_step S1) (m_step S2) => 
  let [ ] ref = det ([ ] andalso S1 S2) in 
    [ ] ref

| [ ] andalso' (m_ref)       (m_ref)   => 
   [ ] ref

| [ ] andalso' (m_tr S1 S1') (m_tr S2 S2') => 
  let [ ] ref = unique ([ ] andalso' S1 S2) in 
    unique ([ ] andalso' S1' S2') 
;

