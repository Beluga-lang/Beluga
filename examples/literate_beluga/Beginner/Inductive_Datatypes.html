<html>
<head>
	<meta charset="UTF-8">
	<style type="text/css">
		body {
			padding: 2em 1em 2em 1em;
			margin: 0;
			font-family: sans-serif;
			color: black;
			background: white;}
		a{text-decoration:none;}
		a:link { color: #00C; background: transparent }
		a:visited { color: #00C; background: transparent }
		a:active { color: #C00; background: transparent }
		keyword { color: #3333cc ; background: transparent }
		p {display: inline;}
		pre {
			border: 1px dashed maroon;  display:block;
			padding:8px; background-color: #dddddd;}
		code {
			background-color: #dddddd;
			color: black; font-family: "courier";margin:0;
			white-space: pre-wrap; }
		.typ {color: #660000; font-weight:bold}
		.constructor {color: #335C85; font-weight:bold}
		.function {color: #660033; font-weight:bold}
		.schema {color: #6600CC; font-weight:bold}
	</style>
</head>
<body>

<p><h2>Algorithmic Equality for the Untyped Lambda-calculus (R-version)</h2>This case-study is a mechanization of <a href="https://github.com/pientka/ORBI/blob/master/benchmarks/EqualUntyped.orbi" target="_blank">EqualUntyped.orbi</a>. We examine Theorems 7, 10, & 22 from <a href="orbi-jar.pdf" target="_blank">(Felty et al, 2014)</a>, proving each by the <i>context relation</i> (R) approach.</p>
<p><ul>
<li><b>Theorem 7 (Admissibility of Reflexivity):</b> If  <code>g &#8866; is_tm M</code> then <code>g &#8866; aeq M M</code>.</li><br>
<li><b>Theorem 10 (Admissibility of Symmetry and Transitivity):</b>
<ol> <br>
<li>If <code>g:xaG</code> and <code>g &#8866; aeq M L</code> and <code>g &#8866; aeq L N</code> then <code>g &#8866; aeq M N</code>.</li><br>
<li>If <code>g:xaG</code> and <code>g &#8866; aeq M N</code> then <code>g &#8866; aeq N M</code>.</li><br>
</ol></li>
<li><b>Theorem 22 (Completeness):</b> If <code>g:daG</code> and <code>g &#8866; deq M N</code> then <code>g &#8866; aeq M N</code>.</li><br>
</ul>
</p><p>
We have seen that Beluga elegantly supports proofs using generalized contexts. Here we exploit the ability to define context relations in Beluga to implement proofs using context relations (R Version). To illustrate the idea, we go back to the reflexivity proof for algorithmic equality.</p>
<p><h3>Syntax</h3>
Untyped lambda-terms are introduced with LF-level declarations. The context schemas translate directly from the ORBI file. </p><br><pre><code><span class="typ" id="tm">tm</span> : <keyword>type</keyword>.
<br><span class="constructor" id="app">app</span> : <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a>.
<br><span class="constructor" id="lam">lam</span> : (<a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a>) &#x2192 <a href="#tm">tm</a>.
<br><span class="typ" id="aeq">aeq</span> : <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a> &#x2192 <keyword>type</keyword>.
<br><span class="constructor" id="ae_l">ae_l</span> : {x : <a href="#tm">tm</a>} <a href="#aeq">aeq</a> x x &#x2192 <a href="#aeq">aeq</a> M x N x &#x2192 <a href="#aeq">aeq</a> <a href="#lam">lam</a> (&lambda;x. M x) <a href="#lam">lam</a> (&lambda;x. N x).
<br><span class="constructor" id="ae_a">ae_a</span> : <a href="#aeq">aeq</a> M1 N1 &#x2192 <a href="#aeq">aeq</a> M2 N2 &#x2192 <a href="#aeq">aeq</a> <a href="#app">app</a> M1 M2 <a href="#app">app</a> N1 N2.
<br><keyword>schema</keyword> <span class="schema" id="xG">xG</span> = <a href="#tm">tm</a>;
<br><keyword>schema</keyword> <span class="schema" id="xaG">xaG</span> = <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x);
</code></pre>
<p></p><p>
<h2> Context Relationships via Inductive Datatypes</h2>
</p><p>
The key to express context weakening and strengthening is the ability to relate two contexts via a substitution. In Beluga, we can describe context relations using <i>inductive datatypes</i> as a relation between context <code>phi</code>, context <code>psi</code>, and a substitution <code>#S</code> that maps variables from <code>phi</code> to the context <code>psi</code>, formally <code>#S:psi &#8866; phi</code> as follows:</p><br><pre><code><keyword>datatype</keyword> <span class="typ" id="Ctx_xaR">Ctx_xaR</span> : {phi : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xaG">xaG</a>} &#x2192 [psi &#x22A2 phi] &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Nil_xa">Nil_xa</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [] [] [ &#x22A2 ^]
| <span class="constructor" id="Cons_xa">Cons_xa</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 <a href="#Ctx_xaR">Ctx_xaR</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b &#x22A2  #S[&hellip;] b.1];
</code></pre>
<p>We again use first-class substitution variables <code>#S</code> of type <code>[psi &#8866; phi]</code> to move from the context <code>phi</code> to the context <code>psi</code>. If <code>#S</code> relates <code>phi</code> and <code>psi</code>, then the substitution <code>#S b.1</code> relates context <code>phi, x:tm</code> to <code>psi, b:block (x:tm,u:aeq x x)</code> via constructor <code>Cons_xaR</code>.</p><br><pre><code><keyword>datatype</keyword> <span class="typ" id="EqV">EqV</span> : {phi : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xaG">xaG</a>} &#x2192 [psi &#x22A2 phi] &#x2192 {x : [phi &#x22A2 <a href="#tm">tm</a>]} &#x2192 {y : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="EqV_v">EqV_v</span> : <a href="#EqV">EqV</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2  #S[&hellip;] b.1] [phi, x : <a href="#tm">tm</a> &#x22A2 x] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.1]
| <span class="constructor" id="EqV_p">EqV_p</span> : <a href="#EqV">EqV</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;] &#x2192 <a href="#EqV">EqV</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b &#x22A2  #S[&hellip;] b.1] [phi, x : <a href="#tm">tm</a> &#x22A2 #p &hellip;] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 #q.1 &hellip;];
<br><keyword>datatype</keyword> <span class="typ" id="Eq">Eq</span> : {phi : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xaG">xaG</a>} &#x2192 [psi &#x22A2 phi] &#x2192 {y1 : [phi &#x22A2 <a href="#tm">tm</a>]} &#x2192 {z : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Eq_v">Eq_v</span> : <a href="#EqV">EqV</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;]
| <span class="constructor" id="Eq_a">Eq_a</span> : <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 M &hellip;] [psi &#x22A2 M' &hellip;] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 N &hellip;] [psi &#x22A2 N' &hellip;] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 <a href="#app">app</a> (M &hellip;) (N &hellip;)] [psi &#x22A2 <a href="#app">app</a> (M' &hellip;) (N' &hellip;)]
| <span class="constructor" id="Eq_l">Eq_l</span> : <a href="#Eq">Eq</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2  #S[&hellip;] b.1] [phi, x : <a href="#tm">tm</a> &#x22A2 M &hellip; x] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 M' &hellip; b.1] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] [psi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M' &hellip; x)];
</code></pre>
<p></p><p>
<h3>Proof of Reflexivity, Compact version</h3>
The recursive function <code>refl</code> of type <code>{phi:xG}{M: [phi &#8866;  tm]} Ctx_xaR [phi] [psi] [ psi &#8866; #S[&hellip;] ] -> [psi &#8866;  aeq (M #S[&hellip;]) (M #S[&hellip;])]</code>:  for all contexts <code>phi</code> and <code>psi</code> that have schema <code>xG</code> and <code>xaG</code>, respectively, if we have a substitution <code>#S</code> s.t. <code>#S:psi &#8866; phi</code> then for all terms <code>M</code> depending on <code>phi</code>, we have a proof that <code>[ psi &#8866; aeq (#p #S[&hellip;]) (#p #S[&hellip;])]</code>." Since the term <code>M</code> depends only on the context <code>phi</code>, it is explicitly weakened through applying <code>#S</code> to move it to the context <code>psi</code>.</p><br><pre><code><keyword>rec</keyword> <span class="function" id="ctx_membership">ctx_membership</span> : {#p : [phi &#x22A2 <a href="#tm">tm</a>]} (<a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]]) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (#p #S[&hellip;]) (#p #S[&hellip;])] =
<keyword>mlam</keyword> #p &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>let</keyword>  (cr : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]])= cr <keyword>in</keyword>
                                                                    <keyword>case</keyword> [phi &#x22A2 #p &hellip;] <keyword>of</keyword> 
                                                                    | [phi, x : <a href="#tm">tm</a> &#x22A2 x] &#x21D2
                                                                    <keyword>let</keyword>  Cons_xa cr' = cr <keyword>in</keyword>
                                                                    <keyword>let</keyword>  (cr' : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]])= cr' <keyword>in</keyword>
                                                                    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.2]
                                                                    | [phi, x : <a href="#tm">tm</a> &#x22A2 #p &hellip;] &#x21D2
                                                                    <keyword>let</keyword>  Cons_xa cr' = cr <keyword>in</keyword>
                                                                    <keyword>let</keyword>  [psi &#x22A2 E &hellip;] =
                                                                    <a href="#ctx_membership">ctx_membership</a> [phi &#x22A2 #p &hellip;] cr' <keyword>in</keyword>
                                                                    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E &hellip;];
<br><keyword>rec</keyword> <span class="function" id="refl">refl</span> : {phi : <a href="#xG">xG</a>} {M : [phi &#x22A2 <a href="#tm">tm</a>]} (<a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]]) &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M #S[&hellip;]) (M #S[&hellip;])] =
<keyword>mlam</keyword> phi &#x21D2 <keyword>mlam</keyword> M &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>case</keyword> [phi &#x22A2 M &hellip;] <keyword>of</keyword> 
  | [phi &#x22A2 #p &hellip;] &#x21D2 <a href="#ctx_membership">ctx_membership</a> [phi &#x22A2 #p &hellip;] cr
  | [phi &#x22A2 <a href="#app">app</a> (M &hellip;) (N &hellip;)] &#x21D2
    <keyword>let</keyword>  [psi &#x22A2 D1 &hellip;] = <a href="#refl">refl</a> [phi] [phi &#x22A2 M &hellip;] cr <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 D2 &hellip;] = <a href="#refl">refl</a> [phi] [phi &#x22A2 N &hellip;] cr <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)]
  | [phi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] &#x21D2
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#refl">refl</a> [phi, x : <a href="#tm">tm</a>] [phi, x : <a href="#tm">tm</a> &#x22A2 M &hellip; x] (<a href="#Cons_xa">Cons_xa</a> cr) <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D &hellip; x u)];
</code></pre>
<p>The proof is implemented as a recursive function over the term M. We again consider three possible cases: If we have an application <code>[ phi &#8866; app (M1 ::)(M2 ::)]</code>, we appeal to the induction hypothesis on <code>[phi &#8866; M1 &hellip;]</code> and <code>[ &#8866; M2 ::]</code> by making a recursive call. Since the context <code>phi</code> and the context <code>psi</code> do not change, we can simply make the recursive all on <code>[phi &#8866; M1 ::]</code> and <code>[phi &#8866; M2 ::]</code> respectively using the relation <code>cr</code>.
<br><br>
When we have <code>[phi &#8866; lam \x.M :: x]</code>, we want to appeal to the induction hypothesis on <code>[phi &#8866; x:tm. M ::x]</code>. To make the recursive call, we also need a witness relating the context <code>[phi &#8866; x:tm. M ::x]</code> to the context <code>[psi, b:block (x:tm,u:aeq x x)]</code>. Recall that <code>cr</code> stands for <code>Ctx_xaR [phi] [psi] [psi &#8866; #S]</code>. Therefore, by <code>Cons_xa</code>, we know there exists <code>Ctx_xaR [phi ,x:tm] [psi ,b:block (x:tm,u:aeq x x)] [psi, b &#8866; #S b.1]</code> and we appeal to the induction hypothesis by <code>reflR [phi,x:tm] [phi,x:tm.M ::x] (Cons_xa cr)</code>.
<br><br>
Finally, we take a close look at the variable case. For clarity, we follow the outline of the proof from the companion paper (Felty et al, 2014) and factor out the Context Membership Lemma. We distinguish two different cases depending on the position of the variable in the context by pattern matching on the shape of <code>phi</code>. If <code>[phi,x:tm &#8866; x]</code>, then we inspect the context relation <code>cr</code>. We note that pattern matching forces the original context <code>phi</code> to be <code>phi,x:tm</code>. By pattern matching on <code>cr'</code>, we observe that there exists a relation <code>cr'</code>, s.t. <code>Ctx_xaR [phi] [psi] [psi &#8866; #S]</code>. Moreover, <code>psi = psi,b:block (x:tm,u:aeq x x)</code> and <code>#S = #S b.1</code> where the left hand side denotes the original context and substitution, while the right hand side shows the context and substitution refinement after pattern matching. We must show that there exists a proof for <code>aeq x x</code> in the context <code>psi, b:block (x:tm,u:aeq x x)</code>. This is simply <code>b.2</code>.</p>
<p><br><br>
Following we generalize reasoning about terms which contain substitution variables, reasoning explicitly about equality between terms <code>M</code> and <code>M #S[&hellip;]</code>. Since we cannot pattern match directly on <code>M #S[&hellip;]</code> (because <code>#S</code> is a general substitution and we do not enforce on the type-level that it is a variable-variable substitution) we cannot use unification to solve equations; If <code>#S</code> would be known to be a pattern substitution, then we could solve equations such as <code>M #S[&hellip;] = app (M1 &hellip;) (M2 &hellip;)</code>; we hence encode such equalities explicitly.
</p><p>
<h3>Proof of Reflexivity, Expanded</h3></p><br><pre><code><keyword>rec</keyword> <span class="function" id="ctx_member">ctx_member</span> : {#p : [phi &#x22A2 <a href="#tm">tm</a>]} (<a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]]) &#x2192 <a href="#EqV">EqV</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 M &hellip;] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M &hellip;) (M &hellip;)] =
<keyword>mlam</keyword> #p &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 
  <keyword>let</keyword>  (cr : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]])= cr <keyword>in</keyword>
  <keyword>case</keyword> [phi &#x22A2 #p &hellip;] <keyword>of</keyword> 
  | [phi, x : <a href="#tm">tm</a> &#x22A2 x] &#x21D2
    <keyword>let</keyword>  Cons_xa cr' = cr <keyword>in</keyword>
    <keyword>let</keyword>  EqV_v = m <keyword>in</keyword>
    <keyword>let</keyword>  (cr' : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]])= cr' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.2]
  | [phi, x : <a href="#tm">tm</a> &#x22A2 #p &hellip;] &#x21D2
    <keyword>let</keyword>  Cons_xa cr' = cr <keyword>in</keyword>
    <keyword>let</keyword>  EqV_p m' = m <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E &hellip;] = <a href="#ctx_member">ctx_member</a> [phi &#x22A2 #p &hellip;] cr' m' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E &hellip;];
<br><keyword>rec</keyword> <span class="function" id="reflR">reflR</span> : {phi : <a href="#xG">xG</a>} {M : [phi &#x22A2 <a href="#tm">tm</a>]} (<a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]]) &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 M &hellip;] [psi &#x22A2 M' &hellip;] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M' &hellip;) (M' &hellip;)] =
<keyword>mlam</keyword> phi &#x21D2 <keyword>mlam</keyword> M &#x21D2 <keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>case</keyword> [phi &#x22A2 M &hellip;] <keyword>of</keyword> 
  | [phi &#x22A2 #p &hellip;] &#x21D2 <keyword>let</keyword>  Eq_v m' = m <keyword>in</keyword> <a href="#ctx_member">ctx_member</a> [phi &#x22A2 #p &hellip;] cr m'
  | [phi &#x22A2 <a href="#app">app</a> (M &hellip;) (N &hellip;)] &#x21D2
    <keyword>let</keyword>  Eq_a m1 m2 = m <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 D1 &hellip;] = <a href="#reflR">reflR</a> [phi] [phi &#x22A2 M &hellip;] cr m1 <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 D2 &hellip;] = <a href="#reflR">reflR</a> [phi] [phi &#x22A2 N &hellip;] cr m2 <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)]
  | [phi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] &#x21D2
    <keyword>let</keyword>  Eq_l m' = m <keyword>in</keyword>
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D &hellip; b.1 b.2] =
    <a href="#reflR">reflR</a> [phi, x : <a href="#tm">tm</a>] [phi, x : <a href="#tm">tm</a> &#x22A2 M &hellip; x] (<a href="#Cons_xa">Cons_xa</a> cr) m' <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D &hellip; x u)];
<br><keyword>rec</keyword> <span class="function" id="transV">transV</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 <a href="#EqV">EqV</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 M &hellip;] [psi &#x22A2 #p.1 &hellip;] &#x2192 <a href="#EqV">EqV</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 N &hellip;] [psi &#x22A2 #p.1 &hellip;] &#x2192 <a href="#EqV">EqV</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 L &hellip;] [psi &#x22A2 #p.1 &hellip;] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> #p.1 &hellip; #p.1 &hellip;] =
<keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> n &#x21D2 <keyword>fn</keyword> l &#x21D2 <keyword>case</keyword> m <keyword>of</keyword> 
  | EqV_v  &#x21D2
    <keyword>let</keyword>  EqV_v = n <keyword>in</keyword>
    <keyword>let</keyword>  EqV_v = l <keyword>in</keyword>
    <keyword>let</keyword>  Cons_xa cr' = cr <keyword>in</keyword>
    <keyword>let</keyword>  (cr' : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]])= cr' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.2]
  | EqV_p m'  &#x21D2
    <keyword>let</keyword>  EqV_p n' = n <keyword>in</keyword>
    <keyword>let</keyword>  EqV_p l' = l <keyword>in</keyword>
    <keyword>let</keyword>  Cons_xa cr' = cr <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E &hellip;] = <a href="#transV">transV</a> cr' m' n' l' <keyword>in</keyword>
    [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E &hellip;];
<br><keyword>rec</keyword> <span class="function" id="transR">transR</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 M &hellip;] [psi &#x22A2 M' &hellip;] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 N &hellip;] [psi &#x22A2 N' &hellip;] &#x2192 <a href="#Eq">Eq</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 L &hellip;] [psi &#x22A2 L' &hellip;] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M' &hellip;) (N' &hellip;)] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (N' &hellip;) (L' &hellip;)] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (M' &hellip;) (L' &hellip;)] =
<keyword>fn</keyword> cr &#x21D2 <keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> n &#x21D2 <keyword>fn</keyword> l &#x21D2 <keyword>fn</keyword> d1 &#x21D2 <keyword>fn</keyword> d2 &#x21D2 <keyword>case</keyword> d1 <keyword>of</keyword> 
  | [psi &#x22A2 #p.2 &hellip;] &#x21D2
    <keyword>let</keyword>  [psi &#x22A2 #q.2 &hellip;] = d2 <keyword>in</keyword>
    <keyword>let</keyword>  Eq_v m' = m <keyword>in</keyword>
    <keyword>let</keyword>  (m' : <a href="#EqV">EqV</a> [phi] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2  #S[&hellip;]] [phi &#x22A2 #r &hellip;] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 #q.1 &hellip;])=
    m' <keyword>in</keyword> <a href="#ctx_member">ctx_member</a> [phi &#x22A2 #r &hellip;] cr m'
  | [psi &#x22A2 <a href="#ae_a">ae_a</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  [psi &#x22A2 <a href="#ae_a">ae_a</a> (F1 &hellip;) (F2 &hellip;)] = d2 <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a m1 m2 = m <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a n1 n2 = n <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a l1 l2 = l <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E1 &hellip;] = <a href="#transR">transR</a> cr m1 n1 l1 [psi &#x22A2 D1 &hellip;] [psi &#x22A2 F1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E2 &hellip;] = <a href="#transR">transR</a> cr m2 n2 l2 [psi &#x22A2 D2 &hellip;] [psi &#x22A2 F2 &hellip;] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (E1 &hellip;) (E2 &hellip;)]
  | [psi &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D1 &hellip; x u)] &#x21D2
    <keyword>let</keyword>  [psi &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. D2 &hellip; x u)] = d2 <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l m' = m <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l n' = n <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l l' = l <keyword>in</keyword>
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 F &hellip; b.1 b.2] =
    <a href="#transR">transR</a> (<a href="#Cons_xa">Cons_xa</a> cr) m' n' l' [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D1 &hellip; b.1 b.2] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 D2 &hellip; b.1 b.2] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. F &hellip; x u)];
<br><span class="typ" id="deq">deq</span> : <a href="#tm">tm</a> &#x2192 <a href="#tm">tm</a> &#x2192 <keyword>type</keyword>.
<br><span class="constructor" id="de_l">de_l</span> : {x : <a href="#tm">tm</a>} <a href="#deq">deq</a> x x &#x2192 <a href="#deq">deq</a> M x M' x &#x2192 <a href="#deq">deq</a> <a href="#lam">lam</a> (&lambda;x. M x) <a href="#lam">lam</a> (&lambda;x. M' x).
<br><span class="constructor" id="de_a">de_a</span> : <a href="#deq">deq</a> M1 N1 &#x2192 <a href="#deq">deq</a> M2 N2 &#x2192 <a href="#deq">deq</a> <a href="#app">app</a> M1 M2 <a href="#app">app</a> N1 N2.
<br><span class="constructor" id="de_r">de_r</span> : <a href="#deq">deq</a> M M.
<br><span class="constructor" id="de_t">de_t</span> : <a href="#deq">deq</a> M L &#x2192 <a href="#deq">deq</a> L N &#x2192 <a href="#deq">deq</a> M N.
<br><keyword>schema</keyword> <span class="schema" id="xdG">xdG</span> = <keyword>block</keyword> (x:<a href="#tm">tm</a>, de_v:<a href="#deq">deq</a> x x);
<br><keyword>schema</keyword> <span class="schema" id="daG">daG</span> = <keyword>block</keyword> (x:<a href="#tm">tm</a>, ae_v:<a href="#aeq">aeq</a> x x, de_v:<a href="#deq">deq</a> x x);
<br><keyword>datatype</keyword> <span class="typ" id="Ctx_xdR">Ctx_xdR</span> : {phi : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xdG">xdG</a>} &#x2192 [psi &#x22A2 phi] &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Nil_xd">Nil_xd</span> : <a href="#Ctx_xdR">Ctx_xdR</a> [] [] [ &#x22A2 ^]
| <span class="constructor" id="Cons_xd">Cons_xd</span> : <a href="#Ctx_xdR">Ctx_xdR</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 <a href="#Ctx_xdR">Ctx_xdR</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [psi, b &#x22A2  #S[&hellip;] b.1];
<br><keyword>datatype</keyword> <span class="typ" id="Ctx_adR">Ctx_adR</span> : {phi : <a href="#xaG">xaG</a>} &#x2192 {psi : <a href="#xdG">xdG</a>} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Nil_ad">Nil_ad</span> : <a href="#Ctx_adR">Ctx_adR</a> [] []
| <span class="constructor" id="Cons_ad">Cons_ad</span> : <a href="#Ctx_adR">Ctx_adR</a> [phi] [psi] &#x2192 <a href="#Ctx_adR">Ctx_adR</a> [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)];
</code></pre>
<p> Equality in addition to properties about equality, such as deterministic and existence. These properties are all encoded relationally, because we do not support functions in computation-level types. If we were to support functions in computation-level types, these proofs and some of these relations would go away.</p><br><pre><code><keyword>datatype</keyword> <span class="typ" id="EqV'">EqV'</span> : {phi : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xdG">xdG</a>} &#x2192 [psi &#x22A2 phi] &#x2192 {z1 : [phi &#x22A2 <a href="#tm">tm</a>]} &#x2192 {x1 : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="EqV'_v">EqV'_v</span> : <a href="#EqV'">EqV'</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2  #S[&hellip;] b.1] [phi, x : <a href="#tm">tm</a> &#x22A2 x] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 b.1]
| <span class="constructor" id="EqV'_p">EqV'_p</span> : <a href="#EqV'">EqV'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;] &#x2192 <a href="#EqV'">EqV'</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [psi, b &#x22A2  #S[&hellip;] b.1] [phi, x : <a href="#tm">tm</a> &#x22A2 #p &hellip;] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 #q.1 &hellip;];
<br><keyword>datatype</keyword> <span class="typ" id="Eq'">Eq'</span> : {phi : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xdG">xdG</a>} &#x2192 [psi &#x22A2 phi] &#x2192 {x2 : [phi &#x22A2 <a href="#tm">tm</a>]} &#x2192 {y2 : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Eq'_v">Eq'_v</span> : <a href="#EqV'">EqV'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;] &#x2192 <a href="#Eq'">Eq'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;]
| <span class="constructor" id="Eq'_a">Eq'_a</span> : <a href="#Eq'">Eq'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 M &hellip;] [psi &#x22A2 M' &hellip;] &#x2192 <a href="#Eq'">Eq'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 N &hellip;] [psi &#x22A2 N' &hellip;] &#x2192 <a href="#Eq'">Eq'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 <a href="#app">app</a> (M &hellip;) (N &hellip;)] [psi &#x22A2 <a href="#app">app</a> (M' &hellip;) (N' &hellip;)]
| <span class="constructor" id="Eq'_l">Eq'_l</span> : <a href="#Eq'">Eq'</a> [phi, x : <a href="#tm">tm</a>] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2  #S[&hellip;] b.1] [phi, x : <a href="#tm">tm</a> &#x22A2 M &hellip; x] [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 M' &hellip; b.1] &#x2192 <a href="#Eq'">Eq'</a> [phi] [psi] [psi &#x22A2  #S[&hellip;]] [phi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] [psi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M' &hellip; x)];
<br><keyword>datatype</keyword> <span class="typ" id="Equal_xaG">Equal_xaG</span> : {psi : <a href="#xaG">xaG</a>} &#x2192 {y3 : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 {z2 : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Refl_xaG">Refl_xaG</span> : <a href="#Equal_xaG">Equal_xaG</a> [psi &#x22A2 M &hellip;] [psi &#x22A2 M &hellip;];
<br><keyword>datatype</keyword> <span class="typ" id="Equal_xG">Equal_xG</span> : {psi : <a href="#xG">xG</a>} &#x2192 {z3 : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 {x3 : [psi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="Refl_xG">Refl_xG</span> : <a href="#Equal_xG">Equal_xG</a> [psi &#x22A2 M &hellip;] [psi &#x22A2 M &hellip;];
<br><keyword>datatype</keyword> <span class="typ" id="ExistsEq'">ExistsEq'</span> : {gamma : <a href="#xG">xG</a>} &#x2192 {phi : <a href="#xdG">xdG</a>} &#x2192 [phi &#x22A2 gamma] &#x2192 {L : [phi &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="ExistsEq'">ExistsEq'</span> : {L : [gamma &#x22A2 <a href="#tm">tm</a>]} (<a href="#Eq'">Eq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [gamma &#x22A2 L &hellip;] [phi &#x22A2 Ld &hellip;]) &#x2192 <a href="#ExistsEq'">ExistsEq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [phi &#x22A2 Ld &hellip;]
| <span class="constructor" id="ExistsEqV'">ExistsEqV'</span> : {#p : [gamma &#x22A2 <a href="#tm">tm</a>]} (<a href="#EqV'">EqV'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [gamma &#x22A2 #p &hellip;] [phi &#x22A2 #q.1 &hellip;]) &#x2192 <a href="#ExistsEq'">ExistsEq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [phi &#x22A2 #q.1 &hellip;];
<br><keyword>rec</keyword> <span class="function" id="existsEqV'">existsEqV'</span> : <a href="#Ctx_xdR">Ctx_xdR</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] &#x2192 {#p : [phi &#x22A2 <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x)]} <a href="#ExistsEq'">ExistsEq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [phi &#x22A2 #p.1 &hellip;] =
<keyword>fn</keyword> cr_xd &#x21D2 <keyword>mlam</keyword> #p &#x21D2 
  <keyword>let</keyword>  (cr_xd : <a href="#Ctx_xdR">Ctx_xdR</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]])= cr_xd <keyword>in</keyword>
  <keyword>case</keyword> [phi &#x22A2 #p.1 &hellip;] <keyword>of</keyword> 
  | [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 b.1] &#x21D2
    <keyword>let</keyword>  Cons_xd cr'_xd = cr_xd <keyword>in</keyword>
    <keyword>let</keyword>  (cr'_xd : <a href="#Ctx_xdR">Ctx_xdR</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]])= cr'_xd <keyword>in</keyword>
    <a href="#ExistsEqV'">ExistsEqV'</a> [gamma, x : <a href="#tm">tm</a> &#x22A2 x] <a href="#EqV'_v">EqV'_v</a>
  | [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 #p.1 &hellip;] &#x21D2
    <keyword>let</keyword>  Cons_xd cr'_xd = cr_xd <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEqV' ([gamma &#x22A2 #r &hellip;]) eq = <a href="#existsEqV'">existsEqV'</a> cr'_xd [phi &#x22A2 #p &hellip;] <keyword>in</keyword>
    <a href="#ExistsEqV'">ExistsEqV'</a> [gamma, x : <a href="#tm">tm</a> &#x22A2 #r &hellip;] (<a href="#EqV'_p">EqV'_p</a> eq);
<br><keyword>rec</keyword> <span class="function" id="existsEq'">existsEq'</span> : <a href="#Ctx_xdR">Ctx_xdR</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] &#x2192 {Ld : [phi &#x22A2 <a href="#tm">tm</a>]} <a href="#ExistsEq'">ExistsEq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [phi &#x22A2 Ld &hellip;] =
<keyword>fn</keyword> cr_xd &#x21D2 <keyword>mlam</keyword> Ld &#x21D2 
  <keyword>let</keyword>  (cr_xd : <a href="#Ctx_xdR">Ctx_xdR</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]])= cr_xd <keyword>in</keyword>
  <keyword>case</keyword> [phi &#x22A2 Ld &hellip;] <keyword>of</keyword>  
  | [phi &#x22A2 #p.1 &hellip;] &#x21D2 <a href="#existsEqV'">existsEqV'</a> cr_xd [phi &#x22A2 #p &hellip;]
  | [phi &#x22A2 <a href="#app">app</a> (M &hellip;) (N &hellip;)] &#x21D2
    <keyword>let</keyword>  ExistsEq' ([gamma &#x22A2 L1 &hellip;]) eq1 = <a href="#existsEq'">existsEq'</a> cr_xd [phi &#x22A2 M &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq' ([gamma &#x22A2 L2 &hellip;]) eq2 = <a href="#existsEq'">existsEq'</a> cr_xd [phi &#x22A2 N &hellip;] <keyword>in</keyword>
    <a href="#ExistsEq'">ExistsEq'</a> [gamma &#x22A2 <a href="#app">app</a> (L1 &hellip;) (L2 &hellip;)] (<a href="#Eq'_a">Eq'_a</a> eq1 eq2)
  | [phi &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] &#x21D2
    <keyword>let</keyword>  ExistsEq' ([gamma, x : <a href="#tm">tm</a> &#x22A2 L &hellip; x]) eq =
    <a href="#existsEq'">existsEq'</a> (<a href="#Cons_xd">Cons_xd</a> cr_xd) [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 M &hellip; b.1] <keyword>in</keyword>
    <a href="#ExistsEq'">ExistsEq'</a> [gamma &#x22A2 <a href="#lam">lam</a> (&lambda;x. L &hellip; x)] (<a href="#Eq'_l">Eq'_l</a> eq);
<br><keyword>datatype</keyword> <span class="typ" id="ExistsEq">ExistsEq</span> : {gamma : <a href="#xG">xG</a>} &#x2192 {psi : <a href="#xaG">xaG</a>} &#x2192 [psi &#x22A2 gamma] &#x2192 {L : [gamma &#x22A2 <a href="#tm">tm</a>]} &#x2192 <keyword>ctype</keyword> = 
| <span class="constructor" id="ExistsEqV">ExistsEqV</span> : {La : [psi &#x22A2 <a href="#tm">tm</a>]} (<a href="#EqV">EqV</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;]) &#x2192 <a href="#ExistsEq">ExistsEq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #p &hellip;]
| <span class="constructor" id="ExistsEq">ExistsEq</span> : {La : [psi &#x22A2 <a href="#tm">tm</a>]} (<a href="#Eq">Eq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 L &hellip;] [psi &#x22A2 La &hellip;]) &#x2192 <a href="#ExistsEq">ExistsEq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 L &hellip;];
<br><keyword>rec</keyword> <span class="function" id="existsEqV">existsEqV</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 {#p : [gamma &#x22A2 <a href="#tm">tm</a>]} <a href="#ExistsEq">ExistsEq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #p &hellip;] =
<keyword>fn</keyword> cr_xa &#x21D2 <keyword>mlam</keyword> #p &#x21D2 
  <keyword>let</keyword>  (cr_xa : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]])= cr_xa <keyword>in</keyword>
  <keyword>case</keyword> [gamma &#x22A2 #p &hellip;] <keyword>of</keyword> 
  | [gamma, x : <a href="#tm">tm</a> &#x22A2 x] &#x21D2
    <keyword>let</keyword>  Cons_xa cr'_xa = cr_xa <keyword>in</keyword>
    <keyword>let</keyword>  (cr'_xa : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]])= cr'_xa <keyword>in</keyword>
    <a href="#ExistsEqV">ExistsEqV</a> [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 b.1] <a href="#EqV_v">EqV_v</a>
  | [gamma, x : <a href="#tm">tm</a> &#x22A2 #p &hellip;] &#x21D2
    <keyword>let</keyword>  Cons_xa cr'_xa = cr_xa <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEqV ([psi &#x22A2 #q.1 &hellip;]) eq = <a href="#existsEqV">existsEqV</a> cr'_xa [gamma &#x22A2 #p &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  (eq : <a href="#EqV">EqV</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;])= eq <keyword>in</keyword>
    <a href="#ExistsEqV">ExistsEqV</a> [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 #q.1 &hellip;] (<a href="#EqV_p">EqV_p</a> eq);
<br><keyword>rec</keyword> <span class="function" id="existsEq">existsEq</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 {L : [gamma &#x22A2 <a href="#tm">tm</a>]} <a href="#ExistsEq">ExistsEq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 L &hellip;] =
<keyword>fn</keyword> cr_xa &#x21D2 <keyword>mlam</keyword> L &#x21D2 
  <keyword>let</keyword>  (cr_xa : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]])= cr_xa <keyword>in</keyword>
  <keyword>case</keyword> [gamma &#x22A2 L &hellip;] <keyword>of</keyword>  
  | [gamma &#x22A2 #p &hellip;] &#x21D2 <a href="#existsEqV">existsEqV</a> cr_xa [gamma &#x22A2 #p &hellip;]
  | [gamma &#x22A2 <a href="#app">app</a> (M &hellip;) (N &hellip;)] &#x21D2
    <keyword>let</keyword>  ExistsEq ([psi &#x22A2 La1 &hellip;]) eq1 = <a href="#existsEq">existsEq</a> cr_xa [gamma &#x22A2 M &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq ([psi &#x22A2 La2 &hellip;]) eq2 = <a href="#existsEq">existsEq</a> cr_xa [gamma &#x22A2 N &hellip;] <keyword>in</keyword>
    <a href="#ExistsEq">ExistsEq</a> [psi &#x22A2 <a href="#app">app</a> (La1 &hellip;) (La2 &hellip;)] (<a href="#Eq_a">Eq_a</a> eq1 eq2)
  | [gamma &#x22A2 <a href="#lam">lam</a> (&lambda;x. M &hellip; x)] &#x21D2
    <keyword>let</keyword>  ExistsEq ([psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 La &hellip; b.1]) eq =
    <a href="#existsEq">existsEq</a> (<a href="#Cons_xa">Cons_xa</a> cr_xa) [gamma, x : <a href="#tm">tm</a> &#x22A2 M &hellip; x] <keyword>in</keyword>
    <a href="#ExistsEq">ExistsEq</a> [psi &#x22A2 <a href="#lam">lam</a> (&lambda;x. La &hellip; x)] (<a href="#Eq_l">Eq_l</a> eq);
<br><keyword>rec</keyword> <span class="function" id="det_eqV">det_eqV</span> : <a href="#EqV">EqV</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #p &hellip;] [psi &#x22A2 #q.1 &hellip;] &#x2192 <a href="#EqV">EqV</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #p &hellip;] [psi &#x22A2 #r.1 &hellip;] &#x2192 <a href="#Equal_xaG">Equal_xaG</a> [psi &#x22A2 #q.1 &hellip;] [psi &#x22A2 #r.1 &hellip;] =
<keyword>fn</keyword> v &#x21D2 <keyword>fn</keyword> v' &#x21D2 <keyword>case</keyword> v <keyword>of</keyword> 
  | EqV_v  &#x21D2 <keyword>let</keyword>  EqV_v = v' <keyword>in</keyword> <a href="#Refl_xaG">Refl_xaG</a>
  | EqV_p v  &#x21D2
    <keyword>let</keyword>  EqV_p v' = v' <keyword>in</keyword> <keyword>let</keyword>  Refl_xaG = <a href="#det_eqV">det_eqV</a> v v' <keyword>in</keyword> <a href="#Refl_xaG">Refl_xaG</a>;
<br><keyword>rec</keyword> <span class="function" id="det_eq">det_eq</span> : <a href="#Eq">Eq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 M &hellip;] [psi &#x22A2 N &hellip;] &#x2192 <a href="#Eq">Eq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 M &hellip;] [psi &#x22A2 N' &hellip;] &#x2192 <a href="#Equal_xaG">Equal_xaG</a> [psi &#x22A2 N &hellip;] [psi &#x22A2 N' &hellip;] =
<keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> m' &#x21D2 <keyword>case</keyword> m <keyword>of</keyword> 
  | Eq_v v  &#x21D2 <keyword>let</keyword>  Eq_v v' = m' <keyword>in</keyword> <a href="#det_eqV">det_eqV</a> v v'
  | Eq_a m1 m2  &#x21D2
    <keyword>let</keyword>  Eq_a n1 n2 = m' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG = <a href="#det_eq">det_eq</a> m1 n1 <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG = <a href="#det_eq">det_eq</a> m2 n2 <keyword>in</keyword> <a href="#Refl_xaG">Refl_xaG</a>
  | Eq_l m  &#x21D2
    <keyword>let</keyword>  Eq_l n = m' <keyword>in</keyword> <keyword>let</keyword>  Refl_xaG = <a href="#det_eq">det_eq</a> m n <keyword>in</keyword> <a href="#Refl_xaG">Refl_xaG</a>;
<br><keyword>rec</keyword> <span class="function" id="det_eqV'">det_eqV'</span> : <a href="#EqV'">EqV'</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #q &hellip;] [psi &#x22A2 #p.1 &hellip;] &#x2192 <a href="#EqV'">EqV'</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #r &hellip;] [psi &#x22A2 #p.1 &hellip;] &#x2192 <a href="#Equal_xG">Equal_xG</a> [gamma &#x22A2 #q &hellip;] [gamma &#x22A2 #r &hellip;] =
<keyword>fn</keyword> v &#x21D2 <keyword>fn</keyword> v' &#x21D2 <keyword>case</keyword> v <keyword>of</keyword> 
  | EqV'_v  &#x21D2 <keyword>let</keyword>  EqV'_v = v' <keyword>in</keyword> <a href="#Refl_xG">Refl_xG</a>
  | EqV'_p v  &#x21D2
    <keyword>let</keyword>  EqV'_p v' = v' <keyword>in</keyword> <keyword>let</keyword>  Refl_xG = <a href="#det_eqV'">det_eqV'</a> v v' <keyword>in</keyword> <a href="#Refl_xG">Refl_xG</a>;
<br><keyword>rec</keyword> <span class="function" id="det_eq'">det_eq'</span> : <a href="#Eq'">Eq'</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 M &hellip;] [psi &#x22A2 N &hellip;] &#x2192 <a href="#Eq'">Eq'</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 M' &hellip;] [psi &#x22A2 N &hellip;] &#x2192 <a href="#Equal_xG">Equal_xG</a> [gamma &#x22A2 M &hellip;] [gamma &#x22A2 M' &hellip;] =
<keyword>fn</keyword> m &#x21D2 <keyword>fn</keyword> m' &#x21D2 <keyword>case</keyword> m <keyword>of</keyword> 
  | Eq'_v v  &#x21D2 <keyword>let</keyword>  Eq'_v v' = m' <keyword>in</keyword> <a href="#det_eqV'">det_eqV'</a> v v'
  | Eq'_a m1 m2  &#x21D2
    <keyword>let</keyword>  Eq'_a n1 n2 = m' <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xG = <a href="#det_eq'">det_eq'</a> m1 n1 <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xG = <a href="#det_eq'">det_eq'</a> m2 n2 <keyword>in</keyword> <a href="#Refl_xG">Refl_xG</a>
  | Eq'_l m  &#x21D2
    <keyword>let</keyword>  Eq'_l n = m' <keyword>in</keyword> <keyword>let</keyword>  Refl_xG = <a href="#det_eq'">det_eq'</a> m n <keyword>in</keyword> <a href="#Refl_xG">Refl_xG</a>;
<br><keyword>rec</keyword> <span class="function" id="ceq">ceq</span> : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] &#x2192 <a href="#Ctx_xdR">Ctx_xdR</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] &#x2192 <a href="#Ctx_adR">Ctx_adR</a> [psi] [phi] &#x2192 <a href="#Eq">Eq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 M &hellip;] [psi &#x22A2 Ma &hellip;] &#x2192 <a href="#Eq">Eq</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 N &hellip;] [psi &#x22A2 Na &hellip;] &#x2192 <a href="#Eq'">Eq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [gamma &#x22A2 M &hellip;] [phi &#x22A2 Md &hellip;] &#x2192 <a href="#Eq'">Eq'</a> [gamma] [phi] [phi &#x22A2  #T[&hellip;]] [gamma &#x22A2 N &hellip;] [phi &#x22A2 Nd &hellip;] &#x2192 [phi &#x22A2 <a href="#deq">deq</a> (Md &hellip;) (Nd &hellip;)] &#x2192 [psi &#x22A2 <a href="#aeq">aeq</a> (Ma &hellip;) (Na &hellip;)] =
<keyword>fn</keyword> cr_a &#x21D2 <keyword>fn</keyword> cr_d &#x21D2 <keyword>fn</keyword> cr_da &#x21D2 <keyword>fn</keyword> ma &#x21D2 <keyword>fn</keyword> na &#x21D2 <keyword>fn</keyword> md &#x21D2 <keyword>fn</keyword> nd &#x21D2 <keyword>fn</keyword> d &#x21D2 
  <keyword>let</keyword>  (cr_da : <a href="#Ctx_adR">Ctx_adR</a> [psi] [phi])= cr_da <keyword>in</keyword>
  <keyword>let</keyword>  (cr_a : <a href="#Ctx_xaR">Ctx_xaR</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]])= cr_a <keyword>in</keyword> <keyword>case</keyword> d <keyword>of</keyword> 
  | [phi &#x22A2 #p.2 &hellip;] &#x21D2
    <keyword>let</keyword>  Refl_xG = <a href="#det_eq'">det_eq'</a> md nd <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG = <a href="#det_eq">det_eq</a> ma na <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_v v' = md <keyword>in</keyword>
    <keyword>let</keyword>  Eq_v v = ma <keyword>in</keyword>
    <keyword>let</keyword>  (v : <a href="#EqV">EqV</a> [gamma] [psi] [psi &#x22A2  #S[&hellip;]] [gamma &#x22A2 #r &hellip;] [psi &#x22A2 #q.1 &hellip;])= v <keyword>in</keyword>
    <a href="#ctx_member">ctx_member</a> [gamma &#x22A2 #r &hellip;] cr_a v
  | [phi &#x22A2 <a href="#de_r">de_r</a>] &#x21D2
    <keyword>let</keyword>  Refl_xG = <a href="#det_eq'">det_eq'</a> md nd <keyword>in</keyword>
    <keyword>let</keyword>  Refl_xaG = <a href="#det_eq">det_eq</a> ma na <keyword>in</keyword> <a href="#reflR">reflR</a> [gamma] [gamma &#x22A2 _] cr_a ma
  | [phi &#x22A2 <a href="#de_t">de_t</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  ([phi &#x22A2 D1 &hellip;] : [phi &#x22A2 <a href="#deq">deq</a> (Md &hellip;) (Ld &hellip;)])= [phi &#x22A2 D1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  ([phi &#x22A2 D2 &hellip;] : [phi &#x22A2 <a href="#deq">deq</a> (Ld &hellip;) (Nd &hellip;)])= [phi &#x22A2 D2 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq' ([gamma &#x22A2 L &hellip;]) ld = <a href="#existsEq'">existsEq'</a> cr_d [phi &#x22A2 Ld &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  ExistsEq ([psi &#x22A2 La &hellip;]) la = <a href="#existsEq">existsEq</a> cr_a [gamma &#x22A2 L &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E1 &hellip;] = <a href="#ceq">ceq</a> cr_a cr_d cr_da ma la md ld [phi &#x22A2 D1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E2 &hellip;] = <a href="#ceq">ceq</a> cr_a cr_d cr_da la na ld nd [phi &#x22A2 D2 &hellip;] <keyword>in</keyword>
    <a href="#transR">transR</a> cr_a ma la na [psi &#x22A2 E1 &hellip;] [psi &#x22A2 E2 &hellip;]
  | [phi &#x22A2 <a href="#de_a">de_a</a> (D1 &hellip;) (D2 &hellip;)] &#x21D2
    <keyword>let</keyword>  Eq_a ma1 ma2 = ma <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_a md1 md2 = md <keyword>in</keyword>
    <keyword>let</keyword>  Eq_a na1 na2 = na <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_a nd1 nd2 = nd <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E1 &hellip;] = <a href="#ceq">ceq</a> cr_a cr_d cr_da ma1 na1 md1 nd1 [phi &#x22A2 D1 &hellip;] <keyword>in</keyword>
    <keyword>let</keyword>  [psi &#x22A2 E2 &hellip;] = <a href="#ceq">ceq</a> cr_a cr_d cr_da ma2 na2 md2 nd2 [phi &#x22A2 D2 &hellip;] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_a">ae_a</a> (E1 &hellip;) (E2 &hellip;)]
  | [phi &#x22A2 <a href="#de_l">de_l</a> (&lambda;x. &lambda;u. D &hellip; x u)] &#x21D2
    <keyword>let</keyword>  Eq_l ma1 = ma <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_l md1 = md <keyword>in</keyword>
    <keyword>let</keyword>  Eq_l na1 = na <keyword>in</keyword>
    <keyword>let</keyword>  Eq'_l nd1 = nd <keyword>in</keyword>
    <keyword>let</keyword>  [psi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#aeq">aeq</a> x x) &#x22A2 E &hellip; b.1 b.2] =
    <a href="#ceq">ceq</a> (<a href="#Cons_xa">Cons_xa</a> cr_a) (<a href="#Cons_xd">Cons_xd</a> cr_d) (<a href="#Cons_ad">Cons_ad</a> cr_da) ma1 na1 md1 nd1 [phi, b : <keyword>block</keyword> (x:<a href="#tm">tm</a>, u:<a href="#deq">deq</a> x x) &#x22A2 D &hellip; b.1 b.2] <keyword>in</keyword>
    [psi &#x22A2 <a href="#ae_l">ae_l</a> (&lambda;x. &lambda;u. E &hellip; x u)];
</code></pre><br><br><h3>To download the code: <a href="Inductive_Datatypes.bel" target="_blank">Inductive_Datatypes.bel</a></h3>

</body>
</html>
