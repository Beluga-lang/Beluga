% Beluga Development with explicit context relations
% Author: Brigitte Pientka
%{ Content:

   - Definition for aeq
   - Definition for deq
   - Meta-theoretic properties: (Solved with generalized context)
      o Admissibility of Reflexivity
      o Admissibility of Transitivity
      o Admissibility of Symmertry
      o Soundness
      o Completeness
}%

term : type.
app : term -> term -> term.
lam : (term -> term) -> term.
%name term M x.

% Algorithmic Equality
aeq: term -> term -> type.   %name aeq Q u.
ae_a : aeq M1 N1 -> aeq M2 N2
    -> aeq (app M1 M2) (app N1 N2).
ae_l :  ({x:term} aeq x x -> aeq (M x) (N x))
        -> aeq (lam (\x. M x)) (lam (\x. N x)).

% Declarative Equality
deq: term -> term -> type.
de_l: ({x:term} deq x x -> deq (M x) (M' x))
     -> deq (lam (\x. M x)) (lam (\x. M' x)).
de_a: deq M1 N1 -> deq M2 N2
     -> deq (app M1 M2) (app N1 N2).
de_r: deq M M.
de_t: deq M L -> deq L N
     -> deq M N.

% Context declarations
schema tCtx = term;
schema taCtx = block x:term, _t:aeq x x;
schema tdCtx =  block x:term,  _t:deq x x ;

%----------------------------------------------------------
% Context relations

inductive Crel : {g:tCtx} {h:taCtx} ctype =
| Crel_e : Crel [ ] []
| Crel_xa: Crel [g] [h] -> Crel [g, x:term] [h, b: block (x:term, u:aeq x x)]
;

% Relation of terms in tCtx context to terms in taCtx context
% TRel [g |- M[..]] [h |- N[..]]
% This relation allows for a dual reading:
% 1) When given [g |- M[..]] then we can always weaken it to obtain [h |- N[..]]
% 2) When given [h |- N[..]] we can always strengthen it to obtain [g |- M[..]]

inductive TRel : (g:tCtx) (h:taCtx) [g |- term] -> [h |- term] -> ctype #stratified =
| TRvar0 : {h: taCtx} Crel [g] [h] ->
            TRel [g, x:term |-  x]
 		 [h, b:block (x:term, u:aeq x x) |- b.1]
| TRvar  : TRel  [g |- #p[..]] [h |- #q.1[..]]
         -> TRel [g, x:term |-  #p[..]]
                [h, b:block (x:term, u:aeq x x) |-  #q.1[..]]

| TRapp  : TRel [g |- M[..]] [h |- M'] -> TRel [g |- N[..]] [h |- N'[..]]
        -> TRel [g |- app (M[..]) (N[..])] [h |- app M' N']

| TRlam  : TRel [g, x:term |-  M] [h, b:block (x:term, _u:aeq x x) |-  N[.. b.1]]
	   -> TRel [g |- lam \x. M] [h |- lam \x. N]
;
 
