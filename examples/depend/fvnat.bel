tp: type.
nat: tp.
bool: tp.

exp : tp -> type.
z   : exp nat.
suc : exp nat -> exp nat.
and : exp bool -> exp bool -> exp bool.
tt  : exp bool.
ff  : exp bool.

opt: type.
NONE: opt.
SOME: {T:tp} exp T -> opt.

schema w = some [T:tp] block exp T;

rec FVnat : {g:(w)*} {T::tp[.]} (exp T![.]!)[g] -> (opt)[g] =
FN g => mlam T => fn e => 
 (case e of
    box(g . z)            : (exp nat)[g]   => box(g . NONE)
  | box(g . tt)           : (exp bool)[g]  => box(g . NONE)
  | box(g . ff)           : (exp bool)[g]  => box(g . NONE)

  | {T'::tp[.]} {#p::(exp T'![.]!)[g]}
     box(g . #p![id]!)     : (exp T'![.]!)[g] => box(g . SOME T'![.]! #p![id]!)

  | {U::(exp nat)[g]}
    box(g . suc U![id]!) : (exp nat)[g]   => FVnat [g] < . nat >  (box(g . U![id]!))

  | {U::(exp bool)[g]} {V::(exp bool)[g]}
     box(g . and U![id]! V![id]!) : (exp bool)[g]  => 
       (case FVnat [g] < . bool > (box(g . U![id]!)) of
          box(g . NONE)                : opt[g] => FVnat [g] < . bool > (box(g . V![id]!))

       | {T'::tp[.]} {#p::(exp T'![.]!)[g]}
          box(g . SOME T'![.]! #p![id]!) : opt[g] => box(g . SOME T'![.]! #p![id]!))
);
