/* Tutorial example by Marie-Andree B.Langlois */

terminals z suc lambda app
syntax 

/* The example illustrates the usual expressions one would want to declare using thiskind of system.*/
/* This type is called exp, the two first alternatives are simply the naturals. */
exp ::= z
| suc exp

/* x, must be declared as an alternative, this way the reconstruction will know that every x is a variable. All variable must be declared seperately, the translater recongnizes them for being alternatives of length one, that are not terminals. The following alternative declares a lambda term, the \ is mandatory for the parser to understand that it's a lambda term. The "." indicates that there is a binding comming. One of the Sasybel conventions is that``e[x]''
denotes that the variable x is bound in the expression e.*/
| x
| lambda \x .exp[x] 

/* The next alternative is simply the application of an expression, a fucntion (lambda expression) to another expression. Then there is the declaration of a let statement, the keywords/symbol let, = and in are mandatory. Then when have an expression that will equal the variable x in an expression bound in x. Note that the traslation to beluga will dislay the word letv instead of let, because let is reserved in Beluga. */
| app exp exp 
| let exp = x in exp[x] ;

/* The following judgment simply specifies what is considered a value. */
judgment value : exp value ;

--------------- val-z
z value ;

e1 value ;
--------------- val-s
(suc e1) value ;

------------------------------ val-lam
(lambda \x . e1[x]) value ;

/* inference rules about evaluation. */
judgment eval : exp eval exp;

--------------- ev-z
z eval z;

e1 eval e2;
------------------------- ev-s
(suc e1) eval (suc e2);

----------------------------------------- ev-lam
(lambda \x .e1[x]) eval (lambda \x .e1[x]);

e1 eval (lambda \x .e[x]);
e2 eval e2';
e[e2'] eval e1';
----------------------------------------- ev-app
(app e1 e2) eval e1';
/*
(e2[e1]) eval v1;
e1 eval v1;
------------------------------------------- ev-let
(let e1 = x in e2[x]) eval v1;
*/

/* This is the proof of value soundness that indicates that every expression evaluates to a value that is an expression. *//*
theorem val-sound : forall d: e eval e' exists e' value .

d1 : e' value by induction on d:

case rule

	--------------- ev-z
	a1: z eval z;

	is

	a2: e' value by rule val-z

end case

case rule 

	a3: e1 eval e2;
	---------------------------- ev-s
	a4: (suc e1) eval (suc e2);

	is

	b8: e2 value by induction hypothesis on a3
	a5: e' value by rule val-s on b8

end case

case rule 

	a6: e2[e1] eval e1';
	a7: e1 eval e1';
	----------------------------------------------- ev-let
	a8: (let x=e1 in e2[x]) eval e1';

	is

	a9: e' value by induction hypothesis on a6

end case

case rule 

	-------------------------------------------------------- ev-lam
	b1: (lambda \x . e1[x]) eval (lambda \x . e1[x]);

	is

	b2: e' value by rule val-lam

end case

case rule 

	b3: e1 eval lambda \x . e3[x];
	b4: e2 eval e2';
	b5: e3[e2'] eval e1';
	------------------------------------- ev-app
	b6: (e1 e2) eval e1';

	is

	b7: e' value by induction hypothesis on b5

end case
end induction 
end theorem*/
