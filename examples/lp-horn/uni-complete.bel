%%% Completeness of uniform proofs with respect to canonical deductions
%%% Author: Frank Pfenning
%%% Adapted: Brigitte Pientka

schema c_ctx = some [a:o] block u: assume a, v:pf a , _t:atm v ;

rec cmpcs: {g:c_ctx}[g. can (A ..) (D ..) ] -> [g. solve (A ..) ] =
mlam g => fn cn => case cn of
|[g. can_andi (CN2 ..) (CN1 ..)] =>
   let [g. S1..] = cmpcs [g] [g. CN1 ..] in
   let [g. S2..] = cmpcs [g] [g. CN2 ..] in
     [g. s_and (S2 ..) (S1 ..)]

|[g. can_truei] => [g. s_true]

| [g. can_atm (AT1 ..)] =>
  let [g,q:p,u:focus (A ..) q. I1 .. q u] = cmpai [g] [g . _ ] [g. AT1 .. ] in
    [g. I1 .. _ (i_atom)]

%{ % This case is only not necessary for the Horn fragment
  | {CN1::(can (B ..) (D .. u))[g,u:pf (A ..), v:atm u]}
  [g] can_impi (\u.\a. CN1 .. u a) =>
  let {S1::(solve (A1 ..))[g,v:assume (A2 ..)]}
      [g, b: block u:assume (A2 ..),v:pf (A2 ..) . atm v] S1 .. b.1 =
      cmpcs [g, b:block u:assume (A..) ,v:pf (A..) . atm v] ([g,b] CN1 .. b.2 b.3)
  in
     [g] s_imp (\v. S1 .. v )
}%

and cmpai: {g:c_ctx}{E:[g. pf (B ..)]}[g. atm (E ..)] ->
	       [g, q:p, u:focus (B ..) q . solve (atom q)] =
mlam g => mlam D => fn at => case [g. D .. ] of
  | [g. #p.2 ..] => [g,q,u. s_atom u (#p.1 ..)]
  | [g. andel (D1 .. )] =>
    let [g. atm_andel (CN1 .. )] = at in
    let [g,q:p, i: focus (& (B1 ..) (B2 ..))  q. I1 .. q i] = cmpai [g] [g . D1 .. ] [g. CN1 ..] in
      [g,q,i. I1 .. q (i_andl i)]

  | [g. ander (D1 .. )] =>
    let [g. atm_ander (CN1 .. )] = at in
    let [g,q:p, i: focus (& (B1 ..) (B2 ..))  q. I1 .. q i] = cmpai [g] [g . D1 .. ] [g. CN1 ..] in
      [g,q,i. I1 .. q (i_andr i)]

  | [g. impe (D1 ..) (D2 ..)] =>
    let [g. atm_impe (CN2 ..) (AT1 ..)] = at in
    let [g,q:p, u:focus (A ..) q. I1 .. q u] = cmpai [g] [g. D1 .. ] [g. AT1 ..] in
    let [g. S2 ..] = cmpcs [g] [g. CN2 ..] in
      [g,q,i. I1 .. q (i_imp (S2 ..) i )]

  | [g. foralle (D1 ..) T] =>
    let [g. atm_foralle (AT1 ..)] = at in
    let [g,q:p, i: focus (A ..) q. I1 .. q i] = cmpai [g] [g.D1 .. ] [g. AT1 ..] in
      [g,q,i. I1 .. q (i_forall T i)]

;
