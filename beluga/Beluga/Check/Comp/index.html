<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Comp (beluga.Beluga.Check.Comp)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">beluga</a> &#x00BB; <a href="../../index.html">Beluga</a> &#x00BB; <a href="../index.html">Check</a> &#x00BB; Comp</nav><header class="odoc-preamble"><h1>Module <code><span>Check.Comp</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-typeVariant"><a href="#type-typeVariant" class="anchor"></a><code><span><span class="keyword">type</span> typeVariant</span><span> = </span></code><ol><li id="type-typeVariant.VariantCross" class="def variant constructor anchored"><a href="#type-typeVariant.VariantCross" class="anchor"></a><code><span>| </span><span><span class="constructor">VariantCross</span></span></code></li><li id="type-typeVariant.VariantArrow" class="def variant constructor anchored"><a href="#type-typeVariant.VariantArrow" class="anchor"></a><code><span>| </span><span><span class="constructor">VariantArrow</span></span></code></li><li id="type-typeVariant.VariantCtxPi" class="def variant constructor anchored"><a href="#type-typeVariant.VariantCtxPi" class="anchor"></a><code><span>| </span><span><span class="constructor">VariantCtxPi</span></span></code></li><li id="type-typeVariant.VariantPiBox" class="def variant constructor anchored"><a href="#type-typeVariant.VariantPiBox" class="anchor"></a><code><span>| </span><span><span class="constructor">VariantPiBox</span></span></code></li><li id="type-typeVariant.VariantBox" class="def variant constructor anchored"><a href="#type-typeVariant.VariantBox" class="anchor"></a><code><span>| </span><span><span class="constructor">VariantBox</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mismatch_kind"><a href="#type-mismatch_kind" class="anchor"></a><code><span><span class="keyword">type</span> mismatch_kind</span><span> = </span><span>[ </span></code><ol><li id="type-mismatch_kind.fn" class="def variant constructor anchored"><a href="#type-mismatch_kind.fn" class="anchor"></a><code><span>| </span><span>`fn</span></code></li><li id="type-mismatch_kind.mlam" class="def variant constructor anchored"><a href="#type-mismatch_kind.mlam" class="anchor"></a><code><span>| </span><span>`mlam</span></code></li><li id="type-mismatch_kind.box" class="def variant constructor anchored"><a href="#type-mismatch_kind.box" class="anchor"></a><code><span>| </span><span>`box</span></code></li><li id="type-mismatch_kind.ctxfun" class="def variant constructor anchored"><a href="#type-mismatch_kind.ctxfun" class="anchor"></a><code><span>| </span><span>`ctxfun</span></code></li><li id="type-mismatch_kind.tuple" class="def variant constructor anchored"><a href="#type-mismatch_kind.tuple" class="anchor"></a><code><span>| </span><span>`tuple</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span></code><ol><li id="type-error.IllegalParamTyp" class="def variant constructor anchored"><a href="#type-error.IllegalParamTyp" class="anchor"></a><code><span>| </span><span><span class="constructor">IllegalParamTyp</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a>
  * <a href="../../../Synint/LF/index.html#type-typ">Beluga_syntax.Synint.LF.typ</a></span></code></li><li id="type-error.MismatchChk" class="def variant constructor anchored"><a href="#type-error.MismatchChk" class="anchor"></a><code><span>| </span><span><span class="constructor">MismatchChk</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></li><li id="type-error.MismatchSyn" class="def variant constructor anchored"><a href="#type-error.MismatchSyn" class="anchor"></a><code><span>| </span><span><span class="constructor">MismatchSyn</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a>
  * <a href="#type-typeVariant">typeVariant</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></li><li id="type-error.PatIllTyped" class="def variant constructor anchored"><a href="#type-error.PatIllTyped" class="anchor"></a><code><span>| </span><span><span class="constructor">PatIllTyped</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/Comp/index.html#type-pattern">Beluga_syntax.Synint.Comp.pattern</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></li><li id="type-error.BasicMismatch" class="def variant constructor anchored"><a href="#type-error.BasicMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">BasicMismatch</span> <span class="keyword">of</span> <a href="#type-mismatch_kind">mismatch_kind</a>
  * <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></li><li id="type-error.SBoxMismatch" class="def variant constructor anchored"><a href="#type-error.SBoxMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">SBoxMismatch</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a>
  * <a href="../../../Synint/LF/index.html#type-dctx">Beluga_syntax.Synint.LF.dctx</a></span></code></li><li id="type-error.SynMismatch" class="def variant constructor anchored"><a href="#type-error.SynMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">SynMismatch</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></li><li id="type-error.TypMismatch" class="def variant constructor anchored"><a href="#type-error.TypMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">TypMismatch</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a>
  * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></li><li id="type-error.UnsolvableConstraints" class="def variant constructor anchored"><a href="#type-error.UnsolvableConstraints" class="anchor"></a><code><span>| </span><span><span class="constructor">UnsolvableConstraints</span> <span class="keyword">of</span> <span><a href="../../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> option</span> * string</span></code></li><li id="type-error.InvalidRecCall" class="def variant constructor anchored"><a href="#type-error.InvalidRecCall" class="anchor"></a><code><span>| </span><span><span class="constructor">InvalidRecCall</span></span></code></li><li id="type-error.NotRecursiveSrc" class="def variant constructor anchored"><a href="#type-error.NotRecursiveSrc" class="anchor"></a><code><span>| </span><span><span class="constructor">NotRecursiveSrc</span> <span class="keyword">of</span> <a href="../../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a></span></code></li><li id="type-error.NotRecursiveDst" class="def variant constructor anchored"><a href="#type-error.NotRecursiveDst" class="anchor"></a><code><span>| </span><span><span class="constructor">NotRecursiveDst</span> <span class="keyword">of</span> <a href="../../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a></span></code></li><li id="type-error.MissingTotal" class="def variant constructor anchored"><a href="#type-error.MissingTotal" class="anchor"></a><code><span>| </span><span><span class="constructor">MissingTotal</span> <span class="keyword">of</span> <a href="../../../Syncom/Id/index.html#type-cid_prog">Beluga_syntax.Id.cid_prog</a></span></code></li><li id="type-error.NotImpossible" class="def variant constructor anchored"><a href="#type-error.NotImpossible" class="anchor"></a><code><span>| </span><span><span class="constructor">NotImpossible</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>
  * <a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a></span></code></li><li id="type-error.InvalidHypotheses" class="def variant constructor anchored"><a href="#type-error.InvalidHypotheses" class="anchor"></a><code><span>| </span><span><span class="constructor">InvalidHypotheses</span> <span class="keyword">of</span> <a href="../../../Synint/Comp/index.html#type-hypotheses">Beluga_syntax.Synint.Comp.hypotheses</a>
  * <a href="../../../Synint/Comp/index.html#type-hypotheses">Beluga_syntax.Synint.Comp.hypotheses</a></span></code></li><li id="type-error.SufficesDecompositionFailed" class="def variant constructor anchored"><a href="#type-error.SufficesDecompositionFailed" class="anchor"></a><code><span>| </span><span><span class="constructor">SufficesDecompositionFailed</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></li><li id="type-error.SufficesLengthsMismatch" class="def variant constructor anchored"><a href="#type-error.SufficesLengthsMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">SufficesLengthsMismatch</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>
  * int
  * int</span></code></li><li id="type-error.SufficesBadAnnotation" class="def variant constructor anchored"><a href="#type-error.SufficesBadAnnotation" class="anchor"></a><code><span>| </span><span><span class="constructor">SufficesBadAnnotation</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>
  * int
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></li><li id="type-error.SufficesBadGoal" class="def variant constructor anchored"><a href="#type-error.SufficesBadGoal" class="anchor"></a><code><span>| </span><span><span class="constructor">SufficesBadGoal</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a></span></code></li><li id="type-error.SufficesPremiseNotClosed" class="def variant constructor anchored"><a href="#type-error.SufficesPremiseNotClosed" class="anchor"></a><code><span>| </span><span><span class="constructor">SufficesPremiseNotClosed</span> <span class="keyword">of</span> <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * int
  * <a href="../../../Synint/Comp/index.html#type-suffices_typ">Beluga_syntax.Synint.Comp.suffices_typ</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> <a href="../../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="#type-error">error</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-throw"><a href="#val-throw" class="anchor"></a><code><span><span class="keyword">val</span> throw : <span><a href="../../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-error">error</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Raises an error from this module.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append_hypotheses"><a href="#val-append_hypotheses" class="anchor"></a><code><span><span class="keyword">val</span> append_hypotheses : 
  <span><a href="../../../Synint/Comp/index.html#type-hypotheses">Beluga_syntax.Synint.Comp.hypotheses</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-hypotheses">Beluga_syntax.Synint.Comp.hypotheses</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/Comp/index.html#type-hypotheses">Beluga_syntax.Synint.Comp.hypotheses</a></span></code></div><div class="spec-doc"><p>Appends two sets of hypotheses. Appropriately MShifts the left contexts and applies an appropriate totality shift.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_unbox_modifier"><a href="#val-apply_unbox_modifier" class="anchor"></a><code><span><span class="keyword">val</span> apply_unbox_modifier : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-unbox_modifier">Beluga_syntax.Synint.Comp.unbox_modifier</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Synint.LF.ctyp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Synint.LF.ctyp</a> * <a href="../../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a></span></code></div><div class="spec-doc"><p>Transforms the given contextual type according the an unboxing modifier. The returned substitution witnesses the transformation of the type. It should be applied to the metavariable of the computed type in order for it to make sense in the original context. For example, suppose apply_unbox_modifier cD `Strengthen cU = cU', s If we want X : cU' to make sense in its original LF context, then it suffices to apply X<code>s</code>. This substitution is used by the translation from proofs into programs.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_unbox_modifier_opt"><a href="#val-apply_unbox_modifier_opt" class="anchor"></a><code><span><span class="keyword">val</span> apply_unbox_modifier_opt : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../Synint/Comp/index.html#type-unbox_modifier">Beluga_syntax.Synint.Comp.unbox_modifier</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Synint.LF.ctyp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/LF/index.html#type-ctyp">Beluga_syntax.Synint.LF.ctyp</a> * <a href="../../../Synint/LF/index.html#type-sub">Beluga_syntax.Synint.LF.sub</a></span></code></div><div class="spec-doc"><p>Variant of apply_unbox_modifier that is the identity when no modifier is specified.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-validate_contexts"><a href="#val-validate_contexts" class="anchor"></a><code><span><span class="keyword">val</span> validate_contexts : 
  <span><a href="../../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> * <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a></span></code></div><div class="spec-doc"><p>Verifies that the pairs of contexts are convertible. It is a user error InvalidHypotheses if they are not. If the contexts are convertible, then they are merged, using plicity and type information from the context on the left, but the entry name from the context on the right.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-thm"><a href="#val-thm" class="anchor"></a><code><span><span class="keyword">val</span> thm : 
  <span><span><a href="../../../Syncom/Id/index.html#type-cid_prog">Beluga_syntax.Id.cid_prog</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Synint.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?cIH</span>:<a href="../../../Synint/Comp/index.html#type-ihctx">Beluga_syntax.Synint.Comp.ihctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-thm">Beluga_syntax.Synint.Comp.thm</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Checks a theorem in the given contexts against the given type. The given list of total declarations is used for totality checking. The cid_comp_const parameter is used for registering Harpoon subgoals. For ordinary Beluga programs or for complete Harpoon proofs, this argument can be None.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : 
  <span><span><a href="../../../Syncom/Id/index.html#type-cid_prog">Beluga_syntax.Id.cid_prog</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Synint.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?cIH</span>:<a href="../../../Synint/Comp/index.html#type-ihctx">Beluga_syntax.Synint.Comp.ihctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-syn"><a href="#val-syn" class="anchor"></a><code><span><span class="keyword">val</span> syn : 
  <span><span><a href="../../../Syncom/Id/index.html#type-cid_prog">Beluga_syntax.Id.cid_prog</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../Synint/Comp/index.html#type-total_dec">Beluga_syntax.Synint.Comp.total_dec</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?cIH</span>:<a href="../../../Synint/Comp/index.html#type-ihctx">Beluga_syntax.Synint.Comp.ihctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-ihctx">Beluga_syntax.Synint.Comp.ihctx</a> option</span> * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-checkKind"><a href="#val-checkKind" class="anchor"></a><code><span><span class="keyword">val</span> checkKind : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-kind">Beluga_syntax.Synint.Comp.kind</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-checkTyp"><a href="#val-checkTyp" class="anchor"></a><code><span><span class="keyword">val</span> checkTyp : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wf_mctx"><a href="#val-wf_mctx" class="anchor"></a><code><span><span class="keyword">val</span> wf_mctx : <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mvars_in_patt"><a href="#val-mvars_in_patt" class="anchor"></a><code><span><span class="keyword">val</span> mvars_in_patt : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-pattern">Beluga_syntax.Synint.Comp.pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a></span></code></div><div class="spec-doc"><p>Transforms the given meta-context by marking all meta-variables appearing in the pattern as Inductive.</p><p>This function relies on numerous (non-exported; 87 lines total) helpers to traverse the syntax tree. I believe that there is an opportunity to refactor this and move it to a different module. -je</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fixParamTyp"><a href="#val-fixParamTyp" class="anchor"></a><code><span><span class="keyword">val</span> fixParamTyp : 
  <span><a href="../../../Synint/LF/index.html#type-mfront">Beluga_syntax.Synint.LF.mfront</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-meta_typ">Beluga_syntax.Synint.Comp.meta_typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int option</span> * <a href="../../../Synint/Comp/index.html#type-meta_typ">Beluga_syntax.Synint.Comp.meta_typ</a> * <span>int option</span></span></code></div><div class="spec-doc"><p>Analyzes a contextual object to decide whether it's a (contextual) variable and rewrites its type from MTyp to PTyp if necessary. This is crucial for coverage checking of a case analysis on a parameter variable. Also returns the index of the variable (so we can later decide if it's a variable we're doing induction on) as well what projection, if any, is applied to the parameter variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-id_map_ind"><a href="#val-id_map_ind" class="anchor"></a><code><span><span class="keyword">val</span> id_map_ind : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a></span></code></div><div class="spec-doc"><p>Transfers inductivity annotations from a source context to a target context related by a meta-substitution.</p><p>id_map_ind cD' t cD = cD'* where cD' |- t : cD</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unroll"><a href="#val-unroll" class="anchor"></a><code><span><span class="keyword">val</span> unroll : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-ihctx">Beluga_syntax.Synint.Comp.ihctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a>
  * <a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a>
  * <a href="../../../Synint/Comp/index.html#type-ihctx">Beluga_syntax.Synint.Comp.ihctx</a>
  * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>
  * <a href="../../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a></span></code></div><div class="spec-doc"><p>unroll cD cG cIH tau = (cD', cG', cIH', tau', t) where cD |- cG &lt;= ctx and cD |- tau &lt;= type s.t. cD' extends cD and cG' extends cG and tau' is a subterm of tau and tau' is not an arrow nor a PiBox type and cD' |- t : cD is a weakening meta-substitution. and cD' |- cIH' ihctx and cIH' is appropriately shifted</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-require_syn_typbox"><a href="#val-require_syn_typbox" class="anchor"></a><code><span><span class="keyword">val</span> require_syn_typbox : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Synint.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../Synint/Comp/index.html#type-meta_typ">Beluga_syntax.Synint.Comp.meta_typ</a> * <a href="../../../Synint/LF/index.html#type-msub">Beluga_syntax.Synint.LF.msub</a></span></code></div><div class="spec-doc"><p>Requires that the given type be a box-type. require_syn_typbox cD cG loc i (tau, t) = (cU, t) if tau = <code>cU</code>; else, raises a synthesis mismatch error for the expression i saying that the type of i is expected to be a box-type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decompose_function_type"><a href="#val-decompose_function_type" class="anchor"></a><code><span><span class="keyword">val</span> decompose_function_type : 
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> list</span> * <a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a>)</span> option</span></span></code></div><div class="spec-doc"><p>Processes all leading PiBoxes to replace them with unification variables in the following type, and returns a further decomposition of the type remaining after all these PiBoxes, which must consist only of simple function types (or a base type).</p><p>Given cD |- tau &lt;= type and tau = Pi X_1:U_1. ... Pi X_n:U_n. tau' and tau' = tau_1 -&gt; tau_2 -&gt; ... -&gt; tau_k (so cD, X_1:U_1, ..., X_n:U_n |- tau' &lt;= type) `decompose_function_type cD tau` calculates an msub t such that cD |- t : cD, X_1:U_1, ..., X_n:U_n that replaces each X_i with a fresh unification variable ?X_i. The msub t is applied to tau' and tau' is further decomposed into a list l = <code>[t]tau_1; [t]tau_2; ...; [t]tau_(k-1)</code>. This list is returned together with the type <code>t</code>tau_k. If the decomposition fails due to an interleaving of PiBox-types and arrow-types, None is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unify_suffices"><a href="#val-unify_suffices" class="anchor"></a><code><span><span class="keyword">val</span> unify_suffices : 
  <span><a href="../../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../Synint/Comp/index.html#type-suffices_typ">Beluga_syntax.Synint.Comp.suffices_typ</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/Comp/index.html#type-typ">Beluga_syntax.Synint.Comp.typ</a> list</span></span></code></div><div class="spec-doc"><p>Checks that the given type annotations are compatible with a given function type.</p><p>unify_suffices cD tau_i tau_anns tau_g requires 1. cD |- tau_i &lt;= type 2. for each stau in tau_anns, if stau = `exact tau, then cD |- tau &lt;= type (for each type in the list) 3. cD |- tau_g &lt;= type It decomposes the function type tau_i (see decompose_function_type) and appropriately unifies the decomposition with the given type annotations so as to pin down all instantiations of universally quantified variables. Some type annotations may be omitted. The interpretation of an omitted annotation is that that annotation is not necessary (the type of that argument is already determined by unification of the goal, or other annotations).</p><p>Returns the list of elaborated premise types, which are guaranteed to be closed (no MMVars).</p><p>The provided location is used when raising errors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genMApp"><a href="#val-genMApp" class="anchor"></a><code><span><span class="keyword">val</span> genMApp : 
  <span><a href="../../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../../Synint/LF/index.html#type-ctyp_decl">Beluga_syntax.Synint.LF.ctyp_decl</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../Synint/LF/index.html#type-mctx">Beluga_syntax.Synint.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  int * <span>(<a href="../../../Synint/Comp/index.html#type-exp">Beluga_syntax.Synint.Comp.exp</a> * <a href="../../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Synint.Comp.tclo</a>)</span></span></code></div><div class="spec-doc"><p>Generates a meta-application spine consisting of unification variables to eliminate leading PiBox types. Returns the number of generated unification variables as well as the type (together with a delayed meta-substitution) of the produced expression.</p></div></div></div></body></html>
