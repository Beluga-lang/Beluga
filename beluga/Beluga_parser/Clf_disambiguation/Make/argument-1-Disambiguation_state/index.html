<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Disambiguation_state (beluga.Beluga_parser.Clf_disambiguation.Make.Disambiguation_state)</title><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">beluga</a> &#x00BB; <a href="../../../index.html">Beluga_parser</a> &#x00BB; <a href="../../index.html">Clf_disambiguation</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; Disambiguation_state</nav><header class="odoc-preamble"><h1>Parameter <code><span>Make.Disambiguation_state</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#variables">Variables</a></li><li><a href="#constants">Constants</a></li><li><a href="#lookups">Lookups</a></li><li><a href="#signature-operations">Signature Operations</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><details><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../../Support/Imperative_state/module-type-IMPERATIVE_STATE/index.html">Support.Imperative_state.IMPERATIVE_STATE</a></span></code></summary><div class="odoc-spec"><div class="spec type anchored" id="type-state"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_tuple2"><a href="#val-traverse_tuple2" class="anchor"></a><code><span><span class="keyword">val</span> traverse_tuple2 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a1</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b1</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a2</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b2</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a1</span> * <span class="type-var">'a2</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b1</span> * <span class="type-var">'b2</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_tuple3"><a href="#val-traverse_tuple3" class="anchor"></a><code><span><span class="keyword">val</span> traverse_tuple3 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a1</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b1</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a2</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b2</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a3</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b3</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a1</span> * <span class="type-var">'a2</span> * <span class="type-var">'a3</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b1</span> * <span class="type-var">'b2</span> * <span class="type-var">'b3</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_list"><a href="#val-traverse_list" class="anchor"></a><code><span><span class="keyword">val</span> traverse_list : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span></span></code></div><div class="spec-doc"><p><code>traverse_list state f [x1; x2; ...; xn]</code> is <code>[y1; y2; ...; yn]</code> where <code>yi = f state xi</code>, and <code>y1</code>, <code>y2</code>, ..., <code>yn</code> are computed in order, meaning that <code>y1</code> is computed first, then <code>y2</code>, etc.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_list1"><a href="#val-traverse_list1" class="anchor"></a><code><span><span class="keyword">val</span> traverse_list1 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_list2"><a href="#val-traverse_list2" class="anchor"></a><code><span><span class="keyword">val</span> traverse_list2 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List2/index.html#type-t">Support.List2.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/List2/index.html#type-t">Support.List2.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_list"><a href="#val-iter_list" class="anchor"></a><code><span><span class="keyword">val</span> iter_list : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>iter_list state f [x1; x2; ...; xn]</code> is <code>f state x1; f state x2; ...; f state xn</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_list1"><a href="#val-iter_list1" class="anchor"></a><code><span><span class="keyword">val</span> iter_list1 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_list2"><a href="#val-iter_list2" class="anchor"></a><code><span><span class="keyword">val</span> iter_list2 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List2/index.html#type-t">Support.List2.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_reverse_list"><a href="#val-traverse_reverse_list" class="anchor"></a><code><span><span class="keyword">val</span> traverse_reverse_list : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span></span></code></div><div class="spec-doc"><p><code>traverse_reverse_list state f [x1; x2; ...; xn]</code> is <code>[y1; y2; ...; yn]</code> where <code>yi = f state xi</code>, and <code>y1</code>, <code>y2</code>, ..., <code>yn</code> are computed in reverse order, meaning that <code>yn</code> is computed first, then <code>y(n-1)</code>, etc.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_reverse_list1"><a href="#val-traverse_reverse_list1" class="anchor"></a><code><span><span class="keyword">val</span> traverse_reverse_list1 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_reverse_list2"><a href="#val-traverse_reverse_list2" class="anchor"></a><code><span><span class="keyword">val</span> traverse_reverse_list2 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List2/index.html#type-t">Support.List2.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/List2/index.html#type-t">Support.List2.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_rev_list"><a href="#val-iter_rev_list" class="anchor"></a><code><span><span class="keyword">val</span> iter_rev_list : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>iter_rev_list state f [x1; x2; ...; xn]</code> is <code>f state xn; f state x(n-1); ...; f state x1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_rev_list1"><a href="#val-iter_rev_list1" class="anchor"></a><code><span><span class="keyword">val</span> iter_rev_list1 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_rev_list2"><a href="#val-iter_rev_list2" class="anchor"></a><code><span><span class="keyword">val</span> iter_rev_list2 : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/List2/index.html#type-t">Support.List2.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-traverse_option"><a href="#val-traverse_option" class="anchor"></a><code><span><span class="keyword">val</span> traverse_option : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/Option/index.html#type-t">Support.Option.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <a href="../../../../Support/Option/index.html#type-t">Support.Option.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_option"><a href="#val-iter_option" class="anchor"></a><code><span><span class="keyword">val</span> iter_option : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="../../../../Support/Option/index.html#type-t">Support.Option.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_list"><a href="#val-seq_list" class="anchor"></a><code><span><span class="keyword">val</span> seq_list : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-seq_list1"><a href="#val-seq_list1" class="anchor"></a><code><span><span class="keyword">val</span> seq_list1 : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter_seq"><a href="#val-iter_seq" class="anchor"></a><code><span><span class="keyword">val</span> iter_seq : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t)</span> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div></div></details></div><div class="odoc-spec"><div class="spec module anchored" id="module-Entry"><a href="#module-Entry" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Entry/index.html">Entry</a></span><span> : <a href="../../../Disambiguation_state/module-type-ENTRY/index.html">Disambiguation_state.ENTRY</a></span></code></div><div class="spec-doc"><p>Recorded data on bindings in Beluga signatures.</p></div></div><h2 id="variables"><a href="#variables" class="anchor"></a>Variables</h2><div class="odoc-spec"><div class="spec value anchored" id="val-add_lf_variable"><a href="#val-add_lf_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_lf_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_lf_variable state ?location identifier</code> adds <code>identifier</code> as a bound LF variable, with binding site <code>location</code>. If <code>location = Option.None</code>, then <code>identifier</code>'s location is used instead.</p><p>This is mostly used for testing. For locally binding an LF variable, see <a href="#val-with_bound_lf_variable"><code>with_bound_lf_variable</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_meta_variable"><a href="#val-add_meta_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_meta_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_meta_variable</code> is like <a href="#val-add_lf_variable"><code>add_lf_variable</code></a>, but the identifier is added as a bound meta-variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_parameter_variable"><a href="#val-add_parameter_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_parameter_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_parameter_variable</code> is like <a href="#val-add_lf_variable"><code>add_lf_variable</code></a>, but the identifier is added as a bound parameter variable (those variables prefixed by <code>'#'</code> like <code>&quot;#p&quot;</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_substitution_variable"><a href="#val-add_substitution_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_substitution_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_substitution_variable</code> is like <a href="#val-add_lf_variable"><code>add_lf_variable</code></a>, but the identifier is added as a bound substitution variable (those variables prefixed by <code>'$'</code> like <code>&quot;$S&quot;</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_context_variable"><a href="#val-add_context_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_context_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_context_variable</code> is like <a href="#val-add_lf_variable"><code>add_lf_variable</code></a>, but the identifier is added as a bound context variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_contextual_variable"><a href="#val-add_contextual_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_contextual_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_contextual_variable</code> is like <a href="#val-add_lf_variable"><code>add_lf_variable</code></a>, but the identifier is added as a bound contextual variable, meaning that it is ambiguously bound as either a meta, parameter, substitution or context variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_computation_variable"><a href="#val-add_computation_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_computation_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_computation_variable</code> is like <a href="#val-add_lf_variable"><code>add_lf_variable</code></a>, but the identifier is added as a bound computation-level variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_free_lf_variable"><a href="#val-add_free_lf_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_free_lf_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_free_lf_variable state ?location identifier</code> is <code>add_lf_variable state ?location identifier</code>, with the additional behaviour of adding <code>identifier</code> as an inner pattern bound identifier and as a free variable during pattern disambiguation. This means that <code>identifier</code> can subsequently be looked up as a bound LF variable during pattern disambiguation. This effectively allows free LF variables to appear multiple times (non-linearly) in patterns.</p><p>See <a href="#val-with_free_variables_as_pattern_variables"><code>with_free_variables_as_pattern_variables</code></a> for the handler for converting free variables in patterns to binders for use as bound variables in expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_free_meta_variable"><a href="#val-add_free_meta_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_free_meta_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_free_meta_variable</code> is like <a href="#val-add_free_lf_variable"><code>add_free_lf_variable</code></a>, but the identifier is added as a free meta-variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_free_parameter_variable"><a href="#val-add_free_parameter_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_free_parameter_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_free_meta_variable</code> is like <a href="#val-add_free_lf_variable"><code>add_free_lf_variable</code></a>, but the identifier is added as a free parameter variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_free_substitution_variable"><a href="#val-add_free_substitution_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_free_substitution_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_free_meta_variable</code> is like <a href="#val-add_free_lf_variable"><code>add_free_lf_variable</code></a>, but the identifier is added as a free substitution variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_free_context_variable"><a href="#val-add_free_context_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_free_context_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_free_meta_variable</code> is like <a href="#val-add_free_lf_variable"><code>add_free_lf_variable</code></a>, but the identifier is added as a free context variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_free_computation_variable"><a href="#val-add_free_computation_variable" class="anchor"></a><code><span><span class="keyword">val</span> add_free_computation_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_free_computation_variable state ?location identifier</code> adds <code>identifier</code> to <code>state</code> as a free variable during pattern disambiguation. This differs from <a href="#val-add_free_lf_variable"><code>add_free_lf_variable</code></a> in that free computation-level variables in patterns do not have implicit binders (because they are not part of the meta-context), and hence must appear only once (linearly) in the overall pattern.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_lf_variable"><a href="#val-with_bound_lf_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_lf_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_lf_variable state ?location identifier m</code> is the result of running <code>m</code> in the local state derived from <code>state</code> having <code>identifier</code> as a bound LF variable.</p><p>When disambiguating a pattern, <code>identifier</code> is also added as an inner pattern binding.</p><p>For example, the disambiguation of an LF term-level lambda-abstraction <code>\x. m</code> requires that the parameter <code>x</code> is locally added in scope when disambiguating the body <code>m</code>. This is achieved like this:</p><pre class="language-ocaml"><code>with_bound_lf_variable state x (fun state -&gt;
    disambiguate_lf_term state m)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_meta_variable"><a href="#val-with_bound_meta_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_meta_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_meta_variable state ?location identifier m</code> is like <a href="#val-with_bound_lf_variable"><code>with_bound_lf_variable</code></a>, except that <code>identifier</code> is added to the state as a bound meta-variable.</p><p>When disambiguating a pattern, <code>identifier</code> is also added as an inner pattern binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_parameter_variable"><a href="#val-with_bound_parameter_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_parameter_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_substitution_variable"><a href="#val-with_bound_substitution_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_substitution_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_context_variable"><a href="#val-with_bound_context_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_context_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_contextual_variable"><a href="#val-with_bound_contextual_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_contextual_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_contextual_variable state ?location identifier m</code> is like <a href="#val-with_bound_lf_variable"><code>with_bound_lf_variable</code></a>, except that <code>identifier</code> is added to the state as a bound contextual variable. This is different from <a href="#val-with_bound_meta_variable"><code>with_bound_meta_variable</code></a>, <a href="#val-with_bound_parameter_variable"><code>with_bound_parameter_variable</code></a>, <a href="#val-with_bound_substitution_variable"><code>with_bound_substitution_variable</code></a> and <a href="#val-with_bound_context_variable"><code>with_bound_context_variable</code></a> in that it is unknown whether <code>identifier</code> should be a meta-variable, parameter variable, substitution variable or context variable. This is used in particular for <code>mlam</code> expressions.</p><p>When disambiguating a pattern, <code>identifier</code> is also added as an inner pattern binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_computation_variable"><a href="#val-with_bound_computation_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_computation_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_computation_variable state ?location identifier m</code> is like <a href="#val-with_bound_lf_variable"><code>with_bound_lf_variable</code></a>, except that <code>identifier</code> is added to the state as a bound computation-level variable.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_pattern_meta_variable"><a href="#val-with_bound_pattern_meta_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_pattern_meta_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_pattern_meta_variable state ?location identifier m</code> is like <code>with_bound_meta_variable state ?location identifier m</code> except that <code>identifier</code> is also treated as a free variable so that in <a href="#val-with_free_variables_as_pattern_variables"><code>with_free_variables_as_pattern_variables</code></a> it can be treated as a pattern variable usable in the expression.</p><p>This is used for meta-variables introduced in the meta-context of a pattern during case analysis. Those variables are considered bound in both the pattern and expression.</p><p>For example, <code>B</code> as below is one such bound pattern meta-variable, and appears in scope for <code>?</code>.</p><pre class="language-ocaml"><code>case x of
| { B : [g |- o] } [g |- impi \u. D] =&gt; ?</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_pattern_parameter_variable"><a href="#val-with_bound_pattern_parameter_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_pattern_parameter_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_pattern_parameter_variable</code> is like <a href="#val-with_bound_pattern_meta_variable"><code>with_bound_pattern_meta_variable</code></a>, but for a parameter variable introduced in the meta-context of a pattern.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_pattern_substitution_variable"><a href="#val-with_bound_pattern_substitution_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_pattern_substitution_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_pattern_substitution_variable</code> is like <a href="#val-with_bound_pattern_meta_variable"><code>with_bound_pattern_meta_variable</code></a>, but for a substitution variable introduced in the meta-context of a pattern.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bound_pattern_context_variable"><a href="#val-with_bound_pattern_context_variable" class="anchor"></a><code><span><span class="keyword">val</span> with_bound_pattern_context_variable : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bound_pattern_context_variable</code> is like <a href="#val-with_bound_pattern_meta_variable"><code>with_bound_pattern_meta_variable</code></a>, but for a context variable introduced in the meta-context of a pattern.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_free_variables_as_pattern_variables"><a href="#val-with_free_variables_as_pattern_variables" class="anchor"></a><code><span><span class="keyword">val</span> with_free_variables_as_pattern_variables : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>pattern:<span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>expression:<span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>with_free_variables_as_pattern_variables state ~pattern ~expression state</code> is the result of running <code>expression</code> with the free variables added in <code>pattern</code> as bound variables. This is used to disambiguate <code>expression</code> with bound variables arising from free variables in <code>pattern</code>.</p><ol><li><code>pattern</code> is run with respect to <code>state</code> while keeping track of free variables. Variables bound outside the pattern are ignored in lookups.</li><li><code>expression</code> is run with respect to <code>state</code> with the addition of the tracked free variables from <code>patterns</code> as bound variables.</li></ol><p>Lookups performed in <code>pattern</code> are more complex. The variables in <code>state</code> count as being unbound, but the variables with binders in the pattern count as bound. Binders in a pattern can be user-specified, or to be reconstructed during abstraction.</p><p>A variable is specifically inner bound if it is introduced explicitly by a lambda abstraction or the pattern meta-context, as an explicit or implicit parameter. Free meta-level variables are reconstructed inner bound. For instance, assuming <code>s</code> and <code>ctx</code> are constants:</p><ul><li>In the pattern <code>(x, x)</code>, both occurrences of <code>x</code> are pattern variables, and that pattern is not linear.</li><li>In the pattern <code>{M : [ |- nat]} [ |- s M]</code>, <code>M</code> as introduced in the meta-context is a pattern variable, and <code>M</code> is an inner pattern-bound identifier in <code>s M</code>, so that pattern is linear.</li><li>In the pattern <code>[ |- \x. s x]</code>, there are no pattern variables.</li><li>In the pattern <code>([g |- s M], [g |- s M])</code>, <code>g</code> and <code>M</code> are pattern variables in the left projection of the tuple pattern, and inner pattern-bound in the right projection of the tuple pattern. This is because the pattern is reconstructed as <code>{g : ctx} {M : [g |- nat]} ([g |- s M], [g |- s M])</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_scope"><a href="#val-with_scope" class="anchor"></a><code><span><span class="keyword">val</span> with_scope : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_scope state m</code> runs <code>m</code> in a nested bindings scope that is discarded afterwards.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_parent_scope"><a href="#val-with_parent_scope" class="anchor"></a><code><span><span class="keyword">val</span> with_parent_scope : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_parent_scope state m</code> runs <code>m</code> while ignoring the topmost scope.</p><p>This is used for the disambiguation of Harpoon proof scripts because Harpoon hypotheticals are already serialized with all the identifiers in the meta-level and computation-level contexts of the proof.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_bindings_checkpoint"><a href="#val-with_bindings_checkpoint" class="anchor"></a><code><span><span class="keyword">val</span> with_bindings_checkpoint : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>with_bindings_checkpoint state m</code> runs <code>m</code> with a checkpoint on the bindings' state to backtrack to in case <code>m</code> raises an exception.</p><p>This is used for backtracking when disambiguating old-style LF type-level and term-level declarations (i.e., <code>x : X</code> where <code>X</code> may be an LF kind or an LF type).</p><p>This is also used in REPLs to safely run parsing functions and recover the state in case of a raised exception during disambiguation.</p><p>This checkpoint mechanism does not perform a copy or snapshot of the referencing environment. You need to make sure that <code>m</code> does not pop too many scopes.</p></div></div><h2 id="constants"><a href="#constants" class="anchor"></a>Constants</h2><div class="odoc-spec"><div class="spec value anchored" id="val-add_lf_type_constant"><a href="#val-add_lf_type_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_lf_type_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_lf_type_constant state ?location ?arity identifier</code> adds <code>identifier</code> as a bound LF type-level constant.</p><p>In the disambiguation of a module's declaration, this also adds the constant as one of the module's declarations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_lf_term_constant"><a href="#val-add_lf_term_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_lf_term_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_lf_term_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for LF term-level constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_schema_constant"><a href="#val-add_schema_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_schema_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_schema_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for schema constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_inductive_computation_type_constant"><a href="#val-add_inductive_computation_type_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_inductive_computation_type_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_inductive_computation_type_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for inductive computation-level type constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_stratified_computation_type_constant"><a href="#val-add_stratified_computation_type_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_stratified_computation_type_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_stratified_computation_type_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for stratified computation-level type constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_coinductive_computation_type_constant"><a href="#val-add_coinductive_computation_type_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_coinductive_computation_type_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_coinductive_computation_type_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for coinductive computation-level type constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_abbreviation_computation_type_constant"><a href="#val-add_abbreviation_computation_type_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_abbreviation_computation_type_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_abbreviation_computation_type_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for computation-level abbreviation type constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_computation_term_constructor"><a href="#val-add_computation_term_constructor" class="anchor"></a><code><span><span class="keyword">val</span> add_computation_term_constructor : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_computation_term_constructor</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for computation-level term constructors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_computation_term_destructor"><a href="#val-add_computation_term_destructor" class="anchor"></a><code><span><span class="keyword">val</span> add_computation_term_destructor : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_computation_term_destructor</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for computation-level term destructors.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_program_constant"><a href="#val-add_program_constant" class="anchor"></a><code><span><span class="keyword">val</span> add_program_constant : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?arity:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_program_constant</code> is like <a href="#val-add_lf_type_constant"><code>add_lf_type_constant</code></a>, but for computation-level program constants.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_module"><a href="#val-add_module" class="anchor"></a><code><span><span class="keyword">val</span> add_module : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>add_module state ?location identifier m</code> is the result of running <code>m</code> in a module disambiguation state, whereby added constants are kept track of as declarations in the module having <code>identifier</code>.</p></div></div><h2 id="lookups"><a href="#lookups" class="anchor"></a>Lookups</h2><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unbound_identifier"><a href="#exception-Unbound_identifier" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unbound_identifier</span> <span class="keyword">of</span> <a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a></span></code></div><div class="spec-doc"><p><code>Unbound_identifier identifier</code> is raised if <code>identifier</code> cannot be found in a disambiguation state when it is looked up.</p><p>This exception is caught whenever a variable lookup fails and <code>identifier</code> can be disambiguated as a free variable.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unbound_qualified_identifier"><a href="#exception-Unbound_qualified_identifier" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unbound_qualified_identifier</span> <span class="keyword">of</span> <a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a></span></code></div><div class="spec-doc"><p><code>Unbound_qualified_identifier identifier</code> is raised if <code>identifier</code> cannot be found in a disambiguation state when it is looked up.</p><p>This exception is unrecoverable, but is caught during disambiguation to provide better error messages.</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Unbound_namespace"><a href="#exception-Unbound_namespace" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Unbound_namespace</span> <span class="keyword">of</span> <a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a></span></code></div><div class="spec-doc"><p><code>Unbound_namespace namespace_identifier</code> is raised if a qualified identifier could not be looked up in a disambiguation state because the namespace with identifier <code>namespace_identifier</code> is unbound.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lookup_toplevel"><a href="#val-lookup_toplevel" class="anchor"></a><code><span><span class="keyword">val</span> lookup_toplevel : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Entry/index.html#type-t">Entry.t</a></span></code></div><div class="spec-doc"><p><code>lookup_toplevel state identifier</code> is <code>entry</code> if <code>identifier</code> resolves to <code>entry</code> in <code>state</code>. If <code>identifier</code> is unbound in <code>state</code>, then <code>Unbound_identifier identifier</code> is raised.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lookup"><a href="#val-lookup" class="anchor"></a><code><span><span class="keyword">val</span> lookup : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Entry/index.html#type-t">Entry.t</a></span></code></div><div class="spec-doc"><p><code>lookup state identifier</code> is <code>entry</code> if <code>identifier</code> resolves to <code>entry</code> in <code>state</code>. Otherwise:</p><ul><li><code>Unbound_identifier ident)</code> is raised if the first segment <code>ident</code> in <code>identifier</code> is unbound.</li><li><code>Unbound_namespace namespace_identifier</code> is raised if a segment in <code>identifier</code> other than the first or last is unbound.</li><li><code>Unbound_qualified_identifier identifier</code> is raised if the last segment in <code>identifier</code> is unbound.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-maximum_lookup_result"><a href="#type-maximum_lookup_result" class="anchor"></a><code><span><span class="keyword">type</span> maximum_lookup_result</span><span> = </span></code><ol><li id="type-maximum_lookup_result.Unbound" class="def variant constructor anchored"><a href="#type-maximum_lookup_result.Unbound" class="anchor"></a><code><span>| </span><span><span class="constructor">Unbound</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-maximum_lookup_result.segments" class="def record field anchored"><a href="#type-maximum_lookup_result.segments" class="anchor"></a><code><span>segments : <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span>;</span></code></li></ol><code><span>}</span></code></li><li id="type-maximum_lookup_result.Partially_bound" class="def variant constructor anchored"><a href="#type-maximum_lookup_result.Partially_bound" class="anchor"></a><code><span>| </span><span><span class="constructor">Partially_bound</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-maximum_lookup_result.leading_segments" class="def record field anchored"><a href="#type-maximum_lookup_result.leading_segments" class="anchor"></a><code><span>leading_segments : <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <a href="../../../../Support/List/index.html#type-t">Support.List.t</a></span>;</span></code></li><li id="type-maximum_lookup_result.segment" class="def record field anchored"><a href="#type-maximum_lookup_result.segment" class="anchor"></a><code><span>segment : <a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a>;</span></code></li><li id="type-maximum_lookup_result.entry" class="def record field anchored"><a href="#type-maximum_lookup_result.entry" class="anchor"></a><code><span>entry : <a href="Entry/index.html#type-t">Entry.t</a>;</span></code></li><li id="type-maximum_lookup_result.trailing_segments" class="def record field anchored"><a href="#type-maximum_lookup_result.trailing_segments" class="anchor"></a><code><span>trailing_segments : <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span>;</span></code></li></ol><code><span>}</span></code></li><li id="type-maximum_lookup_result.Bound" class="def variant constructor anchored"><a href="#type-maximum_lookup_result.Bound" class="anchor"></a><code><span>| </span><span><span class="constructor">Bound</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-maximum_lookup_result.entry" class="def record field anchored"><a href="#type-maximum_lookup_result.entry" class="anchor"></a><code><span>entry : <a href="Entry/index.html#type-t">Entry.t</a>;</span></code></li></ol><code><span>}</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-maximum_lookup"><a href="#val-maximum_lookup" class="anchor"></a><code><span><span class="keyword">val</span> maximum_lookup : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <a href="../../../../Support/List1/index.html#type-t">Support.List1.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-maximum_lookup_result">maximum_lookup_result</a></span></code></div><div class="spec-doc"><p><code>maximum_lookup state segments</code> is either:</p><ul><li><code>Unbound { segments }</code> if the first segment in <code>segments</code> is unbound in <code>state</code>.</li><li><code>Partially_bound { leading_segments; segment; entry; trailing_segments }</code> if the qualified identifier with namespaces <code>leading_segments</code> and name <code>segment</code> is bound to <code>entry</code> in <code>state</code>.</li><li><code>Bound { identifier; entry }</code> if <code>segments</code> form a qualified identifier bound to <code>entry</code> in <code>state</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-actual_binding_exn"><a href="#val-actual_binding_exn" class="anchor"></a><code><span><span class="keyword">val</span> actual_binding_exn : 
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Entry/index.html#type-t">Entry.t</a> <span class="arrow">&#45;&gt;</span></span>
  exn</span></code></div><div class="spec-doc"><p><code>actual_binding_exn identifier entry</code> is an exception reporting what sort of <code>entry</code> is bound at <code>identifier</code>. The exception is annotated with the entry's binding location.</p></div></div><h2 id="signature-operations"><a href="#signature-operations" class="anchor"></a>Signature Operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-open_module"><a href="#val-open_module" class="anchor"></a><code><span><span class="keyword">val</span> open_module : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>open_module state module_identifier</code> adds the exported constants from the module bound to <code>module_identifier</code> as toplevel entries in <code>state</code>. If <code>module_identifier</code> is unbound in <code>state</code>, then an exception is raised.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_default_associativity"><a href="#val-get_default_associativity" class="anchor"></a><code><span><span class="keyword">val</span> get_default_associativity : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../Syncom/Associativity/index.html#type-t">Beluga_syntax.Syncom.Associativity.t</a></span></code></div><div class="spec-doc"><p><code>get_default_associativity state</code> is the associativity to use for infix operators defined by the user using a pragma, without specifying the infix operator's associativity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_default_associativity"><a href="#val-set_default_associativity" class="anchor"></a><code><span><span class="keyword">val</span> set_default_associativity : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Associativity/index.html#type-t">Beluga_syntax.Syncom.Associativity.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>set_default_associativity state default_associativity</code> sets <code>default_associativity</code> as the associativity to return from <a href="#val-get_default_associativity"><code>get_default_associativity</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_default_precedence"><a href="#val-get_default_precedence" class="anchor"></a><code><span><span class="keyword">val</span> get_default_precedence : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a></span></code></div><div class="spec-doc"><p><code>get_default_precedence state</code> is the precedence to use for operators defined by the user using a pragma, without specifying the operator's precedence.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_default_precedence"><a href="#val-set_default_precedence" class="anchor"></a><code><span><span class="keyword">val</span> set_default_precedence : <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>set_default_precedence state default_precedence</code> sets <code>default_precedence</code> as the precedence to return from <a href="#val-get_default_precedence"><code>get_default_precedence</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_prefix_notation"><a href="#val-add_prefix_notation" class="anchor"></a><code><span><span class="keyword">val</span> add_prefix_notation : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?precedence:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_prefix_notation state ?precedence identifier</code> adds a prefix notation for <code>identifier</code>. If <code>precedence = Option.None</code>, then <a href="#val-get_default_precedence"><code>get_default_precedence</code></a> is used instead.</p><p>An exception is raised if <code>identifier</code> is unbound in <code>state</code>, not bound to a constant, or bound to a constant of an unknown or invalid arity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_infix_notation"><a href="#val-add_infix_notation" class="anchor"></a><code><span><span class="keyword">val</span> add_infix_notation : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?precedence:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?associativity:<a href="../../../../Syncom/Associativity/index.html#type-t">Beluga_syntax.Syncom.Associativity.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_infix_notation state ?precedence ?associativity identifier</code> adds an infix notation for <code>identifier</code>. If <code>precedence = Option.None</code>, then <a href="#val-get_default_precedence"><code>get_default_precedence</code></a> is used instead. Likewise, if <code>associativity = Option.None</code>, then <a href="#val-get_default_associativity"><code>get_default_associativity</code></a> is used instead.</p><p>An exception is raised if <code>identifier</code> is unbound in <code>state</code>, not bound to a constant, or bound to a constant of an unknown or invalid arity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_postfix_notation"><a href="#val-add_postfix_notation" class="anchor"></a><code><span><span class="keyword">val</span> add_postfix_notation : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?precedence:<a href="../../../../Support/Int/index.html#type-t">Support.Int.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_postfix_notation state ?precedence identifier</code> adds a postfix notation for <code>identifier</code>. If <code>precedence = Option.None</code>, then <a href="#val-get_default_precedence"><code>get_default_precedence</code></a> is used instead.</p><p>An exception is raised if <code>identifier</code> is unbound in <code>state</code>, not bound to a constant, or bound to a constant of an unknown or invalid arity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lookup_operator"><a href="#val-lookup_operator" class="anchor"></a><code><span><span class="keyword">val</span> lookup_operator : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Operator/index.html#type-t">Beluga_syntax.Syncom.Operator.t</a> <a href="../../../../Support/Option/index.html#type-t">Support.Option.t</a></span></span></code></div><div class="spec-doc"><p><code>lookup_operator state identifier</code> is <code>Option.Some operator</code> if <code>identifier</code> is bound to an operator with descriptor <code>operator</code> in <code>state</code>, and <code>Option.None</code> otherwise.</p><p>This is used to resolve operators in the disambiguation of applications, which are parsed as lists of expressions.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_module_abbreviation"><a href="#val-add_module_abbreviation" class="anchor"></a><code><span><span class="keyword">val</span> add_module_abbreviation : 
  <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?location:<a href="../../../../Syncom/Location/index.html#type-t">Beluga_syntax.Syncom.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Qualified_identifier/index.html#type-t">Beluga_syntax.Syncom.Qualified_identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../../Syncom/Identifier/index.html#type-t">Beluga_syntax.Syncom.Identifier.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Stdlib</span>.Unit.t</span></code></div><div class="spec-doc"><p><code>add_module_abbreviation state ?location module_identifier abbreviation</code> adds the synonym <code>abbreviation</code> for the module bound to <code>identifier</code> in <code>state</code>.</p><p>An exception is raised if <code>module_identifier</code> is unbound in <code>state</code>, or if <code>module_identifier</code> is not bound to a module in <code>state</code>.</p></div></div></div></body></html>