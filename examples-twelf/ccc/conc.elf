% Translation CCC combinators -> lambda-terms

% conc  : mor A B -> (term A -> term B) -> type.
% % mode conc +D -E.
% 
% cid   : conc idc (\x . x).
% 
% ccomp : conc (@ F G) (\x . (M (N x)))
%          <- conc G (\x . N x)
%          <- conc F (\x . M x).
% 
% cunit : conc drop (\x . lunit).
% 
% cpair : conc (pair F G) (\x . (lpair (M x) (N x)))
%          <- conc G (\x . N x)
%          <- conc F (\x . M x).
% 
% cfst  : conc fst (\x . (lfst x)).
% 
% csnd  : conc snd (\x . (lsnd x)).
% 
% ccur  : conc (cur F) (\a . llam (\b . M (lpair a b)))
%          <- conc F (\x . M x).
% 
% capp  : conc app (\a . lapp (lfst a) (lsnd a)).

% worlds () (conc _ _).

rec conc : (mor A B)[] -> (term A -> term B)[] =
    fn d => case d of
        [] idc =>
           [] (\x . x)

% FIXME reconstruct:elBranch expect an atomic type for the argument of the match
% here we are matching on argument of type (term A -> term B) ('let' gets transformed into a match)
% same problem for pair and cur below
% 
%       | [] (@ F G) =>
%            let [] M = conc ([] F) in
%            let [] N = conc ([] G) in
%                [] (\x . (M (N x)))

      | [] drop =>
           [] (\x . lunit)

%       | [] (pair F G) =>
%            let [] M = conc ([] F) in
%            let [] N = conc ([] G) in
%                [] (\x . (lpair (M x) (N x)))

% FIXME problem in unification I do not really understand, same problem for snd and app below
% 
%       | [] fst =>
%           [] (\x . (lfst x))
% 
%       | [] snd =>
%            [] (\x . (lsnd x))

%       | [] (cur F) =>
%            let [] M = conc ([] F) in
%                [] (\a . (llam (\b . (M (lpair a b)))))

%       | [] app =>
%            [] (\a . (lapp (lfst a) (lsnd a)))
;
