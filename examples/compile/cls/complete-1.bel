% Lemma
% Lemma: For every
%   C :: st Ks P S =>* st Ks' P' S'
% and
%   C' :: st Ks P S =>* st Ks' P' S'
% there exists a computation
%  C'' :: st Ks P S =>* st Ks'' P'' S''.

% Proof: By induction on the structure of C.


rec append : [ |- mstep (st Ks P S)  (st Ks' P' S')]
           -> [ |- mstep (st Ks' P' S') (st Ks'' P'' S'')]
	   -> [ |- mstep (st Ks P S) (st Ks'' P'' S'')] =
fn c =>  fn c' => case c of

  [ |- id_step] =>  c'

% Rewrote definition of to s.t. it is clear what a state is,
% namely, it looks like (st K P S). The issue was that
% Otherwise, elaboration will only know the type state for C, but cannot
% refine it later.
 | [ |- to R C]  =>  let [ |- C''] = append [ |- C] c' in [ |- to R C'']
;


% %{
% Subcomputation Lemma:  For every
%   D :: feval K F W
% environment stack Ks, program P, and stack S there exists a computation
%  C :: st (Ks ;; K) (ev F & P) S =>* st Ks P (S ; W)

% Proof: By induction on the structure of D
% }%


% Unlike the Twelf proof, where Ks, P, and S are only made explicit as input
% in the mode declaration, in the functional representation, we make these
% inputs explicit in the type of the function subcomp, and also in the recursive calls.

rec subcomp : {Ks:[ |- envstack]}{P:[ |- program]}{S: [ |- env]}
              [ |- feval K F W] ->
              [ |- mstep (st (push Ks K) (prog (ev F) P) S) (st Ks P (vcons S  W))] =
mlam Ks => mlam P => mlam S =>
fn d => case d of
  [ |- fev_1]  =>  [ |- to c_1 id_step]

 |  [ |- fev_^ D1] =>
     (let [ |- C1]  = subcomp [ |- Ks ] [ |- P ] [ |- S ] [ |- D1] in
 	[ |- to c_^ C1] )


| [ |- fev_1+ D1]  =>
    let [ |- C1] = subcomp [ |- Ks ] [ |- P ] [ |- S ] [ |- D1] in
 	[ |- (to c_1+ C1)]

% | [ ] fev_^+ D1 =>
%     let [ ] C1 = subcomp < . Ks > < . P > < . S > ([ ] D1) in
% 	[ ] (to c_^+ C1)

% Same reason as above: Left-over uninstantiated MVars.
% | [ ] fev_z => [ ] exSubComp (to c_z id_step)


% | [ ] fev_s D1 =>
%     let [ ] exSubComp C1 = subcomp ([ ] D1) in
%
%     % Again the problem that we learn later something about the program.
%     % from the pattern we know that
%     % C1 :  st.. (prog (ev X124[^0]) P30[^0]).
%     % but we need to use it in the append function below with
%     % st. (prog (ev X124[^0]) P30[^0]).
%
%     let [ ] S  =  append ([ ] to c_s C1) ([ ] to c_add1 id_step) in
%       [ ] exSubComp S


;
