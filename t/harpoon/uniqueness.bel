% Prove type-uniqueness for the simply typed lambda-calculus

LF tp : type =
| arr : tp -> tp -> tp
| nat : tp
;

LF term : type =
| lam : tp -> (term -> term) -> term
| app : term -> term -> term
;

LF hastype : term -> tp -> type =
| t_lam : ({x:term} hastype x T1 -> hastype (E x) T2) -> hastype (lam T1 E) (arr T1 T2)
| t_app : hastype E1 (arr T2 T) -> hastype E2 T2 -> hastype (app E1 E2) T
;

LF eq: tp -> tp -> type =
| refl: eq T T
;

schema tctx = some [t:tp] block (x:term, _t:hastype x t);

proof unique : (g : tctx) [g ⊢ hastype M T1[]] → [g ⊢ hastype M T2[]] →
               [⊢ eq T1 T2] =
/ total 1 /
intros
{ g : tctx, M : (g |- term), T1 : ( |- tp), T2 : ( |- tp)
| z5 : [g |- hastype M T1[]], y6 : [g |- hastype M T2[]]
; split z5 as
  case t_app:
  { g : tctx,
    X : (g |- term),
    X3 : (g |- term),
    T1 : ( |- tp),
    T2 : ( |- tp),
    X1 : ( |- tp),
    X4 : (g |- hastype X (arr X1[] T1[])),
    X5 : (g |- hastype X3 X1[])
  | z5 : [g |- hastype (app X X3) T1[]], y6 : [g |- hastype (app X X3) T2[]]
  ; split y6 as
    case t_app:
    { g : tctx,
      X : (g |- term),
      X3 : (g |- term),
      T1 : ( |- tp),
      T2 : ( |- tp),
      X1 : ( |- tp),
      X4 : (g |- hastype X (arr X1[] T1[])),
      X5 : (g |- hastype X3 X1[]),
      X7 : ( |- tp),
      X10 : (g |- hastype X (arr X7[] T2[])),
      X11 : (g |- hastype X3 X7[])
    | z5 : [g |- hastype (app X X3) T1[]],
      y6 : [g |- hastype (app X X3) T2[]]
    ; by unique [g |- X4] [g |- X10] as ih1 ;
      by unique [g |- X5] [g |- X11] as ih2 ;
      split ih1 as
      case refl:
      { g : tctx,
        X : (g |- term),
        X3 : (g |- term),
        T2 : ( |- tp),
        X7 : ( |- tp),
        X4 : (g |- hastype X (arr X7[] T2[])),
        X5 : (g |- hastype X3 X7[]),
        X10 : (g |- hastype X (arr X7[] T2[])),
        X11 : (g |- hastype X3 X7[])
      | z5 : [g |- hastype (app X X3) T2[]],
        y6 : [g |- hastype (app X X3) T2[]],
        ih1 : [ |- eq (arr X7 T2) (arr X7 T2)],
        ih2 : [ |- eq X7 X7]
      ; solve [ |- refl ]
      }
    }
  }
  case t_lam:
  { g : tctx,
    X : ( |- tp),
    X1 : (g, z3 : term |- term),
    X2 : ( |- tp),
    T2 : ( |- tp),
    X3 : (g, x : term, x3 : hastype x X[] |- hastype (X1[.., x]) X2[])
  | z5 : [g |- hastype (lam X[] (\x1. X1)) (arr X[] X2[])],
    y6 : [g |- hastype (lam X[] (\x1. X1)) T2[]]
  ; split y6 as
    case t_lam:
    { g : tctx,
      X : ( |- tp),
      X1 : (g, z3 : term |- term),
      X2 : ( |- tp),
      X6 : ( |- tp),
      X3 : (g, x : term, x3 : hastype x X[] |- hastype (X1[.., x]) X2[]),
      X7 : (g, x : term, x3 : hastype x X[] |- hastype (X1[.., x]) X6[])
    | z5 : [g |- hastype (lam X[] (\x1. X1)) (arr X[] X2[])],
      y6 : [g |- hastype (lam X[] (\x1. X1)) (arr X[] X6[])]
    ; by unique [g, x1 : block x:term, u:hastype x X[] |- X3[.., x1.1, x1.2]] [g, x1 |- X7[.., x1.1, x1.2]]
        as ih ;
      split ih as
      case refl:
      { g : tctx,
        X : ( |- tp),
        X1 : (g, z3 : term |- term),
        X6 : ( |- tp),
        X3 : (g, x : term, x3 : hastype x X[] |- hastype (X1[.., x]) X6[]),
        X7 : (g, x : term, x3 : hastype x X[] |- hastype (X1[.., x]) X6[])
      | z5 : [g |- hastype (lam X[] (\x1. X1)) (arr X[] X6[])],
        y6 : [g |- hastype (lam X[] (\x1. X1)) (arr X[] X6[])],
        ih : [ |- eq X6 X6]
      ; solve [ |- refl ]
      }
    }
  }
  case #.2:
  { g : tctx,
    T1 : ( |- tp),
    #p1 : #(g |- block (x:term, _t:hastype x T1[])),
    T2 : ( |- tp)
  | z5 : [g |- hastype #p1.1 T1[]], y6 : [g |- hastype #p1.1 T2[]]
  ; split y6 as
    case #.2:
    { g : tctx,
      T2 : ( |- tp),
      #p1 : #(g |- block (x:term, _t:hastype x T2[]))
    | z5 : [g |- hastype #p1.1 T2[]], y6 : [g |- hastype #p1.1 T2[]]
    ; solve [ |- refl ]
    }
  }
}
;
