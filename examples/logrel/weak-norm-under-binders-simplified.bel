% ----------------------------------------------------------------------------
% Weak normalization for lambda-calculus with 
% parallel reduction (in particular with reduction 
% under binder)
% Author: A. Cave
% ----------------------------------------------------------------------------
% Definition of types and intrinsically typed terms
LF tp : type = 
| i :  tp
| arr: tp -> tp -> tp
;
%name tp T.

LF tm : tp -> type = 
| app : tm (arr T S) -> tm T -> tm S
| lam : (tm T -> tm S) -> tm (arr T S)
;
%name tm E.

schema ctx = tm T;
% ----------------------------------------------------------------------------
% Multi-step parallel reduction
LF step : tm A -> tm A -> type = 
| s_beta : step (app (lam M) N) (M N)
| s_eta : {M:tm (arr A B)} step M (lam (\x. app M x))
| s_lam : ({x:tm A} step (M x) (M' x)) -> step (lam M) (lam M')
| s_app : step M M' -> step N N' -> step (app M N) (app M' N')
| s_refl : step M M
| s_trans : step M M' -> step M' M'' -> step M M''
;
%name step S.
% -----------------------------------------------------------------------------
% Defining Normal and Neutral Terms
% We define them in LF. We do not enforce eta-longness here, although this can in principle be done.
%

LF normal : tm A -> type =
| n_lam : ({x:tm A} neutral x -> normal (M x)) -> normal (lam (\x. M x))
| n_neut : neutral M -> normal M
and neutral : tm A -> type =
| n_app : neutral M -> normal N -> neutral (app M N)
;

% -----------------------------------------------------------------------------
% -----------------------------------------------------------------------------
% Reducibility Definition 
% It is defined inductively over the type A.
% In the case where A is a function type we quantify over
% the context h0, a substitution #R which maps variables from the context h to the
% context h0. While we use built-in simultanteous substitutions to model #R, our 
% built-in substitutions are more general and do not restrict #R to be a variable 
% substitution (i.e. a possible a weakening substitution).
% We hence define explicitly a predicate that checks whether a given substitution is a 
% variable-to-variable substitution.

schema nctx = some [t:tp] block x:tm t, y:neutral x;

inductive Halts : (gamma:nctx) {A:[ |- tp]}{M:[gamma |- tm A[]]} ctype =
| Halts : {V:[gamma |- tm _]} [gamma |- step M V] -> [gamma |- normal V] -> Halts [ |- A] [gamma |- M];

stratified Reduce : (gamma:nctx) {A:[ |- tp]}{M:[gamma |- tm A[]]} ctype =
| Base : Halts [ |- i] [gamma |- M] -> Reduce [ |- i] [gamma |- M]
| Arr :  {M:[gamma |- tm (arr A[] B[])]}
         ({phi:nctx} {#S:[phi |- gamma]} {N:[phi |- tm A[]]}
            Reduce [ |- A] [phi |- N]
          -> Reduce [ |- B ] [phi |- app M[#S] N])
         -> Reduce [ |- arr A B] [gamma |-  M];

% -----------------------------------------------------------------------------
% Lemma [ Backwards Closed ]
% If step M M'   and   M' is reducible at type A  
% then M is reducible at type A

rec closed : {A:[|- tp]}{M:[g |- tm A[]]}{M':[g |- tm A[]]}
             {S:[g |- step M M']} Reduce [ |- A] [g |- M'] -> Reduce [ |- A] [g |- M] =
/ total a (closed _ a) /
mlam A,M,M',S => fn r => case [|- A] of 
| [|- i] =>  
   let Base (Halts [g |- V] [g |- S'] v) = r in 
     Base (Halts [g |- V] [g |- s_trans S S'] v)

| [|- arr A B] => 
  let Arr [g |- M'] f = r in 
  Arr [g |- M]
  (mlam h, #W, N => fn rn =>
    closed [ |- B] [h |- app M[#W] N] [h |- app M'[#W] N] [h |- s_app S[#W] s_refl] (f [h] [h |- #W] [h |- N] rn))
;

% -----------------------------------------------------------------------------
% Lemma: If M is reducible at type A then M halts

rec reflect : {gamma:nctx}{A:[|-tp]}{R:[gamma |- tm A[]]}{NR:[gamma |- neutral R]} Reduce [ |- A] [gamma |- R] =
/ total a (reflect gamma a) /
mlam gamma, A,R,NR => case [ |- A] of
| [ |- i] => Base (Halts [gamma |- R] [gamma |- s_refl] [gamma |- n_neut NR])
| [ |- arr A B] =>
  Arr [gamma |- R]
  (mlam phi, #W, M2 => fn rm2 =>
    let Halts [phi |- V] [phi |- MS] [phi |- NR'] = reify [phi] [|- A] [phi |- M2] rm2 in
    closed [|- B] [phi |- app R[#W] M2]  [phi |- app R[#W] V] [phi |- s_app s_refl MS] 
           (reflect [phi] [|- B] [phi |- app R[#W] V] [phi |- n_app NR[#W] NR']))

and reify : {gamma:nctx}{A:[|- tp]}{M:[gamma |- tm A[]]}
            Reduce [ |- A] [gamma |- M] -> Halts [ |- A] [gamma |- M] =
 / total a (reify gamma a ) /
mlam gamma,A,M => fn r => case [|- A] of 
| [|- i] => let Base ha = r in ha
| [|- arr A B] => 
  let Arr [gamma |- M] f = r in 
  let q1 = f [gamma,b:block x:tm _,y:neutral x] [gamma,b |- ..] [gamma,b |- b.1]
             (reflect [gamma,b:block x:tm _,y:neutral x ] [|- A] [gamma,b |- b.1] [gamma,b:block x:tm _,y:neutral x |- b.2]) in
  let Halts [gamma,b:block x:tm A[],y:neutral x |- V[..,b.1]]
            [gamma,b:block x:tm A[],y:neutral x |- MS]
            [gamma,b:block x:tm A[],y:neutral x |- N]
          = reify [gamma,b:block x:tm A[],y:neutral x ] [|- B] [gamma,b:block x:tm A[],y:neutral x |- app M[..] b.1] q1 in
  let [gamma,b:block x:tm A[],y:neutral x |- MS'[..,b.1]] = [gamma,b:block x:tm A[],y:neutral x |- MS] in % I am not sure why I have to do this separately
  Halts [gamma |- lam \x.V[..,x]] [gamma |- s_trans (s_eta _) (s_lam (\x. MS'))] [gamma |- n_lam (\x. \y. N[..,<x;y>])]
;

% -----------------------------------------------------------------------------
% Defining reducibility of simultaneous substitutions.

inductive RedSub : {g:ctx}(h:nctx){#S:[h |- g]} ctype =
| Nil : RedSub [] [h |- ^ ]
| Dot : RedSub [g] [h |- #S ] -> Reduce [ |- A] [h |- M] -> RedSub [g,x:tm A[]] [h |- #S, M ];

% Lemmas about reducible simultaneous substitutions.
% Weakening a term M that is reducible at type A
rec wknRed : (h:nctx) {#W:[h |- g]} Reduce  [ |- A] [g |- M] -> Reduce [ |- A] [h |- M[#W]] =
/ total (wknRed) /
mlam #W => fn r =>
case r of
| Base (Halts [_ |- _] [g |- S] [g |- NR]) => Base (Halts [_ |- _] [_ |- S[#W]] [_ |- NR[#W]])
| Arr [g |- M] f =>
  Arr [_ |- M[#W]]
   (mlam h', #W2, N => fn rn =>
    f [h'] [h' |- #W[#W2]] [h' |-  N] rn);


% Composing a reducible substitution with a variable substitution yields a 
% reducible substitution
rec wknRedSub : {#W:[h' |- h]} RedSub [g] [h |- #S] -> RedSub [g] [h' |- #S[#W]] =
/ total rs (wknRedSub _ _ _ _ _ rs) /
mlam #W => fn rs => case rs of
| Nil => Nil
| Dot rs' rN => Dot (wknRedSub [_ |- #W] rs') (wknRed [_ |- #W] rN);

% If sigma is a reducible substitution then applying sigma to a variable yields a term 
% that is reducible
rec redVar : {g:ctx}{#p:[g |- tm A[]]} RedSub [g] [h |- #S] ->  Reduce [ |- A] [h |- #p[#S] ] =
/ total g (redVar g) / 
mlam g, #p => fn rs => case [g] of 
| [] => impossible [ |- #p] 
| [g', x:tm A[]] => (case [g', x:tm A[] |- #p[..,x]] of 
   | [g',x:tm A[] |-  x]      =>    let Dot rs' rN = rs in rN
   | [g',x:tm A[] |-  #q[..]] => let Dot rs' rN = rs in redVar [g'] [g' |-  #q] rs');

% % The identity substitution is reducible
% rec idRedSub : {g:ctx} RedSub [g] [g |- ..] =
% / total g (idRedSub g) /
% mlam g => case [g] of 
% | [ ] => Nil
% | [g',x:tm A[]] =>
%   Dot (wknRedSub (idRedSub [g']) (shiftIsVarSub [g']))
%       (reflect [g', x:tm A[]] [|- _ ] [g', x:tm A[] |- x ] (Var (IsVar [g',x:tm A[] |-  x])));

% -----------------------------------------------------------------------------
% Main Lemma: 
% If g |- M : A   and  h |- sigma : g   and sigma is reducible 
% then M[sigma] is reducible at type A in the context h.

rec eval : {M:[gamma |- tm A[]]} RedSub [gamma] [phi |- #S ] -> Reduce [ |- A] [phi |- M[#S] ] =
/ total m (eval gamma phi a sigma m) /
mlam M => fn rs => let (rs : RedSub [gamma] [phi |- #S] ) = rs in
 case [gamma |- M] of
| [gamma |-  #p] => redVar [gamma] [gamma |-  #p] rs
| [gamma |-  app M1 M2]  =>
  let Arr [phi |- _ ] f = eval [gamma |-  M1]  rs in
   f [phi] [phi |- ..] [phi |- M2[#S]] (eval [gamma |-  M2] rs)
| [gamma |-  lam (\x. M1)] =>
   Arr [phi |- lam (\x. M1[#S[..], x])]
   (mlam psi,#W,N => fn rN =>
     closed [|- _ ] [psi |- app (lam \x.M1[#S[#W[..]],x]) N ] [psi |- M1[#S[#W[..]], N] ] 
            [psi |-  s_beta] (eval [gamma,x:tm _ |-  M1] (Dot (wknRedSub [psi |- #W] rs) rN)));

% -----------------------------------------------------------------------------
% THEOREM: Well-typed terms halt. 

% #Id is a substitution which moves from a term context to a neutral term context in the obvious way
inductive IdSub : (g':nctx){g:ctx}{#Id:[g' |- g]} ctype =
| INil : IdSub [] [|- ^]
| ISnoc : IdSub [g] [g' |- #Id] -> IdSub [g,x:tm A[]] [g',b:block x:tm A[],y:neutral x |- #Id[..], b.1];

rec idLogSub : IdSub [g] [g' |- #Id] -> RedSub [g] [g' |- #Id] =
/ total r (idLogSub g g s r) /
fn r => case r of
| INil => Nil
| ISnoc r' =>
  Dot (wknRedSub [_,b:block x:tm _,y:neutral x |- ..] (idLogSub r'))
      (reflect [_] [|- _] [_ |- _] [_,b:block x:tm _,y:neutral x |- b.2])
;  

rec weakNorm : {M:[g |- tm A[]]} IdSub [g] [g' |- #Id] -> Halts  [ |- A] [g' |- M[#Id]] =
/ total (weakNorm) /
mlam M => fn s => reify [_] [|- _] [_ |- _] (eval [_ |- M] (idLogSub s));

% We probably want to show also that for any g:ctx there exists g':nctx and #Id:[g' |- g]
% such that IdSub [g] [g' |- #Id]...
