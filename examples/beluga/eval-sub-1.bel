% Substitution based evaluator
%   call-by-value strategy
%
%   Author: Brigitte Pientka
%

exp: type.


z   : exp.
suc : exp -> exp.
app : exp -> exp -> exp.
lam : (exp -> exp) -> exp.
letn: exp -> (exp -> exp) -> exp.
letv: exp -> (exp -> exp) -> exp.
fix : (exp -> exp) -> exp. 



% Call-By-Name evaluation 
rec eval : (exp)[.] -> (exp)[.] = 
fn e => 

(case e of

  {U::exp[.]} 
   box( . suc U![.]!) : exp [.] =>

    (case (eval (box( . U![.]!))) of       

      {V::exp[.]} 
      box( . V![.]!) : exp [.] => box( . suc V![.]!))

| {U::exp[.]}{W::exp[.]}
    box( . app U![.]! W![.]!) : exp [.] =>   
    (case (eval (box (. U![.]!))) of
       {V::exp[. , x:exp]} box( . lam (\ x. V![.,x]!)) : exp[.] => 
          eval (box( . V![., W![.]! ]!))
    )
        
| {U::exp[. , x:exp]}
  box( . lam (\ x. U![. , x]!)) : exp[.] =>  e


| {W::exp[.]}{U::exp[. , x:exp]}
   box ( . letn W![.]! (\ x. U![.,x]!)) : exp [.] => 

       eval (box ( . U![. , W![.]! ]!))


| {U::exp[. , x:exp]}
   box( . fix (\ x. U![. , x]!)) : exp[.] =>  

       eval (box (. U![. ; fix (\ x. U![. , x]!) ]!))

);


% Call-By-Value 
rec eval' : (exp)[.] -> (exp)[.] = 
fn e => 

(case e of

  {U::exp[.]} 
   box( . suc U![.]!) : exp [.] =>

    (case (eval' (box( . U![.]!))) of       

      {V::exp[.]} 
      box( . V![.]!) : exp [.] => box( . suc V![.]!))

| {U::exp[.]}{W::exp[.]}
    box( . app U![.]! W![.]!) : exp [.] => 

    (case (eval' (box (. U![.]!))) of
       {V::exp[. , x:exp]} box( . lam (\ x. V![.,x]!)) : exp[.] => 

          (case (eval' (box (. W![.]!))) of 
              {V2::exp[.]} box( . V2![.]!) : exp[.] => 
                   eval' (box( . V![., V2![.]! ]!))
          )
    )
        
| {U::exp[. , x:exp]}
  box( . lam (\ x. U![. , x]!)) : exp[.] =>  e


| {W::exp[.]}{U::exp[. , x:exp]}
   box ( . letv W![.]! (\ x. U![.,x]!)) : exp [.] => 

     case (eval' (box ( . W![.]!))) of 
         {V::exp[.]} box ( . V![.]!) : exp [.] => 
               eval' (box ( . U![. , V![.]! ]!))

);
