September 29, 10:27 am Sasybel successfully translated it's fist theorem!

## Type Reconstruction: sum1.bel ##

rec zless : (less z (s z))[] = 
[] l_one z

## Type Reconstruction done: sum1.bel  ##


theorem z_less_s_z: exists z < (s z) ;

dsolve : z < (s z) by rule less-one

end theorem

## SASyLF parsing: nat.slf ##

rec zless : (less z (s z))[] = 
[] l_one z

## Type Reconstruction done: nat.slf  ##

November 15

## Type Reconstruction: sum.bel ##

rec plus1 : {N :: nat[]} (add N (s z) (s N))[] = 
mlam N =>  case [] N : nat[] of 
           | ([] z) :  . z = N ;   => 
              [] a_z (s z)
           

## Type Reconstruction done: sum.bel  ##

theorem plus1 : forall N exists N + (s z) = (s N);

x : N + (s z) = (s N) by induction on N : 

case z is
	   d2: (z) + (s z) = (s z) 	by rule sum-z
end case

end induction
end theorem 


## SASyLF parsing: sum2.slf ##

rec plus1 : {N :: n[]} (sum N (s z) (s N))[] = 
mlam N =>  case [] N : n[] of 
           | ([] z) :  . z = N ;   => 
              [] sum-z (s z)
           

## Type Reconstruction done: sum2.slf  ##

November 24

## Type Reconstruction: sum.bel ##

rec plus1 : {N :: nat[]} (add N (s z) (s N))[] = 
mlam N => 
  case [] N : nat[] of 
  | ([] z) :  . z = N ;   => 
     [] a_z (s z)
  
  | {Y :: nat[]}
    ([] s Y) :  . s Y = N ;   => 
      (case plus1 <. Y> of 
       | {Z1 :: nat[]}  {X1 :: (add Z1 (s z) (s Z1))[]}
         ([] X1) :  . Z1 = Y ;   => 
          [] a_s Z1 (s z) (s Z1) X1
       )
  

## Type Reconstruction done: sum.bel  ##


## SASyLF parsing: sum2.slf ##

rec plus1 : {N :: n[]} (sum N (s z) (s N))[] = 
mlam N => 
  case [] N : n[] of 
  | ([] z) :  . z = N ;   => 
     [] sum-z (s z)
  
  | {Y :: n[]}
    ([] s Y) :  . s Y = N ;   => 
      (case plus1 <. Y> of 
       | {Z1 :: n[]}  {X1 :: (sum Z1 (s z) (s Z1))[]}
         ([] X1) :  . Z1 = Y ;   => 
          [] sum-s Z1 (s z) (s Z1) X1
       )
  

## Type Reconstruction done: sum2.slf  ##

