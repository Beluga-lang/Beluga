% Basic Context Reasoning
% Author: Brigitte Pientka
%

% Definition of lambda-terms
tm: type.                         %name tm M x.
app: tm -> tm -> tm.
lam: (tm -> tm) -> tm.

% ---------------------------------------------------------------------------
% Algorithmic Equality
aeq: tm -> tm -> type.   %name aeq Q u.
ae_a : aeq M1 N1 -> aeq M2 N2 -> aeq (app M1 M2) (app N1 N2).

ae_l :  ({x : tm} aeq x x -> aeq (M x) (N x)) 
          -> aeq (lam (\x. M x)) (lam (\x. N x)).

% ---------------------------------------------------------------------------
% Declarative Equality
deq: tm -> tm -> type.
de_l: ({x:tm} deq x x -> deq (M x) (M' x)) 
     -> deq (lam (\x. M x)) (lam (\x. M' x)).
de_a: deq M1 N1 -> deq M2 N2 
     -> deq (app M1 M2) (app N1 N2).
de_r: deq M M.
de_t: deq M L -> deq L N 
     -> deq M N.
% Symmetry 
de_s: deq T S -> deq S T.


% ---------------------------------------------------------------------------
% Context schemas 
schema xaG = block x:tm, ae_v:aeq x x;
schema daG =  block x: tm, ae_v:aeq x x, de_v:deq x x ; 

% ---------------------------------------------------------------------------
% Reflexivity: We prove reflexivity in the generalized version
% 
rec reflG: {g:xaG} {M:[g |- tm]} [g |- aeq (M ..) (M ..)] =
mlam g => mlam M => case [g |- (M ..)] of
| [g |- #p.1 ..] => [g |- #p.2 ..]

| [g |- lam \x. M .. x] =>
  let [g,b:block y:tm, ae_v:aeq y y |-  D .. b.1 b.2] = 
         reflG [g, b:block y:tm, ae_v:aeq y y] [g, b |-  M .. b.1]
  in
   [g |- ae_l \x. \w. (D .. x w)]  % : eq (L .. x) (L .. x)
| [g |- app (M1 ..) (M2 ..)] =>
  let [g |- D1 ..] = reflG [g] [g |- M1 .. ] in
  let [g |- D2 ..] = reflG [g] [g |- M2 .. ] in
    [g |- ae_a (D1 ..) (D2 ..)]
;

% ---------------------------------------------------------------------------
% General transitivity is admissible
rec transG: (g:xaG) 
   [g |- aeq (M ..) (L ..)] -> [g |- aeq (L ..) (N ..)]   
 -> [g |- aeq (M ..) (N ..)]  =
fn d1 => fn d2 => case d1 of
| [g |- #p.2 ..] => d2

| [g |- ae_l \x.\u. D1 .. x u] =>
  let [g |- ae_l \x.\u. D2 .. x u] =  d2  in	
  let [g, b:block x:tm, ae_v:aeq x x |-  E .. b.1 b.2] = 
         transG [g, b:block x':tm, ae_v:aeq x' x'  |-  D1 .. b.1 b.2]
               [g, b |-  D2 .. b.1 b.2]
  in
    [g |- ae_l \x. \u. E .. x u]
       
| [g |- ae_a (D1 ..) (D2 ..)] =>
  let [g |- ae_a (F1 ..) (F2 ..)] = d2 in 
  let [g |- E1 ..] = transG [g |- D1 ..]  [g |- F1 ..] in
  let [g |- E2 ..] = transG [g |- D2 ..]  [g |- F2 ..] in
    [g |- ae_a  (E1 ..)  (E2 ..)]
;


% ---------------------------------------------------------------------------
% General symmetry is admissible
rec symG: (g:xaG) 
   [g |- aeq (M ..) (L ..)] -> [g |- aeq (L ..) (M ..)]  =
fn d => case d of
| [g |- #p.2 ..] => d

| [g |- ae_l \x.\u. D1 .. x u] =>
  let [g, b:block x:tm, ae_v:aeq x x |-  E .. b.1 b.2] = 
         symG [g, b:block x':tm, ae_v:aeq x' x'  |-  D1 .. b.1 b.2]
  in
    [g |- ae_l \x. \u. E .. x u]
       
| [g |- ae_a (D1 ..) (D2 ..)] =>
  let [g |- E1 ..] = symG [g |- D1 ..] in
  let [g |- E2 ..] = symG [g |- D2 ..] in
    [g |- ae_a  (E1 ..)  (E2 ..)]
;

% ---------------------------------------------------------------------------
% Promotion lemmas (explicit)
datatype CtxRel : {g:daG} {h:xaG} {#W:g |- h} ctype = 
| Cnil : CtxRel [] [] [ |- ^ ] 
| Ccons: {g:daG}{h:xaG}{#W:h |- g}
         CtxRel [g] [h] [g |- #W[..] ] 
	 -> CtxRel [g, b:block (x:tm, u:aeq x x, v: deq x x)]
		   [h, b:block (x:tm, u:aeq x x)]
		   [g, b:block (x:tm, u:aeq x x, v: deq x x) |- #W[..] <b.1, b.2>]
;

datatype StrTm : (g:daG)[g |- tm] ->  ctype = 
| StrTm :  {g:daG}{h:xaG}{#W: h |- g} 
	  CtxRel [g] [h] [g |- #W[..] ] 
      -> {M: [h |- tm]} StrTm [g |- M #W[..] ];

datatype Ctx_daG : {g:daG} ctype = Ctx_daG : {g:daG} Ctx_daG [g] ;
datatype Ctx_xaG : {g:xaG} ctype = Ctx_xaG : {g:xaG} Ctx_xaG [g] ;

datatype EqCtx : {h:xaG} {h':xaG} ctype = 
| RefCtx : EqCtx [h] [h] ;

datatype EqSub : {g:daG}{h:xaG}{h':xaG} {#W:g |- h}{#W':g' |- h'} ctype = 
| RefSub : {g:daG}{h:xaG}  {#W: g |- h} 
		  EqSub [g] [h] [h] [g |- #W[..] ] [g |- #W[..] ] ;

rec deterministic_CtxRel : CtxRel [g] [h] [g |- #W[..] ] 
			   -> CtxRel [g] [h'] [g |- #W'[..] ] 
			   -> (EqCtx [h] [h'] * EqSub [g] [h] [h'] [g |- #W[..]] [g |- #W'[..]]) =
fn cr1 => fn cr2 => case (cr1 , cr2) of
| (Cnil , Cnil) => (RefCtx ,  RefSub [] [] [ |- ^ ])
| (Ccons [g] [h] [g |- #W[..] ] cr1, Ccons [g] [h'] [g |- #W'[..] ] cr2  ) => 
  let (RefCtx , RefSub [g] [h] [g |- #W[..] ] ) = deterministic_CtxRel cr1 cr2 in 
   (RefCtx , RefSub [g, b:block (x:tm, u:aeq x x, v: deq x x)]
		    [h, b:block (x:tm, u:aeq x x)]
		    [g, b:block (x:tm, u:aeq x x, v: deq x x) |- #W[..] <b.1, b.2>])
   ;

datatype Exists_xaG : {g:daG} ctype = 
| Exists_xaG : {h:xaG} CtxRel [g] [h] [g |- #W[..] ] -> Exists_xaG [g];

datatype Context_daG : {g:daG} ctype = 
| Context_daG : {g:daG} Context_daG [g];

rec exists_CtxRel : Context_daG [g] -> Exists_xaG [g] = 
fn g => case g of 
| Context_daG [ ] =>  Exists_xaG [] Cnil 
| Context_daG [g, b:block (x:tm, u:aeq x x, v:deq x x)] => 
  let Exists_xaG [h] cr = exists_CtxRel (Context_daG [g]) in 
  let (cr : CtxRel [g] [h] [g |- #W[..] ] ) = cr in 
  Exists_xaG [h, b:block (x:tm, u:aeq x x)] (Ccons [g] [h] [g |- #W[..] ] cr)
;

rec str_tm : {g:daG}{M:[g |- tm]} StrTm [g |- M .. ] = 
mlam g => mlam M => case [g |- M ..] of 
| [g,b:block (x:tm, ae_v: aeq x x, de_v:deq x x)  |-  b.1] => 
  let Exists_xaG [h] cr = exists_CtxRel (Context_daG [g]) in 
  let (cr : CtxRel [g] [h] [g |- #W[..] ] ) = cr in 
   StrTm [g, b:block (x:tm, u:aeq x x, v: deq x x)]
         [h, b:block (x:tm, u:aeq x x)]
	 [g, b:block (x:tm, u:aeq x x, v: deq x x) |- #W[..] < b.1, b.2 > ]
	 (Ccons [g] [h] [g |- #W[..] ] cr)
	 [h, b:block (x:tm, u:aeq x x) |-  b.1]

| [g,b:block (x:tm, ae_v: aeq x x, de_v:deq x x)  |-  N .. ] => 
  let StrTm [g] [h] [g |- #W[..] ] cr [h |- N' ..] 
      = str_tm [g] [g |- N ..] in 
     StrTm [g, b:block (x:tm, u:aeq x x, v: deq x x)]
         [h, b:block (x:tm, u:aeq x x)]
	 [g, b:block (x:tm, u:aeq x x, v: deq x x) |- #W[..] < b.1, b.2 > ]
	 (Ccons [g] [h] [g |- #W[..] ] cr)
	 [h, b:block (x:tm, u:aeq x x) |-  N' ..]


| [g |- lam \x. M .. x ] => 
 let {#W: h |- g}
     StrTm [g,b:block (x:tm, u:aeq x x,v:deq x x)]
           [h,b:block (x:tm, u:aeq x x)]
	   [g,b:block (x:tm, u:aeq x x,v:deq x x) |- #W[..] <b.1, b.2>]
           (Ccons [g] [h] [g |- #W[..] ] cr) [h, b:block (x:tm, u:aeq x x) |- M' .. b.1] = 
       str_tm [g, b:block (x:tm, u:aeq x x,v:deq x x)] [g,b:block (x:tm, u:aeq x x,v:deq x x) |- M .. b.1] in 
 StrTm [g] [h] [g |- #W[..] ] cr [h |- lam \y. M' .. y] 

| [g |- app (M ..) (N ..) ] => 
 let StrTm [g] [h] [g |- #W[..] ] cr [h |- M' ..] = str_tm [g] [g |- M ..] in 
  let StrTm [g] [h] [g |- #W'[..] ] cr' [h |- N' ..] = str_tm [g] [g |- N ..] in 
  let (RefCtx , RefSub [g] [h] [g |- #W[..]] ) = deterministic_CtxRel cr cr' in 
  StrTm [g] [h] [g |- #W[..] ] cr  [h |- app (M' ..) (N' ..)]
 ;

rec promote_refl : {g:daG}{M:[g |- tm]} [g |- aeq (M ..) (M ..)] = 
mlam g => mlam M => 
let StrTm [g] [h] [g |- #W[..] ] cr [h |- N ..] = str_tm [g] [g |- M ..]  in 
let [h |- D .. ] = reflG [h] [h |- N ..] in 
  [g |- D #W[..] ] 
;

datatype StrAeq : (g:daG){M:[g |- tm]}{N:[g |- tm]}[g |- aeq (M ..) (N ..)] ->  ctype = 
| StrAeq :  {g:daG}{h:xaG}{#W: h |- g} {M:[h |- tm]}{N:[h |- tm]}
  	    CtxRel [g] [h] [g |- #W[..] ] -> 
	    {D: [h |- aeq (M ..) (N ..)]}
	    StrAeq [g |- M #W[..]] [g |- N #W[..]] [g |- D #W[..]];

rec str_aeq : {g:daG}{M:[g |- tm]}{N:[g |- tm]}
	  {D: [g |- aeq (M ..) (N ..)]} StrAeq [g |- M ..] [g |- N ..] [g |- D ..] = 
mlam g => mlam M => mlam N => mlam D => case [g |- D ..] of 
| [g, b:block (x:tm, u:aeq x x, v:deq x x) |-  b.2] => 
  let Exists_xaG [h] cr = exists_CtxRel (Context_daG [g]) in 
  let (cr : CtxRel [g] [h] [g |- #W[..] ] ) = cr in 
  StrAeq [g, b:block (x:tm, u:aeq x x, v:deq x x)] 
	 [h, b:block (x:tm, u:aeq x x)] 
	 [g, b:block (x:tm, u:aeq x x, v:deq x x) |- #W[..] < b.1, b.2 > ]
	 [h, b:block (x:tm, u:aeq x x) |-  b.1]
	 [h, b:block (x:tm, u:aeq x x) |-  b.1]
	 (Ccons [g] [h] [g |- #W[..] ] cr)
	 [h, b:block (x:tm, u:aeq x x) |-  b.2]
 
| [g |- ae_a (D1 ..) (D2 ..) ] => 
 let StrAeq [g] [h] [g |- #W[..] ] 
            [h |- _ ] [h |- _ ] cr [h |- D1' ..] = str_aeq [g] [g |- _ ] [g |- _ ] [g |- D1 ..] in 
  let StrAeq [g] [h] [g |- #W'[..] ] 
             [h |- _ ] [h |- _ ] cr' [h |- D2' ..] = str_aeq [g] [g |- _ ] [g |- _ ] [g |- D2 ..] in 
  let (RefCtx , RefSub [g] [h] [g |- #W[..]] ) = deterministic_CtxRel cr cr' in 

  StrAeq [g] [h] [g |- #W[..] ] [h |- _ ] [h |- _ ] cr [h |- ae_a (D1' ..) (D2' ..)]

 
| {D:[g,x:tm, u:aeq x x |-  aeq (M .. x) (N .. x)]}
  [g |- ae_l (\x.\u. D .. x u) ] =>  
 let {#W:g |- h}
     StrAeq [g,b:block (x:tm, u:aeq x x,v:deq x x)]
            [h,b:block (x:tm, u:aeq x x)]
	    [g,b:block (x:tm, u:aeq x x,v:deq x x) |- #W[..] <b.1, b.2>]
            [h,b:block (x:tm, u:aeq x x)  |-  M' .. b.1 ]  [h,b:block (x:tm, u:aeq x x)  |-  N' .. b.1 ] 
           (Ccons [g] [h] [g |- #W[..] ] cr) 
            [h, b:block (x:tm, u:aeq x x) |- D' .. b.1 b.2] = 
       str_aeq [g, b:block (x:tm, u:aeq x x,v:deq x x)] 
	       [g,b:block (x:tm, u:aeq x x,v:deq x x) |- M .. b.1] 
	       [g,b:block (x:tm, u:aeq x x,v:deq x x) |- N .. b.1] 
               [g,b:block (x:tm, u:aeq x x,v:deq x x) |- D .. b.1 b.2]

 in 
 StrAeq [g] [h] [g |- #W[..] ] 
   [h |- lam \x.M' .. x ] [h |- lam \x.N' .. x ] cr [h |- ae_l \y.\u. D' .. y u] 

| {D:[g |- aeq (M ..) (N ..)]}
  [g, b:block (x:tm, u:aeq x x, v:deq x x) |-  D ..] => 
  let StrAeq [g] [h] [g |- #W[..] ] [h |- M' ..] [h |- N' ..] cr [h |- D' ..]
      = str_aeq [g] [g |- M ..] [g |- N ..] [g |- D ..] 
  in 
     StrAeq [g, b:block (x:tm, u:aeq x x, v: deq x x)]
         [h, b:block (x:tm, u:aeq x x)]
	 [g, b:block (x:tm, u:aeq x x, v: deq x x) |- #W[..] < b.1, b.2 > ]
	 [h, b:block (x:tm, u:aeq x x) |-  M' ..]
	 [h, b:block (x:tm, u:aeq x x) |-  N' ..]
	 (Ccons [g] [h] [g |- #W[..] ] cr)
	 [h, b:block (x:tm, u:aeq x x) |-  D' ..]
;


rec promote_sym : (g:daG) [g |- aeq (M ..) (N ..)] -> [g |- aeq (N ..) (M ..)] = 
fn d => 
let ([g |- D ..] : [g |- aeq (M ..) (N ..)]) = d in 
let StrAeq [g] [h] [g |- #W[..] ] [h |- M' ..] [h |- N' ..] cr [h |- D' ..] = 
    str_aeq [g] [g |- M ..] [g |- N ..] [g |- D ..] in 
let [h |- F ..] = symG [h |- D' ..] in 
  [g |- F #W[..] ]
;

datatype AndStrAeq :  (g:daG){M:[g |- tm]}{L:[g |- tm]}{N:[g |- tm]}
{D1:[g |- aeq (M ..) (L ..)]}{D2: [g |- aeq (L ..) (N ..)]} ctype = 
AndStrAeq : StrAeq [g |- M ..] [g |- L ..] [g |- D1 ..] -> 
	    StrAeq [g |- L ..] [g |- N ..] [g |- D2 ..]
	    -> AndStrAeq [g |- M ..] [g |- L ..] [g |- N ..] [g |- D1 ..] [g |- D2 ..];

rec promote_trans:  (g:daG) 
   [g |- aeq (M ..) (L ..)] -> [g |- aeq (L ..) (N ..)]   
 -> [g |- aeq (M ..) (N ..)]  = 
fn d1 => fn d2 => 
let ([g |- D1 ..] : [g |- aeq (M ..) (L ..)]) = d1 in 
let ([g |- D2 ..] : [g |- aeq (L ..) (N ..)]) = d2 in 
let str1  = str_aeq [g] [g |- M ..] [g |- _ ] [g |- D1 ..] in 
let str2  = str_aeq [g] [g |- L ..] [g |- _ ] [g |- D2 ..] in  
let AndStrAeq 
	(StrAeq [g] [h] [g |- #W[..] ] [h |- M' ..] [h |- L' ..] cr [h |- D1' ..])
	(StrAeq [g] [h] [g |- #W[..] ] [h |- L' ..] [h |- N' ..] cr' [h |- D2' ..]) 
 = AndStrAeq str1 str2 in 
  let [h |- F ..] = transG [h |- D1' ..] [h |- D2' ..] in 
  [g |- F #W[..] ]
 ;


% ---------------------------------------------------------------------------
% Completeness 

rec ceq: (g:daG)
         [g |- deq (M ..) (N ..)] -> [g |- aeq (M ..) (N ..)]  =
fn e => case e of 
| [g |- #p.3 ..] => [g |- #p.2 ..]
| [g |- de_r] => promote_refl [g] [g |- _  ]   
| [g |- de_a (D1 ..) (D2 ..)] => 
  let [g |- F1 ..] = ceq [g |- D1 ..] in 
  let [g |- F2 ..] = ceq [g |- D2 ..] in 
    [g |- ae_a (F1 ..) (F2 ..)]
					
| [g |- de_l (\x.(\u. (D .. x u)))] => 
  let [g,b:block x:tm, _t:aeq x x, u:deq x x |-  F .. b.1 b.2] = 
        ceq [g, b:block x:tm, _t:aeq x x, u:deq x x  |-  D .. b.1 b.3]
  in
     [g |- ae_l (\x.\v. F .. x v)]

| [g |- de_t (D1 ..) (D2 ..)] => 
  let [g |- F2 ..] = ceq [g |- D2 ..] in 
  let [g |- F1 ..] = ceq [g |- D1 ..] in 
    promote_trans [g |- F1 ..]  [g |- F2 ..]           

| [g |- de_s (D ..)] => 
  let [g |- F ..] = ceq [g |- D ..] in 
  promote_sym [g |- F ..]
;

