% coverage example:
%  context matching with dependent arguments

bool: type.
tt: bool.
ff: bool.

dep : bool -> type.
deptt : dep tt.
depff : dep ff.

depdep : {b:bool} dep b -> type.
depdeptt : depdep tt deptt.
depdepff : depdep ff depff.

schema dep-ctx = some [b:bool] dep b;
schema depdep-ctx = depdep tt deptt + depdep ff depff;
schema bool-ctx = bool;

%{
% these examples require context variable splitting, not yet implemented
rec depsplit : {g:bool-ctx} bool[g]  ->  bool[ ] =
fn d => case d of
 | [h, x:bool] U .. => [] tt
;

rec depsplit : {g:dep-ctx} (dep (B ..))[g]  ->  bool[ ] =
fn d => case d of
 | [h, x:dep (S ..)] U .. => [] tt
 | [h, x:dep tt] U .. => [] tt
 | [h, x:dep tt] U .. => [] tt
 | [h, x:dep tt, y:dep tt] U .. => [] ff
;

rec depdepsplit : {g:depdep-ctx} (dep (BQ ..))[g]  ->  bool[ ] =
fn d => case d of
 | [h, x : depdep tt deptt] U .. => [] tt
;

rec depsplit : {g:dep-ctx} (dep (B ..))[g]  ->  bool[ ] =
fn d => case d of
 | [h, x:dep tt] U .. => [] tt
 | [h, x:dep ff] U .. => [] ff
;

rec depsplitWrong : {g:dep-ctx} (dep (B ..))[g]  ->  bool[ ] =
fn d => case d of  %not
 | [h, x:dep tt] U .. => [] tt
;
}%


rec depsplitWrong1asdfasdfadsf : {g:dep-ctx} [g, x : dep T. bool]  ->  [. bool] =
mlam g => fn d => case d of %not
 | [g, xx:dep ff. UU .. xx] => [. ff]
;



rec depsplitWrong1 : {g:dep-ctx} [g, x : dep T. bool]  ->  [. bool] =
mlam g => fn d => case d of %not
 | [g, xx:dep ff. UU .. xx] => [. ff]
% | [g, xx:dep tt] VV .. xx => [] tt
%   msub': has the `ff' in `xx:dep ff'
;

rec depsplitOK1 : {g:dep-ctx} [g, x : dep T. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep ff. UU .. xx] => [. ff]
 | [g, xx:dep tt. VV .. xx] => [. tt]
;

rec depsplitTwoOK1 : {g:dep-ctx} [g, x : dep TX, y : dep TY. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep ff, yy:dep YY. UU .. xx yy] => [. ff]
 | [g, xx:dep tt, yy:dep YY. VV .. xx yy] => [. tt]
;

rec depsplitTwoOK2 : {g:dep-ctx} [g, x : dep TX, y : dep TY. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep XX1, yy:dep ff. UU .. xx yy] => [. ff]
 | [g, xx:dep XX2, yy:dep tt. VV .. xx yy] => [. tt]
;

rec depsplitTwoOK3 : {g:dep-ctx} [g, x : dep TX, y : dep TY. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep ff, yy:dep ff. UU .. xx yy] => [. ff]
 | [g, xx:dep ff, yy:dep tt. VV .. xx yy] => [. tt]
 | [g, xx:dep tt, yy:dep ff. WW .. xx yy] => [. ff]
 | [g, xx:dep tt, yy:dep tt. ZZ .. xx yy] => [. tt]
;

% 3 variables
rec depsplitManyOK : {g:dep-ctx} [g, x : dep TX, y : dep TY, a : dep TA. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep ff, yy:dep ff, aa:dep ff. UU .. xx yy aa] => [. ff]
 | [g, xx:dep ff, yy:dep ff, aa:dep tt. UU .. xx yy aa] => [. ff]

 | [g, xx:dep ff, yy:dep tt, aa:dep ff. UU .. xx yy aa] => [. ff]
 | [g, xx:dep ff, yy:dep tt, aa:dep tt. UU .. xx yy aa] => [. ff]

 | [g, xx:dep tt, yy:dep ff, aa:dep ff. UU .. xx yy aa] => [. ff]
 | [g, xx:dep tt, yy:dep ff, aa:dep tt. UU .. xx yy aa] => [. ff]

 | [g, xx:dep tt, yy:dep tt, aa:dep ff. UU .. xx yy aa] => [. ff]
 | [g, xx:dep tt, yy:dep tt, aa:dep tt. UU .. xx yy aa] => [. ff]
;


% 4 variables, to test splitting bounds
rec depsplitManyOK : {g:dep-ctx} [g, x : dep TX, y : dep TY, a : dep TA, b : dep TB. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep ff, yy:dep ff, aa:dep ff, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep ff, yy:dep ff, aa:dep ff, bb:dep tt. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep ff, yy:dep ff, aa:dep tt, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep ff, yy:dep ff, aa:dep tt, bb:dep tt. UU .. xx yy aa bb] => [. ff]

 | [g, xx:dep ff, yy:dep tt, aa:dep ff, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep ff, yy:dep tt, aa:dep ff, bb:dep tt. UU .. xx yy aa bb] => [. ff]
       | [g, xx:dep tt, yy:dep tt, aa:dep ff, bb:dep tt. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep ff, yy:dep tt, aa:dep tt, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep ff, yy:dep tt, aa:dep tt, bb:dep tt. UU .. xx yy aa bb] => [. ff]

 | [g, xx:dep tt, yy:dep ff, aa:dep ff, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep tt, yy:dep ff, aa:dep ff, bb:dep tt. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep tt, yy:dep ff, aa:dep tt, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep tt, yy:dep ff, aa:dep tt, bb:dep tt. UU .. xx yy aa bb] => [. ff]

 | [g, xx:dep tt, yy:dep tt, aa:dep ff, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep tt, yy:dep tt, aa:dep tt, bb:dep ff. UU .. xx yy aa bb] => [. ff]
 | [g, xx:dep tt, yy:dep tt, aa:dep tt, bb:dep tt. UU .. xx yy aa bb] => [. ff]
;


rec depsplitTwoWrong1 : {g:dep-ctx} [g, x : dep TX, y : dep TY. bool]  ->  [. bool] =
mlam g => fn d => case d of %not
 | [g, xx:dep XX1, yy:dep ff. UU .. xx yy] => [. ff]
;

rec depsplitTwoWrong2 : {g:dep-ctx} [g, x : dep TX, y : dep TY. bool]  ->  [. bool] =
mlam g => fn d => case d of %not
 | [g, xx:dep tt, yy:dep YY2. UU .. xx yy] => [. ff]
;



rec depsplitOK2 : {g:dep-ctx} [g, x : dep T. bool]  ->  [. bool] =
mlam g => fn d => case d of
 | [g, xx:dep WHATEVS. U .. xx] => [. tt]
;



% let ok_call = depsplitWrong [] ([x:dep tt] deptt);
%
% let bad_call = depsplitWrong [] ([x:dep ff] tt);
