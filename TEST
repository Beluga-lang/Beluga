#!/usr/bin/env bash

# Emit an error if undefined variable is used.
set -u

# Allow glob to match files and directories in subdirectories
shopt -s globstar
shopt -s nullglob

# Option flags.
declare FORCE_COLOR_OUTPUT=""
declare NO_EXAMPLES=""
declare ONLY_EXAMPLES=""
declare ONLY_INTERACTIVES=""
declare ONLY_HARPOON=""
declare PRINT_HARPOON_OUTPUT_ON_FAILURE=""
declare RESET_OUT_FILES=""
declare STOP_ON_FAILURE=""

declare -a BELUGA_FLAGS=()

# Path to the Beluga executable to test.
declare -r EXE=${EXE:-"./bin/beluga"}

# Path to the Beluga lex_check to test.
declare -r LEX_CHECK=${LEX_CHECK:-"./bin/lex_check"}

# Path to the Beluga replay to test.
declare -r REPLAY=${REPLAY:-"./bin/replay"}

# Path to the Harpoon to test.
declare -r HARPOON=${HARPOON:-"./bin/harpoon"}

declare -r TESTDIR=${TESTDIR:-"./t/code"}
declare -r EXAMPLEDIR=${EXAMPLEDIR:-"./examples"}
declare -r INTERACTIVE_TESTDIR=${INTERACTIVE_TESTDIR:-"./t/interactive"}
declare -r HARPOON_TESTDIR=${HARPOON_TESTDIR:-"./t/harpoon"}

declare -i TIMEOUT=${TIMEOUT:-10}

die () {
    echo "Fatal error: " "$@" >&2
    exit 1
}

require_program_exists () {
    command -v "$1" >/dev/null 2>&1 || die "program" "$1" "could not found."
}

for p in "${EXE}" "${LEX_CHECK}" "${REPLAY}" "${HARPOON}" ; do
    require_program_exists "${p}"
done

declare -A TEST_RESULT=(
    [total]=0
    [success]=0
    [timeout]=0
    [admissible]=0
    [fail]=0
    [lexer_fail]=0
    [replay_fail]=0
    [harpoon_fail]=0
)

declare -A C=(
    [start]=""
    [admissible]=""
    [ok]=""
    [timeout]=""
    [fail]=""
    [lex_fail]=""
    [added]=""
    [removed]=""
)
declare CEND=""

declare -Ar TYPE_TO_C=(
    [success]="ok"
    [timeout]="timeout"
    [admissible]="admissible"
    [fail]="fail"
    [lexer_fail]="lexer_fail"
    [replay_fail]="fail"
    [harpoon_fail]="fail"
)

function main {
    parse_opts "$@"
    if [[ -t 1 || -n "${FORCE_COLOR_OUTPUT}" ]]; then
        set_colors
    fi
    print_paths
    do_testing
}

function parse_opts {
    while [ "$#" -gt 0 ]; do
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
            -c|--colour|--color)
                FORCE_COLOR_OUTPUT="true"
                ;;
            --noexamples)
                NO_EXAMPLES="true"
                ;;
            --examples)
                ONLY_EXAMPLES="true"
                ;;
            --reset)
                RESET_OUT_FILES="true"
                ;;
            --interactive)
                ONLY_INTERACTIVES="true"
                ;;
            --harpoon)
                ONLY_HARPOON="true"
                ;;
            --printharpoon)
                PRINT_HARPOON_OUTPUT_ON_FAILURE="true"
                STOP_ON_FAILURE="true"
                ;;
            --stop)
                STOP_ON_FAILURE="true"
                ;;
            --)
                shift
                break
                ;;
            "")
                break
                ;;
            *)
                echo "Unrecognized option $1."
                echo "Make sure to write -- before any argument that should be passed to Beluga."
                exit 2
                ;;
        esac
        shift
    done

    BELUGA_FLAGS=("$@")
}

function do_testing {
    local exit_code=0 is_failed=0
    # Limit runtime of each test case, in seconds.
    ulimit -t "${TIMEOUT}"

    if [[ -z "${NO_EXAMPLES}" && -z "${ONLY_INTERACTIVES}" && -z "${ONLY_HARPOON}" ]]; then
        echo "===== EXAMPLES ====="

        for f in $(find_compiler_tests_in "${EXAMPLEDIR}"); do
            start_test_case "${f}"

            if ! lex_check_test_case "${f}"; then
                continue
            fi

            check_compiler_test_case "${f}"
        done
    fi

    if [[ -z "${ONLY_EXAMPLES}" && -z "${ONLY_INTERACTIVES}" && -z "${ONLY_HARPOON}" ]]; then
        echo "===== COMPILER TESTS ====="

        for f in $(find_compiler_tests_in "${TESTDIR}") ; do
            start_test_case "${f}"

            if ! lex_check_test_case "${f}"; then
                continue
            fi

            check_compiler_test_case "${f}"
        done
    fi

    if [[ -z "${ONLY_HARPOON}" ]]; then
        echo "===== INTERACTIVE MODE TESTS ====="

        for f in $(find "${INTERACTIVE_TESTDIR}" -type f | sort -n) ; do
            start_test_case "${f}"

            local output="$(${REPLAY} "${EXE}" "${f}")"
            exit_code=$?

            if [ "${exit_code}" -eq 152 ] ; then
                process_result "timeout" "TIMEOUT"
            elif [ "${exit_code}" -ne 0 ] ; then
                process_result "replay_fail" "FAIL"
                echo "${output}"
            else
                process_result "success" "OK"
            fi
        done
    fi

    echo "===== HARPOON MODE TESTS ====="

    for f in $(find "${HARPOON_TESTDIR}" -type f -name "*.input" | sort -n) ; do
        start_test_case "${f}"

        check_harpoon "${f}"
    done

    echo
    echo "Successes: ${TEST_RESULT[success]}"
    echo "Failures: ${TEST_RESULT[fail]}"
    echo "Lexer failures: ${TEST_RESULT[lexer_fail]}"
    echo "Admissible failures: ${TEST_RESULT[admissible]}"
    echo "Timeouts: ${TEST_RESULT[timeout]}"
    echo "Interactive mode failures: ${TEST_RESULT[replay_fail]}"
    echo "Harpoon mode failures: ${TEST_RESULT[harpoon_fail]}"
    echo "Total: ${TEST_RESULT[total]}"
    echo
    times

    (( is_failed=TEST_RESULT[fail] + TEST_RESULT[timeout] + TEST_RESULT[lexer_fail] + TEST_RESULT[replay_fail] + TEST_RESULT[harpoon_fail] ))
    # If not all tests succeeded then exit with non-zero status.
    # double-negate the failure count to get 0 if it was zero, and
    # 1 if it was nonzero.
    exit $(( ! ! is_failed ))
}

function lex_check_test_case {
    local -r file_path=$1

    local exit_code

    ${LEX_CHECK} "${file_path}" > /dev/null 2>&1
    exit_code=$?

    if [ "${exit_code}" -eq 2 ] ; then
        process_result "lexer_fail" "FATAL LEXER FAILURE"
        stop_on_failure
        return 1
    fi

    if [ "${exit_code}" -ne 0 ] ; then
        process_result "lexer_fail" "LEXER FAILURE"
        stop_on_failure
        return 1
    fi

    return 0
}

function check_compiler_test_case {
    local -r file_path=$1

    local output exit_code diff_output diff_code

    # ${...[@]+${...[@]}} is a workaround for bash < 4.4
    # In bash < 4.4, array without an item is considered as an undefined variable.
    output=$(${EXE} +test "${BELUGA_FLAGS[@]+${BELUGA_FLAGS[@]}}" "${file_path}" 2>&1)
    exit_code=$?
    diff_output=$(printf "%s" "${output}" | diff -b -u "${file_path}.out" - 2>/dev/null)
    # diff responds 0 if same, 1 if different, 2 if couldn't compare.
    diff_code=$?

    if [ "${exit_code}" -eq 152 ];then
        process_result "timeout" "TIMEOUT"
        stop_on_failure
    elif [[ "${diff_code}" -eq 0 || ("${exit_code}" -eq 0 && "${diff_code}" -eq 2) ]]; then
        process_result "success" "OK"
    else
        if grep -q "${file_path}" .admissible-fail ; then
            process_result "admissible" "ADMISSIBLE"
        else
            process_result "fail" "FAIL"

            if [ -z "${diff_output}" ]; then
                echo "${output}"
            else
                echo "${diff_output}" | colorize_diff
            fi

            stop_on_failure
        fi
    fi

    if [[ -n "${RESET_OUT_FILES}" && -f "${file_path}.out" ]]; then
        echo "${output}" > "${file_path}.out"
    fi
}

function check_harpoon {
    local -r file_path=$1

    local output exit_code

    output=$(./run_harpoon_test.sh "${file_path}" --stop 2>&1)
    check_harpoon_output "${output}"
    exit_code=$?

    if [ "${exit_code}" -eq 152 ] ; then
        process_result "timeout" "TIMEOUT"
        stop_on_failure
    elif [ "${exit_code}" -ne 0 ] ; then
        process_result "harpoon_fail" "FAIL"
        print_harpoon_output_on_failure "${output}"
        stop_on_failure
    else
        process_result "success" "OK"
    fi
}

function check_harpoon_output {
    local -r output=$1
    local -r proof_complete_message="Proof complete! (No theorems left.)"
    local -r uncaught_exception_message="Uncaught exception"
    local -r parse_error_message="Parse error"
    local -r internal_error_message="Internal error"

    if ! grep -q "${proof_complete_message}" <(echo "${output}"); then
        return 1
    fi

    if grep -q "${uncaught_exception_message}" <(echo "${output}"); then
        return 1
    fi

    if grep -q "${parse_error_message}" <(echo "${output}"); then
        return 1
    fi

    if grep -q "${internal_error_message}" <(echo "${output}"); then
        return 1
    fi

    return 0
}

function start_test_case {
    local -r file_path=$1

    (( TEST_RESULT[total]+=1 ))
    echo -ne "${C[start]}**${CEND} TEST ${TEST_RESULT[total]}: ${file_path} ... "
}

function process_result {
    local -r type=$1 message=$2

    local -r color=${TYPE_TO_C[${type}]}

    echo -e "${C[${color}]}${message}${CEND}"
    (( TEST_RESULT[${type}]+=1 ))
}

function print_harpoon_output_on_failure {
    local -r output=$1

    if [ -n "${PRINT_HARPOON_OUTPUT_ON_FAILURE}" ]; then
        echo "${output}"
    fi
}

function stop_on_failure {
    if [ -n "${STOP_ON_FAILURE}" ]; then
        exit 1
    fi
}

function find_compiler_tests_in {
    local -a tests

    for dir in "$1"/**/; do
        tests=("${dir}"*.cfg)
        if [ "${#tests[@]}" -eq 0 ]; then
            tests=("${dir}"*.bel)
        fi

        if [ "${#tests[@]}" -gt 0 ]; then
            printf "%s\n" "${tests[@]}"
        fi
    done | sort -n
}

function usage {
    echo "Usage: $0 [test-options] -- [beluga-options]"
    echo
    echo "Synopsis: test harness for Beluga."
    echo
    echo "Options:"
    echo "  -h,--help        Display this usage information."
    echo "  -c,--color       Force colorized output even when piped."
    echo "  --noexamples     Do not also test ${EXAMPLEDIR}."
    echo "  --examples       Only test ${EXAMPLEDIR}."
    echo "  --interactive    Only test the interactive mode."
    echo "  --harpoon        Only test the harpoon mode."
    echo "  --printharpoon   Print harpoon output of a test when the test is failed."
    echo "                   This option implies --stop."
    echo "  --reset          Replace all .out files with new output (use with caution!)."
    echo "  --stop           Stop on the first failed test."
    echo
    echo "Notes:"
    echo "  - If any .cfg files are found in a subdirectory, only them will be tested."
    echo "  - If no .cfg file is found, all .bel files in the subdirectory"
    echo "    will be tested."
    echo "  - To inhibit testing .bel files, put an empty test.cfg in that directory."
}

function print_paths {
    echo "Parameters for this run (override as necessary using environment variables):"
    echo
    echo -e "\t EXE: ${EXE}"
    echo -e "\t LEX_CHECK: ${LEX_CHECK}"
    echo -e "\t REPLAY: ${REPLAY}"
    echo -e "\t TESTDIR: ${TESTDIR}"
    echo -e "\t INTERACTIVE_TESTDIR: ${INTERACTIVE_TESTDIR}"
    echo -e "\t EXAMPLEDIR: ${EXAMPLEDIR}"
    echo -e "\t TIMEOUT: ${TIMEOUT}" seconds
    echo
}

function set_colors {
    C[start]="\x1b[34m"              # foreground blue
    C[admissible]="\x1b[01;33m"      # foreground bold yellow
    C[ok]="\x1b[01;32m"              # foreground bold green
    C[timeout]="\x1b[01;35m"         # foreground bold magenta
    C[fail]="\x1b[01;31m"            # foreground bold red
    C[lexer_fail]="\x1b[01;36m"      # foreground bold cyan
    C[added]="\x1b[32m"              # foreground green
    C[removed]="\x1b[31m"            # foreground red
    CEND="\x1b[00m"                     # reset colors
}

function colorize_diff {
    sed "s/^+/${C[added]}+/
         s/^-/${C[removed]}-/
         s/\$/${CEND}/"
}

main "$@"
