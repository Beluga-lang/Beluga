% Completeness of algorithmic equality for declarative equality for simply typed lambda calculus
% Accompanies Mechanizing Logical Relations using Contextual Type Theory
% by Andrew Cave and Brigitte Pientka

tp : type.         %name tp T.
i :  tp.
arr: tp -> tp -> tp.

tm : type.          %name tm E.
app : tm -> tm -> tm.
lam : (tm -> tm) -> tm.

schema ctx = tm;

tctx : type.
nil : tctx.
& : tctx -> tp -> tctx.

%infix & 5 right.

step : tm -> tm -> type.  %name step S.
beta : step (app (lam M) N) (M N).
stepapp : step M M' -> step (app M N) (app M' N).

mstep : tm -> tm -> type.  %name mstep S.
refl : mstep M M.
trans1 : step M M' -> mstep M' M'' -> mstep M M''.

datatype CtxRel : {G:[|-tctx]}{g:ctx} ctype  #positive =
| RNil : CtxRel [|- nil] []
| RCons : CtxRel [|- G] [g] -> CtxRel [|- G & T] [g,x:tm];

datatype Lookup : {G:[|-tctx]}(g:ctx)[g |-  tm] -> [ |- tp] -> ctype #positive =
| Top : Lookup [|- G & T] [g,x:tm |-  x] [ |- T]
| Pop : Lookup [|- G] [g |- #p[..]] [ |- T]
      -> Lookup [|- G & S] [g,x:tm |- #p[..]] [ |- T];

% Generalize Pop to all terms for convenience
rec pop' : Lookup [|- G] [g |- M[..]] [ |- T]
         -> Lookup [|- G & S] [g,x:tm |- M[..]] [ |- T] =
/ total r (pop' g g m t s r)/
fn r => case r of
| Top => Pop Top
| Pop v => Pop (Pop v);

% Algorithmic equality of terms. _|-_<=>_:_ in the paper
datatype AlgEqN : {G:[|- tctx]}(g:ctx) [g |-  tm] -> [g |- tm] -> [ |- tp] -> ctype #positive =
| AlgBase : [g |-  mstep (M[..]) (P[..])]
          -> [g |-  mstep (N[..]) (Q[..])]
          -> AlgEqR [|- G] [g |-  P[..]] [g |-  Q[..]] [ |- i]
          -> AlgEqN [|- G] [g |-  M[..]] [g |-  N[..]] [ |- i]
| AlgArr :  AlgEqN [|- G & T] [g,x:tm |-  app (M[..]) x] [g,x |-  app (N[..]) x] [ |- S]
          -> AlgEqN [|- G] [g |- (M[..])] [g |- (N[..])] [ |- arr T S]
% Algorithmic equality of paths. _|-_<->_:_ in the paper
and      AlgEqR : {G:[|-tctx]}(g:ctx) [g |-  tm] -> [g |- tm] -> [ |- tp] -> ctype #positive =
| AlgVar : Lookup [|- G] [g |-  #p[..]] [|- T]
         -> AlgEqR [|- G] [g |-  #p[..]] [g |-  #p[..]] [ |- T]
| AlgApp : AlgEqR [|- G] [g |-  M1[..]] [g |-  M2[..]] [ |- arr T S]
         -> AlgEqN [|- G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
         -> AlgEqR [|- G] [g |-  app (M1[..]) (N1[..])] [g |-  app (M2[..]) (N2[..])] [ |- S]
;

% Well-typed variable-for-variable substitutions (renaming substitutions). _|-v_:_ in the paper
datatype IsVarSub : {G:[|-tctx]}{g:ctx}{H:[|-tctx]}(h:ctx) {#S: h |- g}ctype #positive =
| Nil : IsVarSub [|- nil] [] [|- H] [h |- ^ ]
| Cons :  IsVarSub [|- G] [g] [|- H] [h |- #S[..]] -> Lookup [|- H] [h |-  M[..]] [ |- A]
         -> IsVarSub [|- G & A] [g,x:tm] [|- H] [h |- #S[..], (M[..])];


% Logical equivalence. _|-_~~_:_ in the paper
datatype LogEq : {G:[|-tctx]}(g:ctx) [g |-  tm] -> [g |-  tm] -> [ |- tp] -> ctype  #stratified =
| LogBase : AlgEqN [|- G] [g |- M[..]] [g |- N[..]] [ |- i]
          -> LogEq [|- G] [g |- M[..]] [g |- N[..]] [ |- i]
| LogArr  : {M1:[g |- tm]}{M2:[g |- tm]}
             ({H:[|-tctx]}{h:ctx} {#R:h |- g} {N1:[h |- tm]}{N2:[h |- tm]}
                CtxRel [|- H] [h] ->
                IsVarSub [|- G] [g] [|- H] [h |- #R[..]] ->
                LogEq [|- H] [h |- N1[..]] [h |-  N2[..]] [ |- T]
              -> LogEq [|- H] [h |- app (M1 #R[..]) (N1[..])] [h |-  app (M2 #R[..]) (N2[..])] [ |- S])
            -> LogEq [|- G] [g |-  M1[..]] [g |-  M2[..]] [ |- arr T S]
;

% Half a dozen straightforward constructions on renaming substitutions:
rec wknVar : Lookup [|- G] [g |- M[..]] [ |- A] -> IsVarSub [|- G] [g] [|- H] [h |- #W[..]]
 -> Lookup [|- H] [h |- M #W[..]] [ |- A]=
 / total v (wknVar g g0 h h0 w m a v ) /
fn iv => fn ivs => case iv of
| Top =>    let Cons ivs' iv = ivs in iv
| Pop iv' => let Cons ivs' iv = ivs in wknVar iv' ivs';

% Composition of renaming is still renaming
rec renCompose : IsVarSub [|- G] [g] [|- H] [h |- #W[..]]
                   -> IsVarSub [|- H] [h] [|- H0] [h0 |- #W2[..]]
                   -> IsVarSub [|- G] [g] [|- H0] [h0 |- #W[#W2[..]]] =
/ total r1 (renCompose g g h h w h0 h0' w2 r1) /
fn r1 => fn r2 => case r1 of
| Nil => Nil
| Cons ivs' iv => Cons (renCompose ivs' r2) (wknVar iv r2);

% Weakening a renaming is still a renaming

rec wknVarSub : IsVarSub [|- G] [g] [|- H] [h |- #S[..]]
 -> IsVarSub [|- G] [g] [|- H & T] [h,x:tm |- #S[..] ] =
/ total r (wknVarSub _ _ _ _ _ _ r )/
fn r => case r of
| Nil => Nil
| Cons r' v => Cons (wknVarSub r') (pop' v);

% Extending a renaming with a fresh variable is still a renaming
rec extVarSub : IsVarSub [|-G] [g] [|-H] [h |- #S[..]]
 -> IsVarSub [|- G & A] [g,x:tm] [|- H & A] [h,x:tm |- #S[..] , x ] =
/ total (extVarSub)/
fn r => let r : IsVarSub [|-G] [g] [|-H] [h |- #S[..]] = r in Cons (wknVarSub r) Top;

% The identity substitution is a renaming
rec idIsVarSub : CtxRel [|-G] [g] -> IsVarSub [|-G] [g] [|-G] [g |-[..] ] =
/ total r (idIsVarSub g g r) /
fn r => case r of
| RNil => Nil
| RCons r' => extVarSub (idIsVarSub r');

% The shift substitution (weakening substitution) is a renaming
rec shiftIsRen : CtxRel [|-G] [g] -> IsVarSub [|-G] [g] [|- G & A] [g,x:tm |-[..] ] =
/ total (shiftIsRen) /
fn r => wknVarSub (idIsVarSub r);

% Generalizing AlgVar to terms
rec algVar : Lookup [|-G] [g |-  M[..]] [ |- T] -> AlgEqR [|-G] [g |-  M[..]] [g |-  M[..]] [ |- T] =
/ total iv (algVar _ _ _ _ iv) /
fn iv => case iv of
| Top => AlgVar Top
| Pop iv' => let AlgVar v = algVar iv' in AlgVar (Pop v);

% Monotonicity of algorithmic equivalence
rec algEqR_Monotone :   IsVarSub [|-G] [g] [|-H] [h |- #W[..]]
                      -> AlgEqR [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A]
                      -> AlgEqR [|-H] [h |-  M1 #W[..]] [h |-  M2 #W[..]] [ |- A] =
/ total r (algEqR_Monotone g g h h w m1 m2 a iv r) / 
fn iv => fn r => case r of
| AlgVar v => algVar (wknVar v iv)
| AlgApp r' n' => AlgApp (algEqR_Monotone iv r') (algEqN_Monotone iv n')
and algEqN_Monotone : IsVarSub [|-G] [g] [|-H] [h |- #W[..]]
                    -> AlgEqN [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A]
                    -> AlgEqN [|-H] [h |-  M1 #W[..]] [h |-  M2 #W[..]] [ |- A] =
/ total r (algEqN_Monotone g g h h w m1 m2 a iv r) / 
fn iv => let iv : IsVarSub [|-H] [g] [|-H] [h |- #W[..]] = iv in fn r => case r of
| AlgBase [g |-  S1[..]] [g |-  S2[..]] r' => AlgBase [h |-  S1 #W[..]] [h |-  S2 #W[..]] (algEqR_Monotone iv r')
| AlgArr r'' => AlgArr (algEqN_Monotone (extVarSub iv) r'')
;

% Monotonicity of logical equivalence
rec logEq_Monotone : IsVarSub [|-G] [g] [|-H] [h |- #W[..]]
                   -> LogEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A]
                   -> LogEq [|-H] [h |-  M1 #W[..]] [h |-  M2 #W[..]] [ |- A] =
/ total e (logEq_Monotone g g h h w m1 m2 a iv e) /
fn iv => let iv : IsVarSub [|-G] [g] [|-H] [h |- #W[..]] = iv in fn e => case e of
| LogBase v => LogBase (algEqN_Monotone iv v)
| LogArr [g |-  M1[..]] [g |-  M2[..]] f =>
  LogArr [h |-  M1 #W[..]] [h |-  M2 #W[..]]
   (mlam H0 => mlam h0' => mlam #W2 => mlam N1 => mlam N2 => fn rh => fn iv' => fn rn =>
    f [|- H0] [h0'] [h0' |- #W[#W2[..]]] [h0' |-  N1[..]] [h0' |-  N2[..]] rh (renCompose iv iv') rn
   )
;

% Main lemma to escape logical relation
rec reflect : {A:[ |- tp]} AlgEqR [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] -> LogEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] =
/ total a (reflect g g m1 m2 a) /
mlam A => fn r => case [ |- A] of
| [ |- i] => 
  let r : AlgEqR [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] = r in
    LogBase (AlgBase [g |-  refl] [g |-  refl] r)
| [ |- arr A B] =>
  let r : AlgEqR [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] = r in
  LogArr [g |-  M1[..]] [g |-  M2[..]]
   (mlam h => mlam h => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
    reflect [ |- B] (AlgApp (algEqR_Monotone iv r) (reify rh rn))
   )
and reify : CtxRel [|-G] [g] -> LogEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] -> AlgEqN [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] = 
 / total e (reify g g m1 m2 a r e) /
fn r => fn e => let e : LogEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- A] = e in case e of
| LogBase a => a
| LogArr [g |-  M1[..]] [g |-  M2[..]] f =>
  AlgArr (reify (RCons r) (f [|- G & _] [g,x:tm] [g,x |-[..]] [g,x |-  x] [g,x |-  x]
                (RCons r) (shiftIsRen r) (reflect [ |- _] (AlgVar Top))))
;

% Declarative equality. Written _|-_=_:_ in the paper
datatype DecEq : {G:[|-tctx]}(g:ctx) [g |-  tm] -> [g |- tm] -> [ |- tp] -> ctype
#positive =
| DecBeta : DecEq [|- G & T] [g,x:tm |-  M2] [g,x |-  N2] [ |- S]
          -> DecEq [|-G] [g |-  M1[..]] [g |-  N1[..]] [ |- T]
          -> DecEq [|-G] [g |-  (app (lam (\x. M2)) (M1[..]))] [g |-  N2[..] (N1[..])] [ |- S]
| DecLam :  DecEq [|- G & T] [g,x:tm |-  M] [g,x |-  N] [ |- S]
          -> DecEq [|-G] [g |-  lam (\x. M)] [g |-  lam (\x. N)] [ |- arr T S]
| DecExt :  DecEq [|- G & T] [g,x:tm |-  app (M[..]) x] [g,x |-  app (N[..]) x] [ |- S]
          -> DecEq [|-G] [g |-  (M[..])] [g |-  (N[..])] [ |- arr T S]
| DecVar : Lookup [|-G] [g |-  #p[..]] [ |- T]
         -> DecEq [|-G] [g |-  #p[..]] [g |-  #p[..]] [ |- T]
| DecApp : DecEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- arr T S]
         -> DecEq [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
         -> DecEq [|-G] [g |-  app (M1[..]) (N1[..])] [g |-  app (M2[..]) (N2[..])] [ |- S]
| DecSym : DecEq [|-G] [g |-  M[..]] [g |-  N[..]] [ |- T]
         -> DecEq [|-G] [g |-  N[..]] [g |-  M[..]] [ |- T]
| DecTrans : DecEq [|-G] [g |-  M[..]] [g |-  N[..]] [ |- T]
           -> DecEq [|-G] [g |-  N[..]] [g |-  O[..]] [ |- T]
           -> DecEq [|-G] [g |-  M[..]] [g |-  O[..]] [ |- T]
;

% Logical equivalence of substitutions. Written _|-s_~~_:_ in the paper
datatype LogEqSub : {G:[|-tctx]}{g:ctx}{H:[|-tctx]}(h:ctx){#S1: h |- g}{#S2: h |- g}
ctype #positive =
| Nil : LogEqSub [|- nil] [] [|-H] [h |- ^] [h |- ^]
| Dot : LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]] -> LogEq [|-H] [h |-  M1[..]] [h |-  M2[..]] [ |- T]
      -> LogEqSub [|- G & T] [g,x:tm] [|-H] [h |- #S1[..] (M1[..])] [h |- #S2[..] (M2[..])]
;

% Monotonicity of logical equivalence on substitutions
rec wknLogEqSub :
  IsVarSub [|-H] [h] [|-H0] [h0' |- #W[..]]
-> LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]]
-> LogEqSub [|-G] [g] [|-H0] [h0' |- #S1[#W[..]]] [h0' |- #S2[#W[..]]] =
 / total es (wknLogEqSub _ _ _ _ _ _ _ _ _ iv es )/
fn iv => fn es => case es of
| Nil => Nil
| Dot rs' rN => Dot (wknLogEqSub iv rs') (logEq_Monotone iv rN)
;

% Transitivity of mstep
rec mstep_trans : (g:ctx) [g |-  mstep (M[..]) (N[..])] -> [g |-  mstep (N[..]) (P[..])] -> [g |-  mstep (M[..]) (P[..])] =
/ total s1 (mstep_trans g m n p s1 s2) /
fn s1 => fn s2 => case s1 of
| [g |-  refl] => let [g |-  S2[..]] = s2 in [g |-  S2[..]]
| [g |-  trans1 (S1[..]) (MS1[..])] => let [g |-  MSR[..]] = mstep_trans [g |-  MS1[..]] s2 in
  [g |-  trans1 (S1[..]) (MSR[..])]
;

% Boxed form of trans1 for convenience
rec trans1' : (g:ctx) [g |-  step (M[..]) (N[..])] -> [g |-  mstep (N[..]) (P[..])] -> [g |-  mstep (M[..]) (P[..])] =
/ total (trans1') / 
fn s1 => fn s2 => case (s1,s2) of
| ([g |-  S[..]], [g |-  MS[..]]) => [g |-  trans1 (S[..]) (MS[..])]
;

% multi-step reduction under the function position of application
rec mstep_app : (g:ctx) [g |-  mstep (M[..]) (N[..])] -> [g |-  mstep (app (M[..]) (P[..])) (app (N[..]) (P[..]))] =
/ total s1 (mstep_app g m n p s1) /
fn s1 => case s1 of
| [g |-  refl] => [g |-  refl]
| [g |-  trans1 (S[..]) (MS[..])] => trans1' [g |-  stepapp (S[..])] (mstep_app [g |-  MS[..]]);



% Logical equality is backward closed under weak head reduction
% Induction is on T. Make T explicit
rec closed : {T:[|- tp]} [g |-  mstep (N1[..]) (M1[..])] -> [g |-  mstep (N2[..]) (M2[..])]
  -> LogEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- T]
  -> LogEq [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T] =
 / total t (closed g g n1 m1 n2 m2 t) / 
mlam T => fn s1 => fn s2 => fn e => case [|- T] of 
| [|- i] => 
  let LogBase (AlgBase [g |-  S1'[..]] [g |-  S2'[..]] a) = e in
  LogBase (AlgBase (mstep_trans s1 [g |-  S1'[..]]) (mstep_trans s2 [g |-  S2'[..]]) a)
| [|- arr T1 T2] => 
  let LogArr [g |-  M1[..]] [g |-  M2[..]] f = e in 
  let [g |-  S1[..]] = s1 in
  let [g |-  S2[..]] = s2 in
  LogArr [g |-  _] [g |-  _] (mlam H => mlam h => mlam #W => mlam P1 => mlam P2 => fn rh => fn iv => fn rp =>
   let q0 = f [|-H] [h] [h |- #W[..]] [h |-  P1[..]] [h |-  P2[..]] rh iv rp in
   closed [|- T2] (mstep_app [h |-  S1 #W[..]] ) (mstep_app [h |-  S2 #W[..]]) q0
  );

% Looking up a variable in logically equivalence substitutions gives a logical equivalence
rec lookup : Lookup [|-G] [g |-  M1[..]] [ |- T]
 -> LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]]
 -> LogEq [|-H] [h |-  M1 #S1[..]] [h |-  M1 #S2[..]] [ |- T] =
/ total v (lookup _ _ _ _ _ _ _ _ v) /
fn v => fn s => case v of
| Top =>    let Dot s' e = s in e
| Pop v' => let Dot s' e = s in lookup v' s'
;

% Symmetry of algorithmic equivalence
rec algEqRSym :
  AlgEqR [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
-> AlgEqR [|-G] [g |-  N2[..]] [g |-  N1[..]] [ |- T] =
/ total a (algEqRSym g g n1 n2 t a) /
fn a => case a of
| AlgVar v => AlgVar v
| AlgApp a1 a2 => AlgApp (algEqRSym a1) (algEqNSym a2)
and algEqNSym :
  AlgEqN [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
-> AlgEqN [|-G] [g |-  N2[..]] [g |-  N1[..]] [ |- T] =
/ total a (algEqNSym g g n1 n2 t a) /
fn a => case a of
| AlgBase s1 s2 a' => AlgBase s2 s1 (algEqRSym a')
| AlgArr a' => AlgArr (algEqNSym a')
;

% Symmetry of logical equivalence
rec logEqSym :
   {T:[|- tp]}LogEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- T]
 -> LogEq [|-G] [g |-  M2[..]] [g |-  M1[..]] [ |- T] =
/ total t (logEqSym g g m1 m2 t) /
mlam T => fn e => case [|- T] of 
| [|- i] => 
  let LogBase a = e in  LogBase (algEqNSym a)
| [|- arr T1 T2] => 
  let LogArr [g |-  M1[..]] [g |-  M2[..]] f = e in 
  LogArr [g |-  M2[..]] [g |-  M1[..]] (mlam H => mlam h => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
					let e' = logEqSym [|- T1] rn in 
					logEqSym [|- T2] (f [|-H] [h] [h |- #W[..]] [h |-  N2[..]] [h |-  N1[..]] rh iv e')
				       );

% Symmetry of logical equivalence on substitutions
rec logEqSubSym :
   LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]]
 -> LogEqSub [|-G] [g] [|-H] [h |- #S2[..]] [h |- #S1[..]] =
 / total e (logEqSubSym g g h h sigma sigma' e) /
fn e => case e of
| Nil => Nil
| Dot e' e1 => Dot (logEqSubSym e') (logEqSym  [|- _ ] e1);

% Several of the following lemmas are to establish transitivity of algorithmic equivalenc

% Equality on types
datatype EqTp : [ |- tp] -> [ |- tp] -> ctype #positive =
| ReflTp : EqTp [ |- T] [ |- T];

% Lookup produces unique types
rec varEqUnique :
  Lookup [|-G] [g |-  M[..]] [ |- T]
-> Lookup [|-G] [g |-  M[..]] [ |- S]
-> EqTp [ |- T] [ |- S] = 
/ total e1 (varEqUnique g g m t s e1 e2)/
fn e1 => fn e2 => case e1 of
| Top => let Top = e2 in ReflTp
| Pop e1' => let Pop e2' = e2 in varEqUnique e1' e2'
;

% The types from algorithmic path equivalence are uniquely determined
rec algEqRUnique :
  AlgEqR [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
-> AlgEqR [|-G] [g |-  N2[..]] [g |-  N3[..]] [ |- S]
-> EqTp [ |- T] [ |- S] =
/ total e1 (algEqRUnique g g n1 n2 n3 t s e1) / 
fn e1 => fn e2 => case e1 of 
| AlgVar e1' => 
  let AlgVar e2' = e2 in 
   varEqUnique e1' e2'
| AlgApp a1 a2 => 
  let AlgApp b1 b2 = e2 in 
  let ReflTp = algEqRUnique a1 b1 in ReflTp
;

% Equality of terms
datatype EqTm : (g:ctx) [g |-  tm] -> [g |-  tm] -> ctype =
| ReflTm : EqTm [g |-  M[..]] [g |-  M[..]];

% Determinacy of weak head reduction
rec determinacy : (g:ctx) [g |-  step (M[..]) (N[..])] -> [g |-  step (M[..]) (P[..])] -> EqTm [g |-  N[..]] [g |-  P[..]] = 
/ total s1 (determinacy g m n p s1) /
fn s1 => fn s2 => case s1 of
| [g |-  beta] => let [g |-  beta] = s2 in ReflTm
| [g |-  stepapp (S1[..])] => 
  let [g |-  stepapp (S2[..])] = s2 in 
  let ReflTm = determinacy [g |-  S1[..]] [g |-  S2[..]] in ReflTm
;

datatype HasCommonReduct : (g:ctx) [g |-  tm] -> [g |-  tm] -> ctype =
| Common : [g |-  mstep (M1[..]) (N[..])] -> [g |-  mstep (M2[..]) (N[..])] -> HasCommonReduct [g |-  M1[..]] [g |-  M2[..]];

% Confluence is trivial because it's deterministic. This is just a convenient
% way to work with determinacy
rec confluence : [g |-  mstep (M[..]) (N[..])] -> [g |-  mstep (M[..]) (P[..])] ->
                 HasCommonReduct [g |-  N[..]] [g |-  P[..]] =
/ total s1 (confluence g m n p s1) /
fn s1 => fn s2 => case s1 of
| [g |-  refl ] => Common s2 [g |-  refl]
| [g |-  trans1 (S1[..]) (MS1[..])] =>
  case s2 of 
  | [g |-  refl] => Common [g |-  refl] s1
  | [g |-  trans1 (S2[..]) (MS2[..])] => 
    let ReflTm = determinacy [g |-  S1[..]] [g |-  S2[..]] in
    confluence [g |-  MS1[..]] [g |-  MS2[..]]
;

datatype empty : type =;

% Terms in algorithmic path equivalence cannot step
rec neutral_doesnt_step :
  [g |-  step (M[..]) (N[..])]
-> AlgEqR [|-G] [g |-  M[..]] [g |-  P[..]] [ |- T]
-> [ |- empty] =
/ total s (neutral_doesnt_step g g m n p t s ) /
fn s => fn e => case e of 
| AlgApp r n => 
  (case r of 
   | AlgVar v' => let [g |- stepapp (S[..])] = s in neutral_doesnt_step [g |-  S[..]] r
   | AlgApp r' n' => let [g |- stepapp (S[..])] = s in neutral_doesnt_step [g |-  S[..]] r
 )
| AlgVar v => impossible s
;

% Similarly for multi-step reduction
rec neutral_mstep :
  [g |-  mstep (M[..]) (N[..])]
-> AlgEqR [|-G] [g |-  M[..]] [g |-  P[..]] [ |- T]
-> EqTm [g |-  M[..]] [g |-  N[..]] =
/ total  (neutral_mstep) /
fn s => fn e => case s of
| [g |-  refl] => ReflTm
| [g |-  trans1 (S1[..]) (MS[..])] => impossible (neutral_doesnt_step [g |-  S1[..]] e) in [];

% Corollary of determinacy
rec determinacy' :
  [g |-  mstep (M[..]) (M1[..])] -> [g |-  mstep (M[..]) (M2[..])]
-> AlgEqR [|-G] [g |-  N1[..]] [g |-  M1[..]] [ |- T]
-> AlgEqR [|-G] [g |-  M2[..]] [g |-  N2[..]] [ |- T]
-> EqTm [g |-  M1[..]] [g |-  M2[..]] =
/ total (determinacy') /
fn s1 => fn s2 => fn e1 => fn e2 => case (confluence s1 s2) of
| Common s1' s2' =>
  let ReflTm = neutral_mstep s1' (algEqRSym e1) in
  let ReflTm = neutral_mstep s2' e2 in
  ReflTm
;

% Transitivity of algorithmic equivalence
rec algEqRTrans :
  AlgEqR [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
-> AlgEqR [|-G] [g |-  N2[..]] [g |-  N3[..]] [ |- T]
-> AlgEqR [|-G] [g |-  N1[..]] [g |-  N3[..]] [ |- T] =
/ total a1 (algEqRTrans g g n1 n2 n3 t a1) /
fn a1 => fn a2 => case a1 of
| AlgVar e1 => let AlgVar e2 = a2 in AlgVar e1
| AlgApp a1' b1 =>
  let AlgApp a2' b2 = a2 in 
  let ReflTp = algEqRUnique a1' a2' in
  AlgApp (algEqRTrans a1' a2') (algEqNTrans b1 b2)
and algEqNTrans :
  AlgEqN [|-G] [g |-  N1[..]] [g |-  N2[..]] [ |- T]
-> AlgEqN [|-G] [g |-  N2[..]] [g |-  N3[..]] [ |- T]
-> AlgEqN [|-G] [g |-  N1[..]] [g |-  N3[..]] [ |- T] =
/ total a1 (algEqNTrans g g n1 n2 n3 t a1) /
fn a1 => fn a2 => case a1 of
| AlgBase s1 s2 a1' =>
  let AlgBase s2' s3 a2' = a2 in 
  let ReflTm = determinacy' s2 s2' a1' a2' in
  AlgBase s1 s3 (algEqRTrans a1' a2')
| AlgArr a1' => 
  let AlgArr a2' = a2 in AlgArr (algEqNTrans a1' a2')
;

% Transitivity of logical equivalence
rec logEqTrans : {T:[|- tp]}
   LogEq [|-G] [g |-  M[..]] [g |-  N[..]] [ |- T]
 -> LogEq [|-G] [g |-  N[..]] [g |-  P[..]] [ |- T]
 -> LogEq [|-G] [g |-  M[..]] [g |-  P[..]] [ |- T] =
/ total t (logEqTrans g g m  n p t) /
mlam T => fn e1 => fn e2 => case [|- T] of 
| [|- i] => 
  let LogBase a1 = e1 in
  let LogBase a2 = e2 in LogBase (algEqNTrans a1 a2)
| [|- arr T1 T2] => 
  let LogArr [g |-  M[..]] [g |-  N[..]] f1 = e1 in
  let LogArr [g |-  N[..]] [g |-  P[..]] f2 = e2 in
  LogArr [g |-  M[..]] [g |-  P[..]] (mlam H => mlam h => mlam #W => mlam V1 => mlam V2 => fn rh => fn iv => fn v =>
   logEqTrans [|- T2] (f1 [|-H] [h] [h |- #W[..]] [h |-  V1[..]] [h |-  V2[..]] rh iv v)
                      (f2 [|-H] [h] [h |- #W[..]] [h |-  V2[..]] [h |-  V2[..]] rh iv
                      (logEqTrans [|- T1] (logEqSym [|- _ ] v) v)));

% Transitivity of logical equivalence on substitutions
rec logEqSubTrans :
   LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]]
 -> LogEqSub [|-G] [g] [|-H] [h |- #S2[..]] [h |- #S3[..]]
 -> LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S3[..]] =
/ total e1 (logEqSubTrans g g h h s1 s2 s3 e1) /
fn e1 => fn e2 => case e1 of
| Nil => let Nil = e2 in Nil
| Dot e1' x1 => let Dot e2' x2 = e2 in Dot (logEqSubTrans e1' e2') (logEqTrans [|- _ ] x1 x2);

% Fundamental theorem
rec thm :  DecEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- T]
        -> CtxRel [|-H] [h]
        -> LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]]
        -> LogEq [|-H] [h |-  M1 #S1[..]] [h |-  M2 #S2[..]] [ |- T] =
 / total d (thm g g h h m1 m2 t sigma sigma' d) /
fn d => fn r => fn s => 
let s : LogEqSub [|-G] [g] [|-H] [h |- #S1[..]] [h |- #S2[..]] = s in
case d of
| DecVar v => lookup v s
| DecApp d1 d2 => let LogArr [h |-  M1[..]] [h |-  M2[..]] f = thm d1 r s in
    f [|-H] [h] [h |-[..]] [h |-  _] [h |-  _] r (idIsVarSub r) (thm d2 r s)
| (DecLam d1) : DecEq [|-G] [g |-  lam (\x. M1)] [g |-  lam (\x. M2)] [ |- arr T S] =>
   LogArr [h |-  lam (\x. M1 #S1[..] x)] [h |-  lam (\x. M2 #S2[..] x)]
     (mlam h0 => mlam h0' => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
     let q2 = thm d1 rh (Dot (wknLogEqSub iv s) rn) in
     closed [ |- _ ] [h0' |-  trans1 beta refl] [h0' |-  trans1 beta refl] q2
   )
| DecExt d1 =>
  LogArr [h |-  _] [h |-  _] (mlam h0 => mlam h0' => mlam #W => mlam N1 => mlam N2 => fn rh => fn iv => fn rn =>
   thm d1 rh (Dot (wknLogEqSub iv s) rn)
  )
| DecBeta d1 d2 =>
   closed [|- _ ] [h |-  trans1 beta refl] [h |-  refl] (thm d1 r (Dot s (thm d2 r s)))
| DecSym d1 => logEqSym [|- _ ] (thm d1 r (logEqSubSym s))
| DecTrans d1 d2 => logEqTrans [|- _ ] (thm d1 r s) (thm d2 r (logEqSubTrans (logEqSubSym s) s))
;

% The identity substitution is logically related to itself
rec idLogEqSub : CtxRel [|-G] [g]
-> LogEqSub [|-G] [g] [|-G] [g |-[..]] [g |-[..]] =
 / total r (idLogEqSub g g r) /
fn r => case r of
| RNil => Nil
| RCons r' => Dot (wknLogEqSub (shiftIsRen r') (idLogEqSub r'))
                 (reflect [ |- _] (AlgVar Top));

rec completeness : CtxRel [|-G] [g]
-> DecEq [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- T]
-> AlgEqN [|-G] [g |-  M1[..]] [g |-  M2[..]] [ |- T] =
 / total (completeness) /
fn r => fn e => reify r (thm e r (idLogEqSub r));

