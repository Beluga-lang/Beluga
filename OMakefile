# -*- coding: utf-8; indent-tabs-mode: nil; -*-

# Use ocamlfind to manage library linking
USE_OCAMLFIND = true

# Set up the ocamlfind flags
OCAMLFINDFLAGS = -syntax camlp4o

# The ocamlfind packages we use
OCAMLPACKS[] =
        camlp4
        extlib
        oUnit
        ulex
        dynlink

# Compile with debugging options?  This enables:
#
# 1. Pattern match failure warnings
# 2. Profiling information in compiled code (-p)

# DEBUG = true

OCAMLFLAGS = $(if $(DEBUG), -w Ae  -warn-error Ap \
                          , -w Aep -warn-error A)

# 3. Debugging information in byte-compiled code (-g)  (It is never useful to turn this off. -jd)
OCAMLFLAGS += -g

# Flags to pass to the native-code compiler
# Explanation:
#       -noassert       (turn off assertions)
#       -inline 100     (aggressive inlining)
OCAMLOPTFLAGS  = -noassert -inline 100
OCAMLOPTFLAGS += $(if $(DEBUG), -p)

# Declare a phony clean target
# .PHONY: core clean frontend interpreter test
.PHONY: clean interpreter

# Map the src dir onto the build dir
vmount(-l, src, .build)
if $(not $(file-exists .build/core))
  mkdir .build/core
if $(not $(file-exists .build/main))
  mkdir .build/main

# Include the fake .build subdirectory
.SUBDIRS: .build

.DEFAULT: .PHONY/src/.DEFAULT :effects: build
        $(if $(not $(file-exists bin)),               \
          $(mkdir bin))                               \
        $(if $(not $(file-exists bin/interpreter)),   \
          $(symlink .build/main/interpreter, bin/interpreter)) \
        $(if $(not $(file-exists bin/interpreter.run)),   \
          $(symlink .build/main/interpreter.run, bin/interpreter.run))

clean: .PHONY/src/clean
        rm $(filter-proper-targets $(ls R, .))
        rm $(filter %.omc,         $(ls R, .))
        $(if $(file-exists bin), $(rmdir -r bin))
