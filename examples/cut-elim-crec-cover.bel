% Cut-admissibility as a function
% Author: Brigitte Pientka

i : type.  % individuals
%name i S.
o : type.  % formulas
%name o A.

imp    : o -> o -> o.
not    : o -> o.
true   : o.
forall : (i -> o) -> o.

hyp  : o -> type.  % Hypotheses (left)
conc : o -> type.  % Conclusion (right)

axiom   : (hyp A -> conc A).
truer   : conc (true).
impr    : (hyp A -> conc B) -> conc (imp A B).
impl    : conc A -> (hyp B -> conc C) -> (hyp (imp A B) -> conc C).
notr    : ({p:o}hyp A -> conc p) -> conc (not A).
notl    : conc A -> (hyp (not A) -> conc C).
forallr : ({a:i} conc (A a)) -> conc (forall (\x. A x)).
foralll : {T:i}(hyp (A T) -> conc C) -> (hyp (forall (\x . A x)) -> conc C).

schema ctx = some [a: o] hyp a + i + o;

ass: o -> o -> type.
assume: {A:o}conc A -> (hyp A -> conc C) -> ass A C.

% (assum A D (\h. E h))
%  {A:o} conc A -> (hyp A -> conc C) -> conc C.
rec ca : (g:ctx) [g |- ass (A ..) (C ..)]  -> [g |- conc (C ..)] =
% / total e (ca _ _ _ e ) /
fn e => case e of
| [g |- assume (A ..)             (axiom (H ..))      (\h.E .. h)]                            => [g |- (E .. (H ..))]
| [g |- assume (A ..)             (D ..)              (\h. axiom h)]                         => [g |- D ..]
| [g |- assume (imp (A ..) (B ..)) (impr (\h.D .. h))  (\h. impl (E1 .. h) (\h2.E2 .. h h2) h)] =>
  let [g |- E1' ..] = ca [g |- assume (imp (A ..) (B ..)) (impr (\h.D .. h)) (\h.E1 .. h)]    in
  let [g |- D2' ..] = ca [g |- assume (A ..)              (E1' ..)          (\h.D  .. h)]    in
  let [g, h2: hyp (B ..) |-  E2' .. h2] =
                  ca [g,h2: hyp (B ..) |-  assume (imp (A ..) (B ..)) (impr (\h.D .. h)) (\h.E2 .. h h2)] in
    ca [g |- assume (B ..)  (D2' ..) (\h2. E2' .. h2)]

| [g |- assume (not (A .. )) (notr (\p.\h2. D .. p h2)) (\h. notl (E1 .. h) h)]  =>
  let [g |- F1 ..]       = ca [g |- assume (not (A ..)) (notr (\p.\h2. D .. p h2))  (\h. E1 .. h)] in
  let [g,p:o |-  F2 .. p] = ca [g,p:o |-  assume (A .. )     (F1 ..)                    (\h. D .. p h)] in
    [g |- F2 .. _]

| [g |- assume (forall (\x. A1 .. x)) (forallr \a. D1 .. a) (\h.foralll (T ..) (\h1. E1 .. h h1) h)] =>
  let [g,h2: hyp _  |-  E1' .. h2] =
         ca [g, h2:hyp _ |-  assume (forall (\x. A1 .. x)) (forallr \a. D1 .. a) (\h. E1 .. h h2)] in
    ca [g |- assume (A1 .. (T ..)) (D1 .. (T .. )) (\h2. E1' .. h2)]

| [g |- assume (A .. ) (impl (D1 ..) (\h2. D2 .. h2) (H .. )) (\h. E .. h)] =>
  let [g, h2: hyp _  |-  D2' .. h2] = ca [g, h2: hyp _ |-  assume  (A ..)
                                                           (D2 .. h2) (\h  .   E .. h)] in
    [g |- impl (D1 ..) (\h2. D2' .. h2) (H ..)]

| [g |- assume (A ..)  (notl (D1 ..) (H ..)) (\h. E .. h)] => [g |- notl (D1 ..) (H ..)]

| [g |- assume (A ..)  (foralll (T ..) (\h1. D1 .. h1) (H .. )) (\h. E .. h)]  =>
  let [g,h:hyp _ |-  D1' .. h] = ca [g,h:hyp _ |-  assume (A ..) (D1 .. h) (\h.E .. h)] in
    [g |- foralll (T ..) (\h1. D1' .. h1) (H ..)]

%%%%
| [g |- assume (A ..) (D ..) (\h. axiom (H ..))] => [g |- axiom (H ..)]
| [g |- assume (A ..) (D ..) (\h. impr (\h1. E2 .. h1 h))] =>
  let [g, h1:hyp _ |-  E2' .. h1] = ca [g,h1:hyp _ |-  assume (A .. ) (D ..) (\h. E2 .. h1 h)] in
    [g |- impr \h1. E2' .. h1]

| [g |- assume (A ..) (D ..) (\h. impl (E1 .. h) (\h2. E2 .. h2 h) (H ..))] =>
  let [g |- E1' ..] = ca [g |- assume (A ..) (D ..) (\h. E1 .. h)] in
  let [g, h2: hyp _  |-  E2' .. h2] = ca [g, h2: hyp _ |-  assume (A ..) (D ..) (\h. E2 .. h2 h)] in
    [g |- impl (E1' ..) (\h2. E2' .. h2) (H ..)]

| [g |- assume (A ..) (D ..) (\h.notr (\p.\h1. E1 .. h p h1))] =>
  let [g, h1:hyp _ ,p:o |-  E1' .. p h1] = ca [g,h1:hyp _, p:o |-  assume (A ..) (D ..) (\h. E1 .. h p h1)] in
    [g |- notr \p.\h1. E1' .. p h1]

| [g |- assume (A ..) (D ..) (\h.notl (E1 .. h) (H ..))] =>
  let [g |- E1' ..] = ca [g |- assume (A ..) (D ..) (\h.E1 .. h)] in
    [g |- notl (E1' ..) (H ..)]

| [g |- assume (A ..) (D ..) (\h. truer)] => [g |- truer]

| [g |- assume (A ..) (D ..) (\h. forallr (\a. E1 .. a h))] =>
  let [g,a:i |-  E1' .. a] = ca [g,a:i |-  assume (A ..) (D ..) (\h. E1 .. a h)] in
    [g |- forallr \a. E1' .. a]

 | [g |- assume (A ..) (D ..) (\h.foralll (T ..) (\h1.E1 .. h h1) (H ..))] =>
   let [g, h1:hyp _  |-  E1' .. h1] = ca [g, h1:hyp _ |-  assume (A .. ) (D .. ) (\h.E1 .. h h1)] in
   [g |- foralll (T ..) (\h1. E1' .. h1) (H ..)]

;


% Original Twelf implementation
%
% ca : {A:o} conc A -> (hyp A -> conc C) -> conc C -> type.
% %mode ca +A +D +E -F.
%
% %% Axiom Conversions
%
% ca_axiom_l : ca A (axiom H) E (E H).
%
% ca_axiom_r : ca A D ([h:hyp A] axiom h) D.
% ca_imp  : ca (A1 imp A2) (impr D2)
% 	   ([h:hyp (A1 imp A2)] impl (E1 h) (E2 h) h) F
% 	   <- ca (A1 imp A2) (impr D2) E1 E1'
% 	   <- ({h2:hyp A2}
% 		 ca (A1 imp A2) (impr D2)
% 		 ([h:hyp (A1 imp A2)] E2 h h2) (E2' h2))
% 	   <- ca A1 E1' D2 D2'
% 	   <- ca A2 D2' E2' F.
% ca_not  : ca (not A1) (notr D1)
% 	   ([h:hyp (not A1)] notl (E1 h) h) (F2 C)
% 	   <- ca (not A1) (notr D1) E1 F1
% 	   <- ({p:o} ca A1 F1 ([h1:hyp A1] D1 p h1) (F2 p)).
%
%
% ca_forall : ca (forall A1) (forallr D1)
% 	     ([h:hyp (forall A1)] foralll T (E1 h) h) F
% 	     <- ({h2:hyp (A1 T)}
% 		   ca (forall A1) (forallr D1)
% 		   ([h:hyp (forall A1)] E1 h h2) (E1' h2))
% 	     <- ca (A1 T) (D1 T) E1' F.
%
% cal_impl   : ca A (impl D1 D2 H) E (impl D1 D2' H)
% 	      <- ({h2:hyp B2} ca A (D2 h2) E (D2' h2)).
%
% cal_notl   : ca A (notl D1 H) E (notl D1 H).
%
% cal_foralll : ca A (foralll T D1 H) E (foralll T D1' H)
% 	       <- ({h} ca A (D1 h) E (D1' h)).
%
% car_axiom : ca A D ([h:hyp A] axiom H1) (axiom H1).
%
% car_impr : ca A D ([h:hyp A] impr (E2 h)) (impr E2')
% 	    <- ({h1:hyp B1} ca A D ([h:hyp A] E2 h h1) (E2' h1)).
%
% car_impl : ca A D ([h:hyp A] impl (E1 h) (E2 h) H) (impl E1' E2' H)
% 	    <- ca A D E1 E1'
% 	    <- ({h2:hyp B2} ca A D ([h:hyp A] E2 h h2) (E2' h2)).
% car_notr : ca A D ([h:hyp A] notr (E1 h)) (notr E1')
% 	    <- ({p:o} {h1:hyp B1} ca A D ([h:hyp A] E1 h p h1) (E1' p h1)).
%
% car_notl : ca A D ([h:hyp A] notl (E1 h) H) (notl E1' H)
% 	    <- ca A D E1 E1'.
%
% car_truer: ca A D ([h:hyp A] truer) (truer).
%
% car_forallr : ca A D ([h:hyp A] forallr (E1 h)) (forallr E1')
% 	       <- ({a:i} ca A D ([h:hyp A] E1 h a) (E1' a)).
%
% car_foralll: ca A D ([h:hyp A] foralll T (E1 h) H) (foralll T E1' H)
% 	      <- ({h1} ca A D ([h:hyp A] E1 h h1) (E1' h1)).
