<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Coverage (beluga.Beluga.Coverage)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Beluga</a> &#x00BB; Coverage</nav><header class="odoc-preamble"><h1>Module <code><span>Beluga.Coverage</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Comp"><a href="#module-Comp" class="anchor"></a><code><span><span class="keyword">module</span> Comp</span><span> = <a href="../../Synint/Comp/index.html">Beluga_syntax.Synint.Comp</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-LF"><a href="#module-LF" class="anchor"></a><code><span><span class="keyword">module</span> LF</span><span> = <a href="../../Synint/LF/index.html">Beluga_syntax.Synint.LF</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-error"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span></code><ol><li id="type-error.NoCover" class="def variant constructor anchored"><a href="#type-error.NoCover" class="anchor"></a><code><span>| </span><span><span class="constructor">NoCover</span> <span class="keyword">of</span> string</span></code></li><li id="type-error.MatchError" class="def variant constructor anchored"><a href="#type-error.MatchError" class="anchor"></a><code><span>| </span><span><span class="constructor">MatchError</span> <span class="keyword">of</span> string</span></code></li><li id="type-error.NothingToRefine" class="def variant constructor anchored"><a href="#type-error.NothingToRefine" class="anchor"></a><code><span>| </span><span><span class="constructor">NothingToRefine</span></span></code></li><li id="type-error.NoCoverageGoalsGenerated" class="def variant constructor anchored"><a href="#type-error.NoCoverageGoalsGenerated" class="anchor"></a><code><span>| </span><span><span class="constructor">NoCoverageGoalsGenerated</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cov_goal"><a href="#type-cov_goal" class="anchor"></a><code><span><span class="keyword">type</span> cov_goal</span><span> = </span></code><ol><li id="type-cov_goal.CovGoal" class="def variant constructor anchored"><a href="#type-cov_goal.CovGoal" class="anchor"></a><code><span>| </span><span><span class="constructor">CovGoal</span> <span class="keyword">of</span> <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-normal">LF.normal</a> * <a href="../../Synint/LF/index.html#type-tclo">LF.tclo</a></span></code></li><li id="type-cov_goal.CovCtx" class="def variant constructor anchored"><a href="#type-cov_goal.CovCtx" class="anchor"></a><code><span>| </span><span><span class="constructor">CovCtx</span> <span class="keyword">of</span> <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a></span></code></li><li id="type-cov_goal.CovSub" class="def variant constructor anchored"><a href="#type-cov_goal.CovSub" class="anchor"></a><code><span>| </span><span><span class="constructor">CovSub</span> <span class="keyword">of</span> <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-sub">LF.sub</a> * <a href="../../Synint/LF/index.html#type-cltyp">LF.cltyp</a></span></code></li><li id="type-cov_goal.CovPatt" class="def variant constructor anchored"><a href="#type-cov_goal.CovPatt" class="anchor"></a><code><span>| </span><span><span class="constructor">CovPatt</span> <span class="keyword">of</span> <a href="../../Synint/Comp/index.html#type-gctx">Comp.gctx</a> * <a href="../../Synint/Comp/index.html#type-pattern">Comp.pattern</a> * <a href="../../Synint/Comp/index.html#type-tclo">Comp.tclo</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-inside"><a href="#type-inside" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a inside</span></span><span> = <a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <span class="type-var">'a</span> * <a href="../../Synint/LF/index.html#type-msub">LF.msub</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-gen_pat_var_strategy"><a href="#type-gen_pat_var_strategy" class="anchor"></a><code><span><span class="keyword">type</span> gen_pat_var_strategy</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-withPatFVar"><a href="#val-withPatFVar" class="anchor"></a><code><span><span class="keyword">val</span> withPatFVar : <a href="#type-gen_pat_var_strategy">gen_pat_var_strategy</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-withPatVar"><a href="#val-withPatVar" class="anchor"></a><code><span><span class="keyword">val</span> withPatVar : <a href="#type-gen_pat_var_strategy">gen_pat_var_strategy</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_inside"><a href="#val-map_inside" class="anchor"></a><code><span><span class="keyword">val</span> map_inside : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-inside">inside</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-inside">inside</a></span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Error</span> <span class="keyword">of</span> <a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> * <a href="#type-error">error</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-enableCoverage"><a href="#val-enableCoverage" class="anchor"></a><code><span><span class="keyword">val</span> enableCoverage : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-warningOnly"><a href="#val-warningOnly" class="anchor"></a><code><span><span class="keyword">val</span> warningOnly : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-no_covers"><a href="#val-no_covers" class="anchor"></a><code><span><span class="keyword">val</span> no_covers : <span>int <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-problem"><a href="#type-problem" class="anchor"></a><code><span><span class="keyword">type</span> problem</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-case_pragma">Comp.case_pragma</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-branch">Comp.branch</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/Comp/index.html#type-meta_obj">Comp.meta_obj</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-problem">problem</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-coverage_result"><a href="#type-coverage_result" class="anchor"></a><code><span><span class="keyword">type</span> coverage_result</span><span> = </span></code><ol><li id="type-coverage_result.Success" class="def variant constructor anchored"><a href="#type-coverage_result.Success" class="anchor"></a><code><span>| </span><span><span class="constructor">Success</span></span></code></li><li id="type-coverage_result.Failure" class="def variant constructor anchored"><a href="#type-coverage_result.Failure" class="anchor"></a><code><span>| </span><span><span class="constructor">Failure</span> <span class="keyword">of</span> string</span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-depend"><a href="#type-depend" class="anchor"></a><code><span><span class="keyword">type</span> depend</span><span> = </span></code><ol><li id="type-depend.Atomic" class="def variant constructor anchored"><a href="#type-depend.Atomic" class="anchor"></a><code><span>| </span><span><span class="constructor">Atomic</span></span></code></li><li id="type-depend.Dependent" class="def variant constructor anchored"><a href="#type-depend.Dependent" class="anchor"></a><code><span>| </span><span><span class="constructor">Dependent</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><a href="#type-coverage_result">coverage_result</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><a href="#type-coverage_result">coverage_result</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-process"><a href="#val-process" class="anchor"></a><code><span><span class="keyword">val</span> process : <span><a href="#type-problem">problem</a> <span class="arrow">&#45;&gt;</span></span> <span><span>int option</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genNthSchemaElemGoal"><a href="#val-genNthSchemaElemGoal" class="anchor"></a><code><span><span class="keyword">val</span> genNthSchemaElemGoal : 
  <span><span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Syncom/Id/index.html#type-cid_schema">Beluga_syntax.Id.cid_schema</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> <a href="#type-inside">inside</a></span> option</span></span></code></div><div class="spec-doc"><p>Generates the coverage goal for the nth schema element in the given schema. WARNING: Schema element indices are 1-based!</p><p>genNthSchemaElemGoal cD n w = Some (cD', cPsi, t)</p><ul><li>provided n is a valid index for the schema elements of w</li><li>cD' |- t : cD</li><li>cD' |- cPsi dctx is the pattern for this case</li><li>cD' will contain an extra context variable (see remark below) as well as new variables for each of the existential variables for the schema element that is looked up.</li></ul><p>Returns None if the schema element index n is out of bounds.</p><p>Remark: this function will internally extend cD with an additional (dummy) context variable. Unification for dependent pattern matching (see Reconstruct.synPatRefine) eliminates this extra variable later. However, the preliminary branch context</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genPVarGoal"><a href="#val-genPVarGoal" class="anchor"></a><code><span><span class="keyword">val</span> genPVarGoal : 
  <span><a href="../../Synint/LF/index.html#type-sch_elem">LF.sch_elem</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-ctx_var">LF.ctx_var</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-head">LF.head</a> * <a href="../../Synint/LF/index.html#type-typ">LF.typ</a>)</span> <a href="#type-inside">inside</a></span></span></code></div><div class="spec-doc"><p>genPVarGoal sch_elem cD cPsi psi = (cD', cPsi', h, tA', t) calculates a preliminary branch context for a parameter variable referring to the given schema element, without taking projection into account.</p><p>cD |- cPsi ctx cD |- psi ctxvar cD' |- t : cD cD' |- cPsi' ctx cD'; cPsi' |- h &lt;= tA' and h is an LF head, namely the PVar for this case.</p><p>The resulting meta-context cD' will contain an entry for the PVar itself as well as for any existential variables bound by the schema element. The returned substitution t is an appropriate weakening.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genObj"><a href="#val-genObj" class="anchor"></a><code><span><span class="keyword">val</span> genObj : 
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-typ">LF.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-head">LF.head</a> * <a href="../../Synint/LF/index.html#type-typ">LF.typ</a> * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-normal">LF.normal</a> * <a href="../../Synint/LF/index.html#type-tclo">LF.tclo</a>)</span> <a href="#type-inside">inside</a></span> option</span></span></code></div><div class="spec-doc"><p>genObj (cD, cPsi, tP) (tH, tA) = (cD', CovGoal (cPsi', tR, tP'), ms)</p><p>if cD; cPsi |- tH =&gt; tA and there exists a spine tS s.t. cD; cPsi |- tS : tA &gt; tP then tR = Root (tH, tS) and cD'; <code>t</code>cPsi |- tR &lt;= <code>t</code>tP and cD' |- t : cD</p><p>Concretely, this function is used to generate a pattern for a meta-object in splitting. tP is the type of the scrutinee, which is unified against the conclusion type of tA. tA, being the type of the head tH, is typically a pi-type, so we walk it to construct a spine by calling genSpine. Together with the given head, this generated spine is used to form the normal tR that is returned. Since this unification can eliminate variables, the resulting normal makes sense inside the &quot;branch context&quot; cD', so the msub t together with its target context cD' are also returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genPatt"><a href="#val-genPatt" class="anchor"></a><code><span><span class="keyword">val</span> genPatt : 
  <span><span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-gen_pat_var_strategy">gen_pat_var_strategy</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="../../Synint/Comp/index.html#type-typ">Comp.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Id/index.html#type-cid_comp_const">Beluga_syntax.Id.cid_comp_const</a> * <a href="../../Synint/Comp/index.html#type-typ">Comp.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Synint/Comp/index.html#type-gctx">Comp.gctx</a> * <a href="../../Synint/Comp/index.html#type-pattern">Comp.pattern</a> * <a href="../../Synint/Comp/index.html#type-tclo">Comp.tclo</a>)</span> <a href="#type-inside">inside</a></span> option</span></span></code></div><div class="spec-doc"><p>genPatt (cD, tau_i) (c, tau_c) = None | Some (cD', (cG, pat, ttau_p), t) generates a pattern with the given constructor c that matches the type tau_i.</p><p>If cD |- tau_i &lt;= type .; . |- c &lt;= tau_c</p><p>then genPatt tries to generate a spine S such that pat = c S</p><p>cD'; cG |- pat &lt;= ttau_p cD' |- t : cD (cD' |- ttau_p &lt;= type) (cD' |- cG &lt;= gctx)</p><p>This process can fail, if ttau_p is not unifiable with the conclusion type of tau_c, in which case the constructor `c` is impossible for the scrutinee type `tau_i`.</p><p>The given list of names are those in the current scope, to ensure that generated names do not shadow.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genPatCGoals"><a href="#val-genPatCGoals" class="anchor"></a><code><span><span class="keyword">val</span> genPatCGoals : 
  <span><span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-gen_pat_var_strategy">gen_pat_var_strategy</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-typ">Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Synint/Comp/index.html#type-gctx">Comp.gctx</a> * <a href="../../Synint/Comp/index.html#type-pattern">Comp.pattern</a> * <a href="../../Synint/Comp/index.html#type-tclo">Comp.tclo</a>)</span> <a href="#type-inside">inside</a></span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genContextGoals"><a href="#val-genContextGoals" class="anchor"></a><code><span><span class="keyword">val</span> genContextGoals : 
  <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a>
   * <a href="../../Synint/LF/index.html#type-ctyp">LF.ctyp</a>
   * <a href="../../Syncom/Plicity/index.html#type-t">Beluga_syntax.Plicity.t</a>
   * <a href="../../Syncom/Inductivity/index.html#type-t">Beluga_syntax.Inductivity.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> <a href="#type-inside">inside</a></span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genCGoals"><a href="#val-genCGoals" class="anchor"></a><code><span><span class="keyword">val</span> genCGoals : 
  <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-ctyp">LF.ctyp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="#type-cov_goal">cov_goal</a> * <a href="../../Synint/LF/index.html#type-msub">LF.msub</a>)</span> list</span> * <a href="#type-depend">depend</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genCovGoals"><a href="#val-genCovGoals" class="anchor"></a><code><span><span class="keyword">val</span> genCovGoals : 
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-typ">LF.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-normal">LF.normal</a> * <a href="../../Synint/LF/index.html#type-tclo">LF.tclo</a>)</span> <a href="#type-inside">inside</a></span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genBCovGoals"><a href="#val-genBCovGoals" class="anchor"></a><code><span><span class="keyword">val</span> genBCovGoals : 
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-typ">LF.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-normal">LF.normal</a> * <a href="../../Synint/LF/index.html#type-tclo">LF.tclo</a>)</span> <a href="#type-inside">inside</a></span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-genBVar"><a href="#val-genBVar" class="anchor"></a><code><span><span class="keyword">val</span> genBVar : 
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-typ">LF.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../Synint/LF/index.html#type-dctx">LF.dctx</a> * <a href="../../Synint/LF/index.html#type-normal">LF.normal</a> * <a href="../../Synint/LF/index.html#type-tclo">LF.tclo</a>)</span> <a href="#type-inside">inside</a></span> list</span></span></code></div><div class="spec-doc"><p>Generates one coverage goal for every bound variable that appears in the given LF context.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-addToMCtx"><a href="#val-addToMCtx" class="anchor"></a><code><span><span class="keyword">val</span> addToMCtx : <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../Synint/LF/index.html#type-ctyp_decl">LF.ctyp_decl</a> list</span> * <a href="../../Synint/LF/index.html#type-msub">LF.msub</a>)</span> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> * <a href="../../Synint/LF/index.html#type-msub">LF.msub</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_impossible"><a href="#val-is_impossible" class="anchor"></a><code><span><span class="keyword">val</span> is_impossible : <span><a href="../../Synint/LF/index.html#type-mctx">LF.mctx</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Synint/Comp/index.html#type-typ">Comp.typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Decide whether a given computational type is impossible.</p></div></div><p>Error-reporting</p><div class="odoc-spec"><div class="spec value anchored" id="val-reset_information"><a href="#val-reset_information" class="anchor"></a><code><span><span class="keyword">val</span> reset_information : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_information"><a href="#val-get_information" class="anchor"></a><code><span><span class="keyword">val</span> get_information : <span>unit <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_information"><a href="#val-add_information" class="anchor"></a><code><span><span class="keyword">val</span> add_information : <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>