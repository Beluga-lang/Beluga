tp: type.
nat: tp.
bool: tp.
arr : tp -> tp -> tp.


exp : tp -> type.
z   : exp nat.
suc : exp nat -> exp nat.
and : exp bool -> exp bool -> exp bool.
tt  : exp bool.
ff  : exp bool.

app:  exp (arr T T') -> exp T -> exp T'.
lam : (exp T -> exp T') -> exp (arr T T').

opt: type.
nothing: opt.
something: exp T -> opt.

schema w = some [t:tp] exp t;

rec free_var : {g:(w)*} (exp T)[g] -> opt[g] =
FN g  => % mlam T  => 
 fn e => 
 case e of
    [g] z             => [g] nothing
  | [g] tt            => [g] nothing
  | [g] ff            => [g] nothing

  | [g] (#p ..) 
    => [g] something  (#p ..)

  | [g] suc (U ..)  => free_var [g] ([g] (U ..))

  | [g] and (U ..) (V ..)  => 
       (case free_var [g] ([g] (U ..)) of
          [g] nothing   => free_var [g] ([ ] (V ..))
        | [g] something  (#p ..)  => [ ] something  (#p ..))

  | [g] app (U ..) (V ..)  => 
       (case free_var [g] ([g] (U ..)) of
          [g] nothing   => free_var [g] ([g] (V ..))

        | [g] something  (#p ..)  => [g] something  (#p ..))

  | [g] lam (\x . (U .. x)) => 

     (case (free_var [g, x:exp _ ] ([g, x] (U .. x))) of 
        [g, x: exp _ ] nothing       => [ ] nothing
      | [g, x: exp _ ] something x   => [ ] nothing
          % technically we need to initiate backtracking
      | [g, x: exp _ ] something (#p ..) => [ ] something (#p ..)
      )
;


