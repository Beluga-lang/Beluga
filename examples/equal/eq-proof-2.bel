% Given an expression e, return the proof that e is always equal to itself.
% 
% If e is an expression, then eq e e.

% Author: Brigitte Pientka
% Comments: 
% - use of Sigma-types in context
%
% - in Delphin, this example requires a special function `extend' of
%   type eqParamFun = <f:exp#> -> <eq f f> to keep track of the
%   relationship between an introduced parameter and the fact that
%   every parameter is equal to itself;
%
% - also requires explicit use of "remove parameter x and u" in the
%   definition of `extend' and the use of `extend' in `eqfun'

exp: type.    %name exp E x.
z: exp.
app: exp -> exp -> exp.
lam: (exp -> exp) -> exp.

eq: exp -> exp -> type.   %name eq Q u.
eq_app : eq E1 F1 -> eq E2 F2 -> eq (app E1 E2) (app F1 F2).

eq_lam :  ({x : exp} eq x x -> eq (E x) (F x)) 
          -> eq (lam (\x. E x)) (lam (\x. F x)).
 
schema eqCtx = block x:exp. eq x x;

rec ref : {g:(eqCtx)*} {U::exp[g]} (eq (U ..) (U ..))[g] =
 FN g => mlam U => case [g] (U ..) of
| [g] #p.1 .. => [g] #p.2 ..

| [g] lam \x. L .. x =>
  let [g,e:block y:exp. eq y y] V .. e = 
      ref [g, e:block q:exp. eq q q] <g, e. L .. e.1> in
    [g] eq_lam \x. \w. (V .. <x, w>)  % : eq (L .. x) (L .. x)
| [g] app (A1 ..) (A2 ..)  : exp[g]=>
  let [g] EQ1 .. = ref [g] <g . A1 ..> in
  let [g] EQ2 .. = ref [g] <g . A2 ..> in
    [g] eq_app (EQ1 ..) (EQ2 ..)
;



% General transitivity is admissible
rec trans: {g:(eqCtx)*} 
   (eq (TT ..) (RR ..))[g]     % e1 : eq T R
-> (eq (RR ..) (SS ..))[g]     % e2 : eq R S
-> (eq (TT ..) (SS ..))[g]     % result : eq T S
=
FN g => fn e1 => fn e2 => case e1 of

| [g] #p.2 .. => e2

| [g] eq_lam \x.\u. D1 .. x u =>
  let [g] eq_lam \x.\u. D2 .. x u =  e2  in	
  let [g, b:block x:exp. eq x x] E .. b = 
    trans [g, b:block x':exp. eq x' x'] 
        ([g, b] D1 .. b.1 b.2)
        ([g, b] D2 .. b.1 b.2)
  in
    [g] eq_lam \x. \u. E .. <x, u>
       
| [g] eq_app (D1 ..) (D2 ..) =>
  let [g] eq_app (F1 ..) (F2 ..) = e2 in 
  let [g] E1 .. = trans [g]  ([g] D1 ..)  ([g] F1 ..) in
  let [g] E2 .. = trans [g]  ([g] D2 ..)  ([g] F2 ..) in
    [g] eq_app  (E1 ..)  (E2 ..)
;



equal: exp -> exp -> type.
e_l: ({x:exp} equal x x -> equal (T x) (T' x)) -> equal (lam (\x. T x)) (lam (\x. T' x)).
e_a: equal T2 S2  -> equal T1 S1 -> equal (app T1 T2) (app S1 S2).
e_r: {T:exp}equal T T.
e_t: equal T' S -> equal T T' -> equal T S.

schema equalCtx = some [] block x: exp, u:eq x x . equal x x ;

rec ceq: {g:(equalCtx)*} (equal (T ..) (S ..))[g] -> (eq (T ..) (S ..))[g]  =
 FN g =>  fn e => case e of 
| [g] #p.3 .. => [g] #p.2 ..

| [g] e_r (T .. )=> ref [g] <g. T.. >   

| [g] e_t (D2 ..) (D1 ..) => 
  let [g] F2 .. = ceq [g] ([g] D2 ..) in 
  let [g] F1 .. = ceq [g] ([g] D1 ..) in 
    trans [g] ([g] F1 ..)  ([g] F2 ..)           

| [g] e_l (\x.(\u. (D .. x u))) => 
  let {F:: (eq (R .. x) (Q .. x))[g, x:exp, u: eq x x]}
     [g,b:block x:exp,u:eq x x . equal x x] F .. b.1 b.2 = 
        ceq [g, b:block x:exp, u:eq x x . equal x x]   ([g, b] D .. b.1 b.3)
  in
     [g] eq_lam (\x.\v. F .. x v)

| [g] e_a (D2 ..) (D1 ..) => 
    let [g] F1 .. = ceq [g] ([g] D1 ..) in 
    let [g] F2 .. = ceq [g] ([g] D2 ..) in 
      [g] eq_app (F1 ..) (F2 ..)

;


rec ceq_main: (equal T S)[ ] -> (eq T S)[ ] =  fn e =>  ceq [ ] e
;
