term :  type.
z    : term.
suc  : term -> term.
app  : term -> term -> term.

schema termCtx = some [] term;

rec copy : {g:termCtx} [g. term] -> [g. term] =
mlam g => fn e =>
 (case e of
  | [g. z]     => [g. z]
  | [g. suc (U ..)] => let [g. V ..] = copy [g] [g. U ..] in [g. suc (V .. )]
  | [g. #p ..] => [g. #p ..]
  | [g. app (U ..) (V ..)]  =>
    let [g. U' ..]  = copy [g] [g. U ..] in
    let [g. V' ..]  = copy [g] [g. V ..] in
       [g. app (U' ..) (V' ..)]
);


rec copyBroken : {g:termCtx} [g. term] -> [g. term] =
mlam g => fn e =>
 (case e of %not
  | [g. z]     => [g. z]
  | [g. suc (U ..)] => let [g. V ..] = copy [g] [g. U ..] in [g. suc (V .. )]
  | [g. #p ..] => [g. #p ..]
  | [g. app (U ..) (U ..)]  =>  [g. z]   % Doesn't cover because only matches app U U, not app U V
);
