term :  type.
z    : term.
suc  : term -> term.
% app  : term -> term -> term.    
% lam  : (term -> term) -> term.

schema termCtx = some [] term;

%{
rec fff : {g:(termCtx)*} term[g] -> term[g] =
FN g => fn e =>
  case e of
  | [g]  z     => [g] z

  | [g]  suc (U ..)   => [g] z

  | [g]  #p ..   => [g] z
;
}%
%{
%not
rec fffForgotConcreteVarCase : {g:(termCtx)*} term[g, x:term] -> term[g] =
FN g => fn e =>
  case e of
  | [g, x:term]  z     => [g] z
  | [g, x:term]  suc (U .. x)   => [g] z
  | [g, x:term]  #p ..   => [g] z
;

rec fffConcreteOK : {g:(termCtx)*} term[g, x:term] -> term[g] =
FN g => fn e =>
  case e of
  | [g, x:term]  z     => [g] z
  | [g, x:term]  suc (U .. x)   => [g] z
  | [g, x:term]  #p ..   => [g] z
  | [g, x:term]  x   => [g] z
;


rec fffConcreteIncludedInMVar : {g:(termCtx)*} term[g, x:term] -> term[g] =
FN g => fn e =>
  case e of
  | [g, x:term]  U .. x => [g] z
;

%not
rec fffNo-g-MVar : {g:(termCtx)*} term[g, x:term] -> term[g] =
FN g => fn e =>
  case e of
  | [g, x:term]  U x => [g] z
;

%not
rec fffEmptyMVar : {g:(termCtx)*} term[g, x:term] -> term[g] =
FN g => fn e =>
  case e of
  | [g, x:term]  U => [g] z
;
}%

%not
rec fffConcreteOmittedFromMVar : {g:(termCtx)*} term[g, x:term] -> term[g] =
FN g => fn e =>
  case e of
  | [g, x:term]  U .. => [g] z
;

%{
%not
rec fffForgotParamVarCase : {g:(termCtx)*} term[g] -> term[g] =
FN g => fn e =>
  case e of
  | [g]  z     => [g] z

  | [g]  suc (U ..)   => [g] z

  | [g]  #p ..   => [g] z
;
}%

%{
    rec fff : {g:(termCtx)*} term[g, x:term, y:term] -> term[g] =
    FN g => fn e =>
      case e of
      | [g, x:term, y:term]  z     => [g] z

      | [g, x:term, y:term]  suc (U ..)   => [g] z

      | [g, x:term, y:term]  #p ..   => [g] z

    %{
      | [g] app (U ..) (V ..)  => 
          let [g] (U' ..)  = fff [g] ([g] (U ..)) in 
          let [g] (V' ..)  = fff [g] ([g] (V ..)) in 
            [g] app (U' ..) (V' ..)
    }%
    ;
}%
