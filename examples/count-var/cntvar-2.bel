% Variable counting (see Pientka [POPL'08])
% Author:  Brigitte Pientka
%
% This example only uses weak higher-order abstract syntax.

tp  : type.   #name tp T.
nat : tp.
bool: tp.

exp : tp -> type.  #name exp E x.
z   : exp nat.
s   : exp nat -> exp nat.

tt  : exp bool.

add : exp nat -> exp nat -> exp nat.
letv: {T1:tp}exp T1 -> (exp T1 -> exp T2) -> exp T2.
% letv: exp T1 -> (exp T1 -> exp T2) -> exp T2.


schema expCtx = some [t:tp] exp t;


rec plus : (exp nat) [ ] -> (exp nat) [ ] -> (exp nat) [ ] =
fn x => fn y =>
case x of
  [ ] z    => y

| [ ] s U  =>
  let [ ] V = plus ([ ] U) y in ([ ] s V);


rec cntV : {g:(expCtx)*} (exp (S ..))[g, x:exp (T ..)] -> (exp nat) [ ] =
FN g => 
 fn e =>
  case e of

    [g,x : exp _ ] tt          => [ ] z

  | [g,x : exp _ ] (#p .. )    => [ ] z

  | [g,x : exp _ ] x           => [ ] s z


  | [g,x : exp _ ] z           => [ ] z

  | [g,x : exp _ ] s (W .. x)  => cntV [g] ([g,x] (W .. x))
%
%
%  NOT WORKING IF WE OMIT T1 ..  since from the pattern we simply infer
%  T1:tp[g, x:exp _]    and only later in the branch we learn that T1:tp[g].
%  
%   | [g,x : exp _ ] letv  (U1 .. x) (\y . (U2 ..  x y)) =>
%             plus (cntV [g]  ([g,x] (U1 .. x))) 
%                  (cntV [g, y:exp _ ]  ([g,y,x] (U2 .. x y)))
%
% CURRENTLY, THIS PROBLEM ARISES IN THE FORM OF FAILURE TO INVERT THE 
% RECONSTRUCTED BRANCH: MVAR 3[_ . ^0] occurs in the branch, but this is
% bad, since progress would be violated. The pattern may succeed in instantiating 3 to x 
% in the context ., x:A . But then [_, .](x)  does actually not exist.
% The solution is that the original meta-variable 3 needs to be in fact of a different type, 
% namely exp [. ] and not exp[. , x:A].  
%
   | [g,x : exp _ ] letv (T1 ..) (U1 .. x) (\y . (U2 .. x y)) =>
      plus  (cntV [g]          ([g,x] (U1 .. x))) 
            (cntV [g, y:exp _]  ([g,y,x] (U2 .. x y)))


   | [g,x: exp _ ] add (U .. x) (W .. x)  =>
     plus (cntV [g] ([g,x] (U .. x)))
          (cntV [g] ([g,x] (W .. x)))

;
