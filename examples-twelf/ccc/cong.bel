% general congruence: if E <-> E' then M[E/x] <-> M[E'/x]

schema ctx = some [a:obj] term a;

rec cong : {g:(ctx)*} {M::(term B)[g, x:term A]} (conv (E[..]) (E'[..]))[g] -> (conv (M[..] (E[..])) (M[..] (E'[..])))[g] =
   FN g => mlam M => fn c =>
    case ([g,x:term _] M) of
    | [g, x:term A]  x   =>      c
    | [g, x:term _ ] #p[..] =>  [g] c_refl

    | [g, x:term A] lunit => [g] c_refl

    | [g, x:term A] (lpair (M1) (M2))  =>
      let [g] LC1[..]  = cong [g] <g, x . M1> c in
      let [g] LC2[..]  = cong [g] <g, x . M2> c in
        [g] (c_pair (LC1[..]) (LC2[..]))

    | {N::(term (cross B1 B2))[g,x:term A']}
      [g, x:term A'] (lfst (N)) =>
      let [g] LP[..] = cong [g] <g, x . N> c in
        [g] c_fst (LP[..])

    | {N::(term (cross B1 B2))[g,x:term A']}
      [g, x:term A'] (lsnd (N)) =>
      let [g] (LC[..]) = cong [g] <g, x . N> c in
          [g] (c_snd (LC[..]))

    | [g, x:term A'] llam (\y. N[..] y x) =>
      let [g] D[..]  = c in
      let [g, y:term B1'] (CP[..] y) = cong [g, y:term _] <g, y, x . N[..] y x > ([g,y] D[..] ) in
          [g] (c_lam  (\y . CP[..] y ))


    | {N1::(term (arrow B1 B2))[g, x:term A']}
      [g, x:term A'] (lapp (N1) (N2)) =>
      let [g] (CP1[..]) = cong [g] <g, x . N1> c in
      let [g] (CP2[..]) = cong [g] <g, x . N2> c in
          [g] (c_app (CP1[..]) (CP2[..]))

;

