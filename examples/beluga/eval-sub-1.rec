% Substitution based evaluator
%   call-by-value strategy
%
%   Author: Brigitte Pientka
%

exp: type.


z   : exp.
suc : exp -> exp.
app : exp -> exp -> exp.
lam : (exp -> exp) -> exp.
letn: exp -> (exp -> exp) -> exp.
letv: exp -> (exp -> exp) -> exp.
fix : (exp -> exp) -> exp. 



% Call-By-Name evaluation 
rec eval : (exp)[.] -> (exp)[.] = 
fn e => 

(case e of

   box(. . suc U![.]!)  =>

    (case (eval (box( . U![.]!))) of       
      box(. . V![.]!) => box( . suc V![.]!))

| box(. . app U![.]! W![.]!) =>   
    (case (eval (box (. U![.]!))) of
       box(. . lam (\ x. V![.,x]!))  => 
          eval (box( . V![., W![.]! ]!))
    )
        
| box(. . lam (\ x. U![. , x]!)) =>  e


| box (. . letn W![.]! (\ x. U![.,x]!))  => 

       eval (box ( . U![. , W![.]! ]!))


| box(. . fix (\ x. U![. , x]!))  =>  

       eval (box (. U![. ; fix (\ x. U![. , x]!) ]!))

);


% Call-By-Value 
rec eval' : (exp)[.] -> (exp)[.] = 
fn e => 

(case e of

   box(. . suc U![.]!)  =>

    (case (eval' (box( . U![.]!))) of       
      box(. . V![.]!)  => box( . suc V![.]!))

| box(. . app U![.]! W![.]!) => 

    (case (eval' (box (. U![.]!))) of
       box(. . lam (\ x. V![.,x]!))  => 

          (case (eval' (box (. W![.]!))) of 
       	     box(. . V2![.]!) => 
                   eval' (box( . V![., V2![.]! ]!))
          )
    )
        
| box(. . lam (\ x. U![. , x]!)) =>  e


| box (. . letv W![.]! (\ x. U![.,x]!)) => 

     case (eval' (box ( . W![.]!))) of 
          box (. . V![.]!) => 
               eval' (box ( . U![. , V![.]! ]!))

);
