tm: type.
app: tm -> tm -> tm.
lam: (tm -> tm) -> tm.

aeq: tm -> tm -> type.
ae_l: ({x:tm} aeq x x -> aeq (M x) (N x))
          -> aeq (lam (\x. M x)) (lam (\x. N x)).
ae_a: aeq M1 N1 -> aeq M2 N2 -> aeq (app M1 M2) (app N1 N2).

schema xG = tm;
schema xaG = block x:tm, u:aeq x x;

datatype CtxRel : {phi:xG} {psi: xaG} {#S:phi[psi]} ctype =
| Empty : CtxRel [] [] [ $ ^ ]
| Dot   : CtxRel [phi] [psi] [psi $ #S[..] ]
           -> CtxRel [phi, x:tm] [psi, b: block (x:tm,u:aeq x x)] [ psi, b $ #S[..] b.1 ]
;


rec refl : {phi:xG}{M: [phi . tm]}
          CtxRel [phi] [psi] [ psi $ #S[..] ] ->
          [psi . aeq (M #S[..]) (M #S[..])] =
mlam phi => mlam M => fn cr => case [phi . M ..] of
 | [phi, x:tm . x] =>
   let Dot cr' = cr in
   let (cr' : CtxRel [phi] [psi] [ psi $ #S[..] ]) = cr' in
     [psi, b: block (x:tm, u:aeq x x) . b.2]

| [phi, x:tm . #p ..] =>
  let Dot cr' = cr in
  let [psi. E ..] =  refl [phi] [phi.#p..] cr' in
      [psi, b: block (x:tm,u:aeq x x) . E .. ]

| [phi . app (M .. ) (N ..)] =>
  let [psi. D1 .. ] = refl [phi] [phi.M ..] cr in
  let [psi. D2 .. ] = refl [phi] [phi.N ..] cr in
    [psi. ae_a (D1 ..) (D2 ..) ]


 | [phi . lam \x.M .. x] =>
  let [psi, b:block (x:tm, u:aeq x x). D .. b.1 b.2] =
      refl [phi, x:tm] [phi,x:tm. M .. x]  (Dot  cr) in
  [psi. ae_l \x.\u. D .. x u]


 ;
