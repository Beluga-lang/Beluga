% Natural Deduction - Hilbert Translation
% adapted from Handbook article on Logical Frameworks
% by F. Pfenning
%
% Author: Brigitte Pientka
%
% Comment: 
% - This is a good example to 
%   illustrate the differences
%   between Twelf, Delphin and our language.
% - illustrate the need for context schema
%   subsumption
% - proper context coercions should be added
% - should be extended to include the proof
%   that every Hilber-style derivation has 
%   a natural deduction derivation

i : type.  % individual
o : type.  % formulas

imp : o -> o -> o.  
all : (i -> o) -> o.
not : o -> o.     

nd : o -> type. % Natural deduction
impi : (nd A -> nd B) -> nd (imp A B).
impe : nd (imp A B) -> nd A -> nd B.
noti : ({p:o} nd A -> nd p) -> nd (not A).
note : nd (not A) -> {C:o} nd A -> nd C.
alli : ({a:i} nd (A a)) -> nd (all (\x. A x)).
alle : nd (all (\x. A x)) -> {T:i} nd (A T).

hil : o -> type.  % Hilbert deductions
k  : hil (imp A (imp B A)).
s  : hil (imp (imp A (imp B C)) (imp (imp A B) (imp A C))).
n1 : hil (imp (imp A (not B)) (imp (imp A B) (not A))).
n2 : hil (imp (not A) (imp A B)).
f1 : {T:i} hil (imp (all (\x.A x)) (A T)).
f2 : hil (imp (all (\x.(imp B  (A x))))  (imp B (all (\x.A x)))).
mp : hil (imp A B) -> hil A -> hil B.
ug : ({a:i} hil (A a)) -> hil (all (\x.A x)).

% Implementation of the Deduction Theorem
%
%   If G, u:hil A |- hil B then G |- hil (A imp B).
%

schema w =  i + some [ a:o ] hil a;

 rec ded: {g:(w)*} 
    (hil (B ..))[g, u:hil (A ..)] -> (hil (imp (A ..) (B ..)))[g] = 
 FN g => fn h =>  
 case h of 
   [g, u: hil _ ] #p .. =>  [g] mp k #p ..  % SPECIAL!

% Can only be done by giving type annotation to k or s in
% the output; this is also done in the Twelf implementation
% 
% ded_id : ded ([u:hil A] u) (mp (mp s k) (k : hil (A imp (A imp A)))).
% | [g, u: hil _ ] u     => [g] (mp (mp s k) k)
 | [g, u: hil _ ] k  => [g] mp k k
 | [g, u: hil _ ] n1 => [g] mp k n1
 | [g, u: hil _ ] n2 => [g] mp k n2
 | [g, u: hil _ ] f1 (T ..) => [g]  mp k (f1 (T ..))
 | [g, u: hil _ ] f2 => [g] mp k f2

 | [g, u: hil (A ..)] ug (\x. (H .. x u)) => 
  let      
    [g,x:i] (H' .. x) = 
      ded [g, x:i]  ([g, x, u]  (H .. x u))
  in
     [g] mp f2 (ug  \x. (H' .. x))

| {H1 :: (hil (imp (B1 ..) (B2 ..)))[g, u : hil (A ..)]}
  {H2 :: (hil (B1 ..))[g, u : hil (A ..)]}
  [g, u: hil (A ..) ] (mp (H1 .. u) (H2 .. u)) => 
  let [g] H2' .. = ded [g] ([g,u] H2 .. u) in
  let [g] H1' .. = ded [g] ([g,u] H1 .. u) in
       [g] mp (mp s (H1' ..)) (H2' ..)

;

% % Theorem: If G |- nd A  where G = nd B1 .... nd Bn 
% %          then G* |- hil A   where G' = hil B1 ... hil Bn

% schema l = i + o + some [a:o] block u:nd A . hil A ; % where l < w 
% DOES NOT RAISE AN ERROR!!! -- THERE IS NO CHECK THAT A GIVEN SCHEMA
% IS WELL-FORMED.

schema l = i + o + some [a:o] block u:nd a . hil a ; % where l < w 

 rec ndhil : {g:(l)*} (nd (A ..))[g] -> (hil (A .. ))[g] =
 FN g => fn d => 
 case d of 
   [g] (#p.1 ..) => [g] (#p.2 ..)
%{
 | [g] impi \u. D .. u => 
   let [g,u: block x:nd (A ..). hil (A ..)] H .. u = 
     ndhil [g, u:block x:nd (A ..).hil (A ..) ] ([g,u] D .. u.1)
   in
     % NOTE HERE WE NEED THE FACT THAT l < w !!!
       ded [g] ([g,u] H .. u)
}%

 | [g] impe (D1 ..) (D2 ..) => 
   let [g] H1 .. = ndhil [g] ([g] D1 ..) in		
   let [g] H2 .. = ndhil [g] ([g] D2 ..) in 
       [g] mp (H1 ..) (H2 ..)

%{ | [g] noti \p.\u.D .. p u => 
   let [g,p:o,w:nd (A ..)]  H .. w p = 
     ndhil [g, p:o, w : block n:nd (A ..) . hil (A ..)]   ([g,p, w] D .. p w.1) in 
       % NOTE HERE WE NEED THE FACT THAT l < w !!!
   let [g] H1' .. = ded [g]  ([g,w] H .. w (not (A ..))) in 
       % NOTE HERE WE NEED THE FACT THAT l < w !!!
   let [g] H1'' .. = ded [g] ([g,w] H .. w (A ..)) in
     [g] mp (mp n1 (H1' ..)) (H1'' ..)
}%
 | [g] note (D1 ..) (C ..) (D2 ..) => 
   let [g] H1 ..   = ndhil [g]  ([g]D1 ..) in
   let [g] H2 ..   = ndhil [g]  ([g]D2 ..) in
     [g] mp (mp n2 (H1 ..)) (H2 ..)

 | [g] alle  (D1 ..) T => 
   let [g]H1 .. =  ndhil [g] ([g] D1 ..) in
      [g] mp (f1 T) (H1 ..)

 | [g] alli \x. D .. x => 
   let [g,x:i] H .. x =  ndhil [g, x:i] ([g, x] D .. x) in 
     [g] ug \x. (H .. x)

;
