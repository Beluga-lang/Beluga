LF tp: type =
  | bool: tp
  | nat: tp
  | arrow: tp -> tp -> tp
;
--name tp T.

LF term : tp -> type =
  | z    : term nat
  | s    : term nat -> term nat
  | lam  : (term T -> term T') -> term (arrow T T')
  | app  : term (arrow T T') -> term T -> term T'
;
--name term E x.

schema tctx = some [t:tp] term t;
% schema W = term nat;

rec copy : (g:tctx) [g |- term (T[])] -> [g |- term (T[])] =
/ total e (copy _ _ e) /
fn e => case e of
| [g |- #p]    => [g |- (#p)]

| [g |- z]      => [g |- z]

| [g |- s E] =>
  let [g |- F] = copy [g |- E ] in
     [g |- s F]

| [g |- lam  (\x. U)] =>
  let [g,x : term _  |- V] = copy  [g,x: term _ |- U]  in % [g, x:term _ ]
    [g |- lam  (\x. V)]


| [g |- app E1 E2] =>
  let [g |- (F1 )] = copy [g |- E1] in
  let [g |- (F2 )] = copy [g |- E2] in
    [g |- app F1 F2]

;


let t = copy [ |- z] ;

let t = copy [x:term nat |-  x];

let t = copy [x:term _ |-  s x];

let t : [ |- term (arrow nat nat)] =
     copy  [ |- lam \x. x];

let t : [ |- term (arrow (arrow bool nat) (arrow bool nat))]
     = copy [ |- lam \x. (lam \y. app x y)];

let t = copy [y:term (arrow (arrow (arrow bool nat) (arrow bool nat)) nat) |-  app y (lam \x. (lam \y. app x y))];

let t = copy [y:term nat,x:term bool |-  s y];
