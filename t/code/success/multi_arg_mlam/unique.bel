% Definition of types and expressions
tp: type.  --name tp T.
arr: tp -> tp -> tp.
nat: tp.

exp: type. --name exp E.
lam : tp -> (exp -> exp) -> exp.
app : exp -> exp -> exp.

% Typing judgment
type_of: exp -> tp -> type. --name type_of H.

t_lam: ({x:exp}type_of x T1 -> type_of (E x) T2)
        -> type_of (lam T1 E) (arr T1 T2).

t_app: type_of E1 (arr T2 T) -> type_of E2 T2
       -> type_of (app E1 E2) T.


% Equality predicate

eq: tp -> tp -> type.
e_arr:  eq T1 S1 -> eq T2 S2
        -> eq (arr T1 T2) (arr S1 S2).

e_nat: eq nat nat.


% Reflexivity is admissible:
% Theorem: For all types T:tp, eq T T.
rec refl : {T:[ |- tp]}[ |- eq T T] =
mlam T => case [ |- T] of
 | [ |- nat] => [ |- e_nat]
 | [ |- arr T1 T2] =>
   let [ |- D1] = refl [ |- T1 ] in
   let [ |- D2] = refl [ |- T2 ] in
     [ |- e_arr D1 D2]
;


% Uniqueness of typing
%{Theorem:
  If  G |- type_of E T  and G |- type_of E T'
  then  equal T T'.

Proof by induction on E.
}%
% block l = some [t:tp] block x:exp. type_of x t;
% world tctx = l

schema tctx = some [t:tp] block (x:exp, _t:type_of x t);


rec unique : {g:tctx}{E:[g |- exp]} [g |- type_of (E[..]) T[]] -> [g |- type_of (E[..]) T'[]]
             ->  [ |- eq T T'] =
mlam g, E => fn d, f => case [g |- E[..] ] of
 | [g |- app (E1[..] ) (E2[..] )] =>
  let [g |- t_app (D1[..]) (D2[..])] = d in
  let [g |- t_app (F1[..]) (F2[..])] = f in
  let [ |- e_arr C1 C2] = unique [g] [g |- E1[..] ] [g |- D1[..]] [g |- F1[..]] in
    [ |- C2]

| [g |- lam T1[] (\x. E)] =>
  let [g |- t_lam (\x.(\u. D))] = d in
  let [g |- t_lam (\x.(\u. F))] = f in
  let [ |- C2] = unique [g,b: block x:exp, _t:type_of x T1[]]
                      [g,b |- E[..,b.1] ] [g,b |- D[..,b.1,b.2]] [g,b |- F[..,b.1,b.2]] in
 let [ |- C1] = refl [ |- T1 ] in
   [ |- e_arr C1 C2]

| [g |- #p.1[..]] =>
   % #p: l          block a:exp. type_of a R
   % d : (type_of (#p.1[..]) T)[g]
   % f : (type_of (#p.1[..]) T')[g]

  let [g |- #q.2[..]] = d  in  % d : type_of #p.1 T
   % #q : block y:exp. type_of y S
   % #q.2 : type_of (#q.1[..]) S  = d : type_of (#p.1[..]) T
   %  S = T  #q = #p, S = R

  let [g |- #r.2[..]] = f  in  % f : type_of #p.1 T'
   % #r : block y:exp. type_of y S'
   % #r.2 : type_of (#r.1[..]) S'  = f : type_of (#p.1[..]) T'
   % S' = T' ,  #r=#p  , R = S'

    refl [ |- _ ]

;



% Equality predicate
equal: tp -> tp -> type.
e_ref: equal T T.

rec unique2 : {g:tctx}{E:[g |- exp]} [g |- type_of (E[..]) T[]] -> [g |- type_of (E[..]) T'[]]
             ->  [ |- equal T T'] =
mlam g, E => fn d, f => case [g |- E[..] ] of
| [g |- app (E1[..] ) (E2[..] )] =>
  let [g |- t_app (D1[..]) (D2[..])] = d in
  let [g |- t_app (F1[..]) (F2[..])] = f in
  let [ |- e_ref]  = unique2 [g] [g |- E1[..] ] [g |- D1[..]] [g |- F1[..]] in
    [ |- e_ref]

| [g |- lam T1[] (\x. E)] =>
  let [g |- t_lam (\x.(\u. D))] = d in
  let [g |- t_lam (\x.(\u. F))] = f in
  let [ |- e_ref] = unique2 [g,b: block x:exp, _t:type_of x T1[]]
                      [g,b |- E[..,b.1] ] [g,b |- D[..,b.1,b.2]] [g,b |- F[..,b.1,b.2]] in
   [ |- e_ref]

| [g |- #p.1[..]] =>
  let [g |- #q.2[..]] = d  in  % d : type_of #p.1 T
  let [g |- #r.2[..]] = f  in  % f : type_of #p.1 T'
    [ |- e_ref]

;

% Equality predicate
equal: tp -> tp -> type.
e_ref: equal T T.

rec unique3 : (g:tctx)[g |- type_of (E[..]) T[]] -> [g |- type_of (E[..]) T'[]]
             ->  [ |- equal T T'] =
fn d, f => case d of
| [g |- t_app (D1[..]) (D2[..])] =>
  let [g |- t_app (F1[..]) (F2[..])] = f in
  let [ |- e_ref]  = unique3 [g |- D1[..]] [g |- F1[..]] in
    [ |- e_ref]

| [g |- t_lam (\x.\u. D)] =>
  let [g |- t_lam (\x.\u. F)] = f in
  let [ |- e_ref] = unique3 [g,b: block x:exp, _t:type_of x _ |-  D[..,b.1,b.2]] [g,b |- F[..,b.1,b.2]] in
   [ |- e_ref]

| [g |- #q.2[..]] =>           % d : type_of #q.1 T
  let [g |- #r.2[..]] = f  in  % f : type_of #q.1 T'
    [ |- e_ref]
;
