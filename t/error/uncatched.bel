% Type-preserving closure conversion.
% Author: Olivier Savary B. 
%

% Types

datatype tp: type =   
| int: tp
| arr  : tp -> tp -> tp
| code : tp -> tp -> tp
| cross: tp -> tp -> tp
| unit :tp
;
%name tp T.

% Source language 
datatype term: tp -> type =   
| elam: (term T -> term S) -> term (arr T S)
| eapp: term (arr T S) -> term T -> term S
| elet: term T -> (term T -> term S) -> term S
| ez: term int
| esuc: term int -> term int
;
%name term M.

% Target language 
datatype target: tp -> type =     
| bottom: target T
| tunit : target unit
| tfst  : target (cross T S) -> target T
| tsnd  : target (cross T S) -> target S
| tpair : target T -> target S -> target (cross T S)
| tapp  : target (code T S) -> target T -> target S
| tlam  : (target T -> target S) -> target (code T S)
| tlet  : target T -> (target T -> target S) -> target S
% We write E for the type of the environment
| tpack : {E:tp} target (cross (code (cross T E) S) E)
       -> target (arr T S)
| topen : target (arr T S)
       -> ({e:tp} target (cross (code (cross T e) S) e) -> target S')
       -> target S'
| tz: target int
| tsuc: target int -> target int
;
%name target Q.

% Natural Numbers     
datatype nat: type =  
| z:nat
| suc: nat -> nat
;
%name nat N.                       


% List of free variables occurring in a term
datatype fvlist: tp -> type =
| nil: fvlist unit
| cons: term T -> fvlist S -> fvlist (cross T S)
;
%name fvlist F.

% ----------------------------------------------------------------------

% Define contexts for source and target language
schema ctx = term T;
schema tctx = target T;



rec b_env:(g:ctx){h:tctx} 
          ({T:[. tp]} [g. term T] -> [h. target T]) 
	  -> [g. fvlist R] 
	  -> [h. target R] =
mlam h => fn map => fn fvar => case fvar of
| [g. nil] =>
    [h. tunit]
| {T:[. tp]}{E:[g. term T]}{Ta:[g. fvlist S]}
  [g. cons (E..) (Ta..)] => 
  let [h. (E'..)] = map [. _ ] [g. E..] in
  let [h. (Ta'..)] = b_env [h] map [g. Ta.. ] in
    [h. tpair (E'..) (Ta'..)]
;

