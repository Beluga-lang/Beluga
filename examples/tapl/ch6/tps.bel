%{
   Exceptions
}%
tp: type.
nat: tp.
arr: tp -> tp -> tp.

term: type.

app: term -> term -> term.
lam: tp -> (term ->  term) -> term.

value:  term -> type.
v_lam: value (lam T M).


% ---------------------------------------------------------- %
% Small-step operational semantics

step: term -> term -> type.

step_app_1    : step (app E1 E2) (app E1' E2)
                 <- step E1 E1'.
step_app_2    : step (app E1 E2) (app E1 E2')
                 <- value E1
                 <- step E2 E2'.

step_app_beta : step (app (lam T E ) E2) (E E2)
                 <- value E2.


% ---------------------------------------------------------- %
oft: term -> tp -> type.

t_lam : ({x:term} oft x T -> oft (E x) S)
	-> oft (lam T E) (arr T S).
t_app:  oft E1 (arr T S) -> oft E2 T
	-> oft (app E1 E2) S.


% ---------------------------------------------------------- %
rec tps: [.oft M T] -> [.step M N] -> [.oft N T] = 
fn d => fn s => case s of 
| [.step_app_1 S1] => 
  let [. t_app D1 D2] = d in 
  let [. F1] = tps  [. D1] [. S1] in 
    [. t_app F1 D2 ]

| [. step_app_2 S2 _ ] => 
  let [. t_app D1 D2] = d in 
  let [. F2] = tps  [. D2] [. S2] in 
    [. t_app D1 F2] 

| [. step_app_beta V] => 
  let [. t_app (t_lam \x.\u. D x u) D2] = d in 
    [. D _ D2]

;
