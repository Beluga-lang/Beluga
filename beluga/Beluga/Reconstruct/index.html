<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Reconstruct (beluga.Beluga.Reconstruct)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.3.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">beluga</a> &#x00BB; <a href="../index.html">Beluga</a> &#x00BB; Reconstruct</nav><header class="odoc-preamble"><h1>Module <code><span>Beluga.Reconstruct</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-solve_fvarCnstr"><a href="#val-solve_fvarCnstr" class="anchor"></a><code><span><span class="keyword">val</span> solve_fvarCnstr : <span><a href="../Lfrecon/index.html#type-reconType">Lfrecon.reconType</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset_fvarCnstr"><a href="#val-reset_fvarCnstr" class="anchor"></a><code><span><span class="keyword">val</span> reset_fvarCnstr : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-case_type"><a href="#type-case_type" class="anchor"></a><code><span><span class="keyword">type</span> case_type</span></code></div><div class="spec-doc"><p>Type of case to reconstruct. Either a plain data object, or an index object. In the case of an index object, we store the scrutinee in order to correctly implement dependent pattern matching.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-case_type"><a href="#val-case_type" class="anchor"></a><code><span><span class="keyword">val</span> case_type : 
  <span><span><a href="../../Synint/Comp/index.html#type-pattern">Beluga_syntax.Int.Comp.pattern</a> <span class="xref-unresolved">Stdlib</span>.Lazy.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-case_type">case_type</a></span></code></div><div class="spec-doc"><p>Analyzes the given case scrutinee to decide what kind of case we have. The case type is used by other elaboration functions to generate appropriate substitutions. (Specifically, see synPatRefine, which is the main consumer of case_type.)</p><p>The given pattern is passed lazily as it is only needed when the synthesizable expression happens to be a box. (This is related to the implementation of dependent pattern matching.) If you know that the synthesizable expression is definitely not a box, then you can pass lazy (Error.raise_violation &quot;appropriate message&quot;) as the pattern.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_case_type"><a href="#val-map_case_type" class="anchor"></a><code><span><span class="keyword">val</span> map_case_type : 
  <span><span>(<span><span>(<a href="../../Synint/Comp/index.html#type-pattern">Beluga_syntax.Int.Comp.pattern</a> * <a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Int.Comp.meta_obj</a>)</span> <span class="arrow">&#45;&gt;</span></span>
    <a href="../../Synint/Comp/index.html#type-pattern">Beluga_syntax.Int.Comp.pattern</a> * <a href="../../Synint/Comp/index.html#type-meta_obj">Beluga_syntax.Int.Comp.meta_obj</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-case_type">case_type</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-case_type">case_type</a></span></code></div><div class="spec-doc"><p>Transforms a case_type if it was actually an index object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-synPatRefine"><a href="#val-synPatRefine" class="anchor"></a><code><span><span class="keyword">val</span> synPatRefine : 
  <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-case_type">case_type</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> * <a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Int.LF.msub</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Int.LF.msub</a>
  * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Int.LF.msub</a>
  * <a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a></span></code></div><div class="spec-doc"><p>Constructs the refinement substitution for a case analysis. If * cD; cG |- tau_s &lt;= type * cD'; cG' |- tau_p &lt;= type * cD' |- t : cD * if caseT = IndexObj C then</p><ul><li>tau_s = <code>U</code></li><li>cD; cG |- C &lt;= U then synPatRefine' loc caseT (cD, cD') t (tau_s, tau_p) = t', t1', cD'' such that * cD'' |- t' : cD * cD'' |- t1' : cD'</li></ul><p>Remark: * cD'' is the meta-context in which the branch of the case should be elaborated. * t' is just t1' composed with t.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span><span class="keyword">val</span> kind : <span><a href="../../Synapx/LF/index.html#type-kind">Beluga_syntax.Apx.LF.kind</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/LF/index.html#type-kind">Beluga_syntax.Int.LF.kind</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typ"><a href="#val-typ" class="anchor"></a><code><span><span class="keyword">val</span> typ : 
  <span><a href="../Lfrecon/index.html#type-reconType">Lfrecon.reconType</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/LF/index.html#type-typ">Beluga_syntax.Apx.LF.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/LF/index.html#type-typ">Beluga_syntax.Int.LF.typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-schema"><a href="#val-schema" class="anchor"></a><code><span><span class="keyword">val</span> schema : <span><a href="../../Synapx/LF/index.html#type-schema">Beluga_syntax.Apx.LF.schema</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/LF/index.html#type-schema">Beluga_syntax.Int.LF.schema</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mctx"><a href="#val-mctx" class="anchor"></a><code><span><span class="keyword">val</span> mctx : <span><a href="../../Synapx/LF/index.html#type-mctx">Beluga_syntax.Apx.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compkind"><a href="#val-compkind" class="anchor"></a><code><span><span class="keyword">val</span> compkind : <span><a href="../../Synapx/Comp/index.html#type-kind">Beluga_syntax.Apx.Comp.kind</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/Comp/index.html#type-kind">Beluga_syntax.Int.Comp.kind</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-comptyp"><a href="#val-comptyp" class="anchor"></a><code><span><span class="keyword">val</span> comptyp : <span><a href="../../Synapx/Comp/index.html#type-typ">Beluga_syntax.Apx.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-comptyp_cD"><a href="#val-comptyp_cD" class="anchor"></a><code><span><span class="keyword">val</span> comptyp_cD : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/Comp/index.html#type-typ">Beluga_syntax.Apx.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-comptypdef"><a href="#val-comptypdef" class="anchor"></a><code><span><span class="keyword">val</span> comptypdef : 
  <span><a href="../../Syncom/Location/index.html#type-t">Beluga_syntax.Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Syncom/Name/index.html#type-t">Beluga_syntax.Name.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synapx/Comp/index.html#type-typ">Beluga_syntax.Apx.Comp.typ</a> * <a href="../../Synapx/Comp/index.html#type-kind">Beluga_syntax.Apx.Comp.kind</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>(<a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> * <a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a>)</span>
  * <a href="../../Syncom/Id/index.html#type-offset">Beluga_syntax.Id.offset</a>
  * <a href="../../Synint/Comp/index.html#type-kind">Beluga_syntax.Int.Comp.kind</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-elExp"><a href="#val-elExp" class="anchor"></a><code><span><span class="keyword">val</span> elExp : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/Comp/index.html#type-exp">Beluga_syntax.Apx.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Int.LF.msub</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-elExp'"><a href="#val-elExp'" class="anchor"></a><code><span><span class="keyword">val</span> elExp' : 
  <span><a href="../../Synint/LF/index.html#type-mctx">Beluga_syntax.Int.LF.mctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/Comp/index.html#type-exp">Beluga_syntax.Apx.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a> * <a href="../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Int.Comp.tclo</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span><span class="keyword">val</span> exp : 
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/Comp/index.html#type-exp">Beluga_syntax.Apx.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Int.LF.msub</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exp'"><a href="#val-exp'" class="anchor"></a><code><span><span class="keyword">val</span> exp' : 
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/Comp/index.html#type-exp">Beluga_syntax.Apx.Comp.exp</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-exp">Beluga_syntax.Int.Comp.exp</a> * <a href="../../Synint/Comp/index.html#type-tclo">Beluga_syntax.Int.Comp.tclo</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-thm"><a href="#val-thm" class="anchor"></a><code><span><span class="keyword">val</span> thm : 
  <span><a href="../../Synint/Comp/index.html#type-gctx">Beluga_syntax.Int.Comp.gctx</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synapx/Comp/index.html#type-thm">Beluga_syntax.Apx.Comp.thm</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> * <a href="../../Synint/LF/index.html#type-msub">Beluga_syntax.Int.LF.msub</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-thm">Beluga_syntax.Int.Comp.thm</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-numeric_order"><a href="#val-numeric_order" class="anchor"></a><code><span><span class="keyword">val</span> numeric_order : 
  <span><a href="../../Synint/Comp/index.html#type-typ">Beluga_syntax.Int.Comp.typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Synint/Comp/index.html#type-order">Beluga_syntax.Int.Comp.order</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../Synint/Comp/index.html#type-order">Beluga_syntax.Int.Comp.order</a></span></code></div></div></div></body></html>
