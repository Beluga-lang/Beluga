% This is the soundness proof also given in ceval-sound.bel
% but we choose to make the continuation explicit in the
% definition of result. The key is that we need information
% about K since it occurs in a non-pattern position 
% which we may not be able to resolve when we reconstruct
% the pattern in branches, especially when we analyze the
% result of an induction hypothesis (recursive call).	

eval_step: exp -> cont -> val -> type.

result : {K:cont} eval_step E K W
      <- mstep (st K (return V))  (answer W)
      <- eval E V.

rec csd : (mstep (st K (ev E)) (answer W))[ ]
       -> (eval_step E K W)[ ] = 
fn c => case c of 

  [ ] << C' st_z => [ ] result _ ev_z C'
 
| [ ] << C1 st_s => 
  let [ ] result _ D1 (<< C' st_return)  = csd ([ ] C1) in 
   [ ] result _ (ev_s D1) C'

  | [ ] << C1 st_match  => 
     (case csd ([ ] C1) of 
     [ ] result (c K  (\x1. match1 x1 E2 (\x. (E3 x)))) D1 (<< (<< C2 st_match1_z) st_return) => 
       let [ ] result _ D2 C' = csd ([ ] C2) in 
         [ ] result _ (ev_match_z D2 D1) C' 

    | [ ] result(c K  (\x1. match1 x1 E2 (\x. (E3 x)))) D1 (<< (<< C3 st_match1_s)  st_return)  => 
        let [ ] result _ D3 C' = csd ([ ] C3) in 
         [ ] result _ (ev_match_s D3 D1) C'			     
    ) 

  | [ ] (<< C1 st_pair) => 
     let [ ] result (c K  (\x1. pair1 x1 E2)) D1 (<< (<< C2 st_pair1) st_return) = csd ([ ] C1) in 
     let [ ] result (c K (\x2. return (pair_val V1 x2))) D2 (<< C' st_return)    = csd ([ ] C2) in 
       [ ] result _ (ev_pair D2 D1) C'															

  | [ ] (<< C1 st_fst) => 
     let [ ] result (c K  (\x. fst1 x)) D1 (<< (<< C' st_fst1) st_return) = csd ([ ] C1) in 
       [ ] result _ (ev_fst D1) C'						       

  |  [ ] (<< C1 st_snd) => 
     let [ ] result (c K  (\x. snd1 x)) D1 (<< (<< C' st_snd1) st_return) = csd ([ ] C1) in 
       [ ] result _ (ev_snd D1) C'						       


  | [ ] (<< C' st_lam) => [ ] result _ (ev_lam) C'


  | [ ] (<< C1 st_app) =>
    let [ ] result (c K  (\x1. app1 x1 E2)) 
                   D1 (<< (<< C2 st_app1) st_return) = csd ([ ] C1) in 
    let [ ] result (c K (\x2. app2 (lam_val (\x. (E1' x))) x2)) 
	           D2 (<< (<< C3 st_app2) st_return) = csd ([ ] C2) in 
    let [ ] result K D3 C'  = csd ([ ] C3) in 
      [ ] result _ (ev_app D3 D2 D1) C'   

  | [ ] (<< C1 st_letv) => 
      let [ ] result(c K  (\x1. ev (E2 x1)))  D1 (<< C2 st_return) = csd ([ ] C1) in 
      let [ ] result _ D2 C'                                       = csd ([ ] C2) in 
        [ ] result _ (ev_letv D2 D1) C'

  | [ ] (<< C1 st_letn) => 
      let [ ] result _ D2 C' = csd ([ ] C1) in 
        [ ] result _ (ev_letn D2) C'

  | [ ] (<< C1 st_fix) => 
      let [ ] result _ D1 C' = csd ([ ] C1) in 
        [ ] result _ (ev_fix D1) C'

 | [ ] (<< C' st_vl) => [ ] result _ ev_vl C'
;


 rec ceval_sound : (ceval E V)[ ] -> (eval E V)[ ] =
 fn c => let [ ] cev C = c in 
         let [ ] result _ D (<< stop st_init) = csd ([ ] C) in 
           [ ] D
 ;					      
 
