% Definition of types and expressions
tp: type.  %name tp T.
arr: tp -> tp -> tp.
nat: tp.

exp: type. %name exp E.
lam : tp -> (exp -> exp) -> exp.
app : exp -> exp -> exp.

% Typing judgment
type_of: exp -> tp -> type. %name type_of H.

t_lam: ({x:exp}type_of x T1 -> type_of (E x) T2)
        -> type_of (lam T1 E) (arr T1 T2).
          
t_app: type_of E1 (arr T2 T) -> type_of E2 T2
       -> type_of (app E1 E2) T.



schema tctx =  some [t:tp] block x:exp, _t:type_of x t;


% Equality predicate
equal: tp -> tp -> type.
e_ref: equal T T.

rec unique3 : (g:tctx)[g. type_of (E ..) T] -> [g. type_of (E ..) T'] 
             ->  [. equal T T'] = 
fn d => fn f => case d of 
| [g. t_app (D1 ..) (D2 ..)] =>
  let [g. t_app (F1 ..) (F2 ..)] = f in 
  let [. e_ref]  = unique3 [g. D1 ..] [g. F1 ..] in    
    [. e_ref]  

| [g. t_lam (\x.\u. D .. x u)] =>
  let [g. t_lam (\x.\u. F .. x u)] = f in 
  let [. e_ref] = unique3 [g,b: block x:exp, _t:type_of x _. D .. b.1 b.2] [g,b. F .. b.1 b.2] in 
   [. e_ref]  

| [g. #q.2 ..] =>           
  let [g. #r.2 ..] = f  in  
    [. e_ref]

;
