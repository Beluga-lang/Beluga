nat : type.
z : nat.
s : nat -> nat.
s' : nat -> nat.
adding: nat -> nat -> nat.
plus: nat -> nat -> nat.

rec identity : nat [.] -> nat [.] =
    fn x =>
      case x of
          box (. . z)  => box (. z)
        | box (. . s' U ![ . ]!) => box (. s' U ![ . ]!)
        | box (. . s U ![ . ]!)  => box (. s U ![ . ]!)
        | box (. . adding V![.]! U![.]!) => box (. adding V![.]! U![.]!) 
        | box (. . plus V![.]! U![.]!)  => box (. plus V![.]! U![.]!) 
;


rec plus : nat [.] -> nat [.] -> nat [.] = 
fn x => fn y => 
 case x of 
    box (. . z)  => y
 |  box (. . s U ![.]! )  => 
    let 
      box (. . V![.]!)  = plus (box (. U![.]!)) y
    in
      box ( . s V![.]!)
    end;


rec plus' : nat [.] -> nat [.] -> nat [.] = 
  fn x => fn y => 
    case x of box (. . z)  => y
            | box (. . s U![.]!) => 
	      (case (plus' (box (. U![.]!)) y) of 
 	         box (. . V![.]!)  => box ( . s V![.]!));



