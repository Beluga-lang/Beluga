#opts +strengthen;
%
% Problem 2: Elimination of Administrative Redices
% Author: Brigitte Pientka
%


tp : type.
o : tp.
arr : tp -> tp -> tp.

exp   : tp -> type.
value : tp -> type.

app   : exp (arr A B) -> exp A -> exp B.
lam   : (value A -> exp B) -> value (arr A B).
ret   : value A -> exp A.


contra : type.
cvalue : tp -> type.
capp   : cvalue (arr A B) -> cvalue A -> (cvalue B -> contra) -> contra.
clam   : (cvalue A -> (cvalue B -> contra) -> contra) -> cvalue (arr A B).


% Translating values to cvalues
% and exp to cexp
schema ctx = some [a:tp] block x:value a, _t:cvalue a ;

rec cps : {g:ctx}[g |- value A] -> [g |- cvalue A] =
mlam g => fn v => case v of
| [g |- #p.1 ..] => [g |- #p.2 ..]
| {E:[g, x:value A |-  exp B]} % Explicit type annotation for E is necessary
  [g |- lam \x. E .. x] =>        % because we need the type A in the recursive call

  let [g, b:block (x:value A , _t:cvalue A), c:cvalue B -> contra |-  E' .. b.2 c] =
      cpse [g,b:block x:value A , _t:cvalue A] [g, b |-  E .. b.1 ] in
    [g |- clam \v.\c. E' .. v c]


and cpse : {g:ctx}[g |- exp A] -> [g, c: cvalue A -> contra |-  contra] =
mlam g => fn e => case e of
| [g |- ret (V .. )] =>
  let [g |- V' ..] = cps [g] [g |- V .. ] in
    [g,c |- c (V' .. )]

| [g |- app (E1 .. ) (E2 .. )] =>
  let [g, c:cvalue (arr B A) -> contra |-  E1' .. c] = cpse [g] [g |- E1 .. ] in
  let [g, c:cvalue B         -> contra |-  E2' .. c] = cpse [g] [g |- E2 .. ] in
    [g,c |- E1' .. (\f. E2' .. (\x. capp f x c))]

;
%{
% Twelf Solution

cps : value A -> cvalue A -> type.
%mode cps +X1 -X2.

cpse : exp A -> ((cvalue A -> contra) -> contra) -> type.
%mode cpse +X1 -X2.

cps/lam : cps (lam (E : value A -> exp B))
              (clam (E' : cvalue A -> (cvalue B -> contra) -> contra))
              <- ({x:value A}{x':cvalue A} cps x x' -> cpse (E x) (E' x')).

cpse/app : cpse (app (E1:exp (B => A)) (E2:exp B))
                ([c : (cvalue A -> contra)] E1' ([f:cvalue (B => A)]
                                                   E2' ([x:cvalue B]
                                                          capp f x c)))
                <- cpse E1 (E1':(cvalue (B => A) -> contra) -> contra)
                <- cpse E2 (E2':(cvalue B -> contra) -> contra).
cpse/ret : cpse (ret (V:value A)) ([c:(cvalue A -> contra)] c V')
                <- cps V (V':cvalue A).

%block cpsb : some {A : tp} block {x : value A} {x' : cvalue A} {d : cps x x'}.
%worlds (cpsb) (cps _ _) (cpse _ _).
%total (E V) (cps E _) (cpse V _).
}%
