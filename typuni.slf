/* tp: type.  
arr: tp -> tp -> tp.
nat: tp.

exp: type. 
lam : tp -> (exp -> exp) -> exp.
app : exp -> exp -> exp.


% Typing judgment

type_of: exp -> tp -> type. 

t_lam: ({x:exp}type_of x T1 -> type_of (E x) T2)
	-> type_of (lam T1 E) (arr T1 T2).
	  
t_app: type_of E1 (arr T2 T) -> type_of E2 T2
       -> type_of (app E1 E2) T.


% Equality predicate

equal: tp -> tp -> type.
e_ref: equal T T.

% -------------------------------------------------------------------------
% Uniqueness of typing
%{
  Theorem: 
  If  G |- type_of E T  and G |- type_of E T'  
  then  equal T T'.

Proof by induction on E.
}%


schema tctx =  some [t:tp] block x:exp. type_of x t;*/

terminals lam app nat fun
syntax 

tp ::= tp -> tp | nat | x ;

exp ::= lam \x .exp[x] | app exp exp; 

judgment of_typ : exp oft tp;

E1 oft (T2 -> T);  
E2 oft T2;
------------------------- t_app
(app E1 E2) oft T;

{x:exp} x oft T1;  
E[x] oft T2;
------------------------- t_lam
(lam T1 E) oft (T1 -> T2);

judgment equal : tp = tp;

------------------------- eq_ref
T = T;

Context gamma ::= () | {t:tp} (y:exp) y oft t;

theorem unique : forall D : [g:gamma] Í° E oft T ; F : [g] |- E oft T' exists T = T';

T = T' by induction on d :

case rule

D1: [g] |- E1 oft (T2 -> T);  
D2: [g] |- E2 oft T2;
------------------------------ t_app
[g] |- (app E1 E2) oft T;

is

(T2 -> T) = (T2 -> T') by case analysis on f:

                 case rule

                 F1: [g] |- E1 oft (T2 -> T');  
                 F2: [g] |- E2 oft T2;
                 ------------------------------ t_app
                 [g] |- (app E1 E2) oft T';

                 is 

                 (T2 -> T) = (T2 -> T') by induction hypothesis on D1, F1

                 end case
                 end case analysis

T = T' by rule eq_ref

end case
 
end induction
end theorem
