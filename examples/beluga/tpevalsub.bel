% Type-preserving substitution-based interpreter
%
% Author: Brigitte Pientka
%
% TODO extend with functions and function application

tp   : type.
nat  : tp.
bool : tp.

exp  : tp -> type.  

tt   : exp bool.
ff   : exp bool.

z    : exp nat.
suc  : exp nat -> exp nat.
eq   : exp nat -> exp nat -> exp bool.

iff   : {T:tp} exp bool -> exp T -> exp T -> exp T.
letv : {T1:tp} {T2:tp} exp T1 -> (exp T1 -> exp T2) -> exp T2.

rec equal : (exp nat)[.] -> (exp nat)[.] -> (exp bool)[.] =
fn x => fn y => 
  case x of
    box(. z) : (exp nat)[.] => 
      (case y of
          box(. z) : (exp nat)[.] => box(. tt)

       | {U::(exp nat)[.]} 
         box(. suc U![.]!) : (exp nat)[.] => box(. ff))

  | {U::(exp nat)[.]} 
    box(. suc U![.]!) : (exp nat)[.] => 
      (case y of
         box(. z) : (exp nat)[.] => box(. ff)
      | {V::(exp nat)[.]} 
         box(. suc V![.]!) : (exp nat)[.] 
            => equal box(. U![.]!) box(. V![.]!))
;




rec eval : {T::tp[.]} (exp T![.]!)[.] -> (exp T![.]!)[.] = 
mlam T => fn e => 
  case e of 
    box(. tt) : (exp bool)[.] => box(. tt)

  | box(. ff) : (exp bool)[.] => box(. ff)

  | box(. z)  : (exp nat)[.]  => box(. z)

  | {U::(exp nat)[.]}
    box(. suc U![.]!) : (exp nat)[.] => 
         (case eval <. nat >  box(. U![.]!) of
             {V::(exp nat)[.]} 
             box(. V![.]!) : (exp nat)[.] => box(. suc V![.]!))


  | {U::(exp nat)[.]} {V::(exp nat)[.]}
    box(. eq U![.]! V![.]!) : (exp bool)[.] =>
         equal (eval <. nat >   box(. U![.]!)) 
               (eval <. nat >   box(. V![.]!))

   | {T::tp[.]} {U::(exp bool)[.]} {V::(exp T![.]!)[.]} {W::(exp T![.]!)[.]}
         box(. iff T![.]! U![.]! V![.]! W![.]!) : (exp T![.]!)[.] =>
         (case eval <. bool > box(. U![.]!) of
             box(. tt) : (exp bool)[.] => eval <. T![.]! > box(. V![.]!)
           | box(. ff) : (exp bool)[.] => eval <. T![.]! > box(. W![.]!))

   | {T1::tp[.]} {T2::tp[.]} {U::(exp T1![.]!)[.]} {W::(exp T2![.]!)[. , x:(exp T1![.]!)]}
         box(. letv T1![.]! T2![.]! U![.]! (\ x . W![., x]!)) : (exp T2![.]!)[.] =>

         (case eval <. T1![.]! > box(. U![.]!) of

             {T1'::tp[.]} {V::(exp T1'![.]!)[.]}  
             box(. V![.]!) : (exp T1'![.]!)[.] 
             => eval <. T2![.]! > box(. W![ ., V![.]! ]!))
;
