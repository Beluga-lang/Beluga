% Mechanization of POPLMARK Reloaded challenge:
% Retrieved 26 March 2020
% Sec 3.1: Simply typed Î»-calculus with type-directed reductions
% and
% Sec 3.2: Defining strong normalization

%coverage

% Lemma 3.6: Properties of Multi-Step Reductions

rec m-trans : (g : cxt)
              {M1 : [g |- tm A[]]}
              [g |- mstep M1 M2]
              -> [g |- mstep M2 M3]
              -> [g |- mstep M1 M3] =
/ total ms1 (m-trans g a m1 m2 m3 ms1) /
mlam M1 => fn ms1, ms2 => case ms1 of
  | [_ |- m-refl] => ms2
  | [_ |- m-step S1 MS1'] =>
        let [_ |- MS] = m-trans _ [_ |- MS1'] ms2 in
        [_ |- m-step S1 MS]
;

rec m-app-l : (g : cxt)
              {M : [g |- tm (arr A[] B[])]}
              {M' : [g |- tm (arr A[] B[])]}
              {N : [g |- tm A[]]}
              [g |- mstep M M']
              -> [g |- mstep (app M N) (app M' N)] =
/ total ms (m-app-l g a b m m' n ms) /
mlam M, M', N => fn ms => case ms of
  | [_ |- m-refl] => [_ |- m-refl]
  | [_ |- m-step S MS] =>
        let [_ |- MS'] = m-app-l _ _ [_ |- N] [_ |- MS] in
        [_ |- m-step (s-app-l S) MS']
;

rec m-app-r : (g : cxt)
              {M : [g |- tm (arr A[] B[])]}
              {N : [g |- tm A[]]}
              {N' : [g |- tm A[]]}
              [g |- mstep N N']
              -> [g |- mstep (app M N) (app M N')] =
/ total ms (m-app-r g a b m n n' ms) /
mlam M, N, N' => fn ms => case ms of
  | [_ |- m-refl] => [_ |- m-refl]
  | [_ |- m-step S MS] =>
        let [_ |- MS'] = m-app-r [_ |- M] _ _ [_ |- MS] in
        [_ |- m-step (s-app-r S) MS']
;

rec m-abs : (g : cxt)
            {M : [g, x : tm A[] |- tm B[]]}
            [g, x : tm A[] |- mstep M M']
            -> [g |- mstep (abs \x.M) (abs \x.M')] =
/ total ms (m-abs g a b m m' ms) /
mlam M => fn ms => case ms of
  | [_, x : tm _ |- m-refl] => [_ |- m-refl]
  | [_, x : tm _ |- m-step S MS] =>
        let [_ |- MS'] = m-abs _ [_ |- MS] in
        [_ |- m-step (s-abs \x.S) MS']
;

rec m-subst : (g : cxt)
              {M : [g, x : tm A[] |- tm B []]}
              {N : [g |- tm A []]}
              {N' : [g |- tm A []]}
              [g |- step N N']
              -> [g |- mstep M[.., N] M[.., N']] =
/ total n (m-subst g a b m n) /
mlam M, N, N' => fn s => case [_ |- M] of
  | [_, x : tm _ |- x] =>
        let [_ |- S] = s in
        [_ |- m-step S m-refl]
  | [_, x : tm _ |- #p[..]] => [_ |- m-refl]
  | [_, x : tm _ |- abs \y.M'] =>
        let [_ |- S] = s in
        let [_, y : tm _ |- S'] = m-subst
                                   [_, y : tm _, x : tm _ |- M'[.., x, y]]
                                   _
                                   _
                                   [_ |- S[..]] in
        m-abs _ [_ |- S']
  | [_, x : tm _ |- app M1 M2] =>
        let [_ |- S1] = m-app-l _ _ [_ |- M2[.., N]] (m-subst [_ |- M1] _ _ s) in
        let [_ |- S2] = m-app-r [_ |- M1[.., N']] _ _ (m-subst [_ |- M2] _ _ s) in
        m-trans _ [_ |- S1] [_ |- S2]
;

% Lemma 3.8 : Multi-step Strong Normalization

rec mstep-Sn : (g : cxt)
               {M : [g |- tm A[]]}
               {M' : [g |- tm A[]]}
               [g |- mstep M M']
               -> Sn [g |- M]
               -> Sn [g |- M'] =
/ total s (mstep-Sn g m m' s) /
mlam M, M' => fn s, sn => case s of
  | [_ |- m-refl] => sn
  | [_ |- m-step S MS] =>
        let Sn-acc [_ |- _] r = sn in
        let sn' = r _ [_ |- S] in
        mstep-Sn _ _ [_ |- MS] sn'
;
