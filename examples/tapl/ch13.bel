tp: type.
unit: tp.
ref: tp -> tp.
arr: tp -> tp -> tp.

loc: tp -> type.
term: tp -> type.
tunit: term unit.
tref: term T -> term (ref T).
!  : term (ref T) -> term T.
assign: term (ref T) -> term T -> term unit.
lbl: loc T -> term (ref T).

value: {T:tp}term T -> type.
v_l : value (ref T) (lbl L).
v_u : value unit tunit.

schema lctx = loc T;

% Can only mode non-cyclic environments if we re-use the context
% as an environment; the store is a possibly cyclic set and the store typing
% is context of types.


datatype Env' : {g:lctx} {g':lctx} ctype =
| Empty : Env' [g0] []
| Cons  : {V:[g0.term T]}[g0.value T (V ..)] -> Env' [g0] [g]  -> Env' [g0] [g, l:loc T] ;

datatype Env: {g:lctx} ctype =
Env : Env' [g] [g] -> Env [g] ;

%{
datatype env : type =
| empty : env
| cons  : value T V -> loc T -> env -> env

datatype Env: [g.env] -> ctype =
| Empty : Env [.empty]
| Cons  :
}%


datatype Clo : (g:lctx) {T:[.tp]} [g.term T] -> ctype =
| Clo : Env [g] -> {M:[g.term T]} Clo [.T]  [g.M ..];

datatype Result : [.tp] -> ctype =
| Result : Env [g] -> [g.term T] -> Result [.T];

datatype ValOption : (g:lctx) [g.term T] -> ctype =
| None : ValOption [g.M ..]
| Some : [g.value T (M ..)] -> ValOption [g.M ..]
;


rec is_value : {g:lctx}{M:[g.term T]} ValOption [g.M ..] =
mlam g => mlam M => case [g.M ..] of
| [g. lbl (#p ..)] => Some [g.v_l]
| [g. tunit] => Some [g.v_u]
| [g. E .. ] => None
;

rec lookup :{g:lctx} {#p:[g.loc T]} Env [g] -> Result [.T]  =
mlam g => mlam #p => fn env => case  [g.#p..] of
| [g,l:loc T. l] =>
let Env (Cons [g0.V ..] v env') = env in
   Result env [g0.V ..]
| [g,l:loc T. #p .. ] =>
let Env (Cons v env') = env in
lookup [g] [g.#p ..] env'
;

rec update : {g:lctx} {#p:[g.loc T]} Env [g] -> {V:[g.term T]}[g.value (V ..)]
             -> Env [g]  = ? ;

rec weaken_env : {T:[.tp]} Env' [g] [g] -> Env' [g, l:loc T] [g] = ? ;

rec step : Clo [.T] [g.M .. ] -> Result [. T]  =
fn cl => case cl of
| Clo env  [g. ! (lbl (#p ..))] =>  lookup [g] [g.#p ..] env
| Clo env  [g. ! (E ..)] =>
  let Result env' [h.E' ..] = step (Clo env [g. E .. ] ) in
    Result env' [h. ! (E' ..) ]

% | Clo env [g.tunit] => Result env [g.tunit]

| Clo env [g.tref (E ..)] =>
  case is_value [g] [g.E ..] of
  |{V:[g.term T]}{D:[g. value (V ..)]}
   Some [g.V ..] [g.D ..] =>
   let Env e =  env in
   let e' = weaken_env [.T] e in
      Result (Env (Cons [g, l:loc _.V ..] [g, l:loc _. D ..] e')) [g,l:loc _. lbl l]
  | None => let Result env' [h.E' ..] = step (Clo env [g.E ..]) in
           Result env' [h.tref  (E' ..)]


;

