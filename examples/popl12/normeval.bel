
atomic_tp : type.
tp : type.                %name tp T.
atomic : atomic_tp -> tp.
arr: tp -> tp -> tp.

tm : tp -> type.          %name tm E.
app : tm (arr T S) -> tm T -> tm S.
lam : (tm T -> tm S) -> tm (arr T S).

schema tctx = tm T;

neut : tp -> type.       %name neut R.
norm : tp -> type.       %name norm M.
nlam : (neut T -> norm S) -> norm (arr T S).
rapp : neut (arr T S) -> norm T -> neut S.
embed : neut (atomic P) -> norm (atomic P).

schema ctx = neut T;

datatype NeutVar : {g:ctx} [.tp] -> ctype =
| NeutVar : {#p:[g.neut T]} NeutVar [g] [.T]
;

datatype TmVar : {g:tctx} [.tp] -> ctype =
| TmVar : {#p:[g.tm T]} TmVar [g] [.T]
;
datatype Sem : {g:ctx} [. tp] -> ctype =
| Syn :  [g . neut (atomic P)] -> Sem [g] [ .atomic P]
| Slam : %  {g:ctx}
         %  {A:[.tp]}{B:[.tp]}
         ({h:ctx} ({T:[.tp]} NeutVar [g] [. T] ->  NeutVar [h]  [. T]) -> Sem [h] [ .A] -> Sem [h] [ . B])
           -> Sem [g] [ . arr A B]
;

rec extendSub : (g:ctx)(h:ctx)
               ({T:[.tp]} NeutVar [g] [.T] ->  NeutVar [h] [.T])
            ->  ({T:[.tp]} NeutVar [g, x:neut S] [.T] ->  NeutVar [h, x:neut S] [.T]) =
fn s => let (s : {T:[.tp]} NeutVar [g] [.T] ->  NeutVar [h] [.T]) = s in
(mlam T => fn y => case y of
              | NeutVar [g,x:neut Tx. x ] => NeutVar [h,x:neut Tx. x]
              | NeutVar [g,x:neut Tx. #p .. ] =>
                 let NeutVar [h. #q ..] = s [. T] (NeutVar [g . #p ..]) in
                   NeutVar [h,x:neut Tx. #q ..])
;
rec nsubst :  (g:ctx)(h:ctx)
             ({T:[.tp]} NeutVar [g] [.T]  -> NeutVar [h] [.T])
           -> [g . neut S]
           -> [h . neut S] =
fn s => fn e => case e of
| {#p: [g . neut T]}
  [ g . #p .. ] => let NeutVar [h. #q ..] = s [ . T] (NeutVar [g . #p .. ]) in [h.#q ..]
| {R:[g. neut (arr T S)]}
  [g . rapp (R ..) (N ..)] =>
  let [h . R' .. ] = nsubst s [g . R .. ] in
  let {N':[h. norm T]} [h . N' .. ] = nosubst s [g . N .. ] in
    [h . rapp (R' ..) (N' .. ) ]

and nosubst : (g:ctx)(h:ctx)
              ({T:[.tp]} NeutVar [g] [.T] ->  NeutVar [h] [.T])
	    -> [g . norm S]
            -> [h . norm S] =
fn s => fn n =>
let (s : {T:[.tp]} NeutVar [g] [.T] ->  NeutVar [h] [.T]) = s in
case n of
| {R:[g. neut (atomic P)]} [g . embed (R .. ) ] =>
  let [h . R' .. ] = nsubst s [g . R .. ] in [h . embed (R' .. )]

 | {N:[g,x:neut S . norm S']}
   [g . nlam (\x. N .. x) ]  =>
   let [h,x:neut S. N' .. x] =
    nosubst (extendSub s) [g ,x:neut S. N .. x]
  in
   [h . nlam (\x. N' .. x)]
;

rec subst : (g:ctx)(h:ctx)
	     ({T:[.tp]} NeutVar [g] [ .T] -> NeutVar [h] [.T])
          -> Sem [g] [. A]
          -> Sem [h] [.A] =
fn s => fn e =>
let (s : {T:[.tp]} NeutVar [g] [ .T] -> NeutVar [h] [.T]) = s in
case e of
| Syn [g . R ..] => Syn (nsubst s [g. R ..])
| Slam  f =>
    Slam (mlam h' => fn s' => fn e => f [h'] (mlam T => fn y => s' [.T] (s [.T] y)) e)
;

rec weaken : (g :ctx) {T:[.tp]} NeutVar [g] [.T] -> NeutVar [g,x:neut S] [. T] =
mlam T => fn x => let NeutVar [g.#p ..] = x in NeutVar [g,x:neut _. #p ..]
;

rec extend : (g:tctx)(h:ctx)
  ({T:[.tp]} TmVar [g] [. T] -> Sem [h] [.T]) -> Sem [h] [.S]
-> ({T:[.tp]} TmVar [g, x:tm S] [. T] ->  Sem [h] [.T]) =
fn s => fn e => mlam T => fn x => case x of
| TmVar [g,x:tm S. x] => e
| TmVar [g,x:tm S. #q .. ] => s [. T ] (TmVar [g . #q ..])
;

rec id : (g:ctx)  {T:[.tp]} NeutVar [g] [.  T] -> NeutVar [g] [ . T] =
mlam T => fn y => y ;

rec eval : (g:tctx)(h:ctx)
           ({T:[.tp]} TmVar [g] [. T] -> Sem [h] [.T])
           -> [g. tm S] -> Sem [h] [.S]  =
fn s => fn t =>
let (s : ({T:[.tp]} TmVar [g] [. T] -> Sem [h] [.T])) = s in
case t of
| [g . #p .. ]           : [g. tm S] =>  s [.S] (TmVar [g . #p .. ])
| [g. lam (\x. E .. x) ] : [g . tm (arr A B)] =>
  Slam  (mlam h' => fn s' => fn e =>
         eval (extend (mlam T => fn x => subst s' (s [.T] x))  e)
              [g,x:tm A. E .. x])

| [g. app (E1 ..) (E2 ..) ] =>
  let (Slam f ) : Sem [h] [. arr A B] =  eval s [g . E1 ..] in
    f [h] id (eval s [g . E2 ..])
;


rec reflect : (g:ctx) [g. neut A] ->  Sem [g] [.A] =
fn r => let [g. R .. ] : [g. neut A] = r in
case [. A] of
| [. atomic P ] => Syn [g . R ..]
| [. arr T S ] =>  Slam (extendSem r)

% Lesson: FACTORIZATION OF CODE HELPS TYPE RECONSTRUCTION!!!
and extendSem : [g.neut (arr A B)] ->
                ({h:ctx} ({T:[.tp]} NeutVar [g] [. T] ->  NeutVar [h]  [. T]) ->
                 Sem [h] [ .A] -> Sem [h] [ . B])
=
fn r => mlam h => fn s => fn e =>
let [h. N .. ] = reify e in
let [h. R' .. ] = nsubst s r in
  reflect [h. rapp (R' ..) (N ..)]

and reify : Sem [g] [.A] -> [g. norm A] =
fn e => let (e : Sem [g] [.A]) = e in case [. A] of
| [. atomic P ] =>  (case e of Syn [g . R ..] => [g. embed (R ..)])
| [. arr T S ] =>
  (case e of
   | (Slam f)  =>
     let s = (f [g,x:neut T ] weaken (reflect [g ,x:neut T. x])) in
     let [g,x:neut T. E .. x] = reify s
     in [g. nlam (\x. E .. x)])
;

rec initialMap :  {T:[.tp]} TmVar [ ] [. T] -> Sem [ ] [.T] =
mlam T => fn y => let TmVar [.#p] = y in impossible [.#p] in [ ];

rec nbe : [. tm A] -> [. norm A] =
fn t => reify  (eval initialMap t)
;


